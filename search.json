[
  {
    "objectID": "Lessons/lesson11.html",
    "href": "Lessons/lesson11.html",
    "title": "5: Python开源项目复线与应用",
    "section": "",
    "text": "TBD"
  },
  {
    "objectID": "Lessons/lesson3.html",
    "href": "Lessons/lesson3.html",
    "title": "3: Python实用进阶",
    "section": "",
    "text": "当你熟练使用 VS Code 或 PyCharm 这样的 IDE 时，你会发现它们侧边栏上有一个绿色的“运行”按钮，以及强大的图形化调试（Debug）工具。这些功能非常高效，但我强烈建议你先“封印”它们。\n\n\n\n理解程序的真实运行环境\n你的 Python 代码最终是在操作系统中的一个进程里执行的，而不是在 IDE 的“魔法盒子”里。命令行就是这个真实环境最直接的交互窗口。理解 python your_script.py 这行命令的背后意义，比点击一个按钮要重要得多。它告诉你：“我正在调用 Python 解释器，让它来执行这个脚本文件。”\n掌握处理参数的能力\n真实世界的程序很少是“一键运行”就完事的。它们通常需要接收外部传入的参数来改变行为。例如，一个处理文件的脚本需要知道要处理哪个文件；一个数据转换工具需要知道输出格式是什么。这些参数都是通过命令行传入的。如果你只用 IDE 的运行按钮，你将失去练习这项核心技能的机会。\n学习更本质的调试方法\n图形化的 Debugger 非常强大，但它也隐藏了许多底层细节。pdb 是 Python 内置的命令行调试工具。学会使用它，意味着你可以在任何地方进行调试，哪怕是在一个没有图形界面的服务器上。这种能力是专业开发者必备的。它能让你更深刻地理解代码的执行流程、作用域和调用栈。\n\n当你真正理解了命令行的工作方式后，再回头去使用 IDE 的便捷功能，你就会明白那些按钮背后到底发生了什么，从而更好地驾驭这些工具，而不是成为它们的“囚徒”。",
    "crumbs": [
      "计算机工具简介",
      "3: Python实用进阶"
    ]
  },
  {
    "objectID": "Lessons/lesson3.html#进阶心法拥抱命令行",
    "href": "Lessons/lesson3.html#进阶心法拥抱命令行",
    "title": "3: Python实用进阶",
    "section": "",
    "text": "当你熟练使用 VS Code 或 PyCharm 这样的 IDE 时，你会发现它们侧边栏上有一个绿色的“运行”按钮，以及强大的图形化调试（Debug）工具。这些功能非常高效，但我强烈建议你先“封印”它们。\n\n\n\n理解程序的真实运行环境\n你的 Python 代码最终是在操作系统中的一个进程里执行的，而不是在 IDE 的“魔法盒子”里。命令行就是这个真实环境最直接的交互窗口。理解 python your_script.py 这行命令的背后意义，比点击一个按钮要重要得多。它告诉你：“我正在调用 Python 解释器，让它来执行这个脚本文件。”\n掌握处理参数的能力\n真实世界的程序很少是“一键运行”就完事的。它们通常需要接收外部传入的参数来改变行为。例如，一个处理文件的脚本需要知道要处理哪个文件；一个数据转换工具需要知道输出格式是什么。这些参数都是通过命令行传入的。如果你只用 IDE 的运行按钮，你将失去练习这项核心技能的机会。\n学习更本质的调试方法\n图形化的 Debugger 非常强大，但它也隐藏了许多底层细节。pdb 是 Python 内置的命令行调试工具。学会使用它，意味着你可以在任何地方进行调试，哪怕是在一个没有图形界面的服务器上。这种能力是专业开发者必备的。它能让你更深刻地理解代码的执行流程、作用域和调用栈。\n\n当你真正理解了命令行的工作方式后，再回头去使用 IDE 的便捷功能，你就会明白那些按钮背后到底发生了什么，从而更好地驾驭这些工具，而不是成为它们的“囚徒”。",
    "crumbs": [
      "计算机工具简介",
      "3: Python实用进阶"
    ]
  },
  {
    "objectID": "Lessons/lesson3.html#在命令行中处理参数",
    "href": "Lessons/lesson3.html#在命令行中处理参数",
    "title": "3: Python实用进阶",
    "section": "在命令行中处理参数",
    "text": "在命令行中处理参数\n让我们的脚本变得更实用！一个能接收参数的程序才算得上是一个真正的“工具”。\n\n方式一：使用 sys.argv（入门）\nPython 的 sys 模块提供了一个名为 argv 的列表，它可以捕获所有从命令行传入的参数。\n\nsys.argv 是一个列表（list）。\n列表的第一个元素 sys.argv[0] 永远是脚本文件自己的名字。\n从 sys.argv[1] 开始，依次是用户传入的参数。\n\n\n示例：greet_user.py\n\n# greet_user.py\nimport sys\n\n# 检查用户是否传入了足够多的参数\nif len(sys.argv) &gt; 1:\n    # sys.argv[0] 是脚本名 'greet_user.py'\n    # sys.argv[1] 是我们期望的第一个参数\n    name = sys.argv[1]\n    print(f\"你好，{name}！欢迎来到命令行世界。\")\nelse:\n    print(\"错误：请输入你的名字作为参数！\")\n    print(\"用法: python greet_user.py [你的名字]\")\n\n# 让我们看看 sys.argv 到底是什么\nprint(f\"\\ Debug Info\")\nprint(f\"sys.argv 的内容是: {sys.argv}\")\nprint(f\"总共有 {len(sys.argv)} 个元素。\")\n\n你好，-f！欢迎来到命令行世界。\n\\ Debug Info\nsys.argv 的内容是: ['/home/runner/.local/lib/python3.12/site-packages/ipykernel_launcher.py', '-f', '/tmp/tmptmwsljmo.json', '--HistoryManager.hist_file=:memory:']\n总共有 4 个元素。\n\n\n&lt;&gt;:15: SyntaxWarning:\n\ninvalid escape sequence '\\ '\n\n&lt;&gt;:15: SyntaxWarning:\n\ninvalid escape sequence '\\ '\n\n/tmp/ipykernel_2380/4007309989.py:15: SyntaxWarning:\n\ninvalid escape sequence '\\ '\n\n\n\n\n\n在命令行中运行它：\n不带参数运行：\npython greet_user.py\n输出：\n错误：请输入你的名字作为参数！\n用法: python greet_user.py [你的名字]\n Debug Info\nsys.argv 的内容是: ['greet_user.py']\n总共有 1 个元素。\n带一个参数运行：\npython greet_user.py 张三\n输出：\n你好，张三！欢迎来到命令行世界。\n Debug Info\nsys.argv 的内容是: ['greet_user.py', '张三']\n总共有 2 个元素。\n带多个参数运行：\npython greet_user.py \"张三\" \"来自北京\"\n如果你传入的参数包含空格，请用引号把它包起来。sys.argv 会把每个用空格隔开的单元（或引号包起来的整体）当作一个独立的参数。\n\n对于简单的脚本，sys.argv 足够好用。但当参数变得复杂时（例如需要处理 -f, --file 这样的选项），我们通常会使用更强大的 argparse 模块，你可以在学完基础后自行探索。\n\n\n\n\n方式二：使用 argparse（进阶推荐）\n有些脚本需要处理更多参数：选项、类型、默认值、帮助信息……这时候，推荐用 Python 标准库中的 argparse。\n\n什么是 argparse？\nargparse 能帮你自动解析命令行参数，自动生成帮助说明，还能支持多种参数类型、可选项、布尔开关等，非常适合写稍微复杂一点的命令行工具。\n\n\n示例：greet_user_argparse.py\n\nimport argparse\n\nparser = argparse.ArgumentParser(description=\"欢迎使用命令行问候脚本\")\nparser.add_argument('name', help='你的名字')\nparser.add_argument('--city', '-c', help='你来自的城市', default='未知')\n\nargs = parser.parse_args()\n\nprint(f\"你好，{args.name}！来自 {args.city}。欢迎来到命令行世界。\")\n\n\n\n运行效果：\n查看帮助：\npython greet_user_argparse.py --help\n输出：\nusage: greet_user_argparse.py [-h] [--city CITY] name\n\n欢迎使用命令行问候脚本\n\npositional arguments:\n  name           你的名字\n\noptions:\n  -h, --help     show this help message and exit\n  --city CITY, -c CITY\n                 你来自的城市\n带参数运行：\npython greet_user_argparse.py 张三\n输出：\n你好，张三！来自 未知。欢迎来到命令行世界。\n带全部参数运行：\npython greet_user_argparse.py 张三 --city 北京\n输出：\n你好，张三！来自 北京。欢迎来到命令行世界。\n\n\n为什么推荐 argparse？\n\n自动生成友好的帮助信息（-h/--help）\n支持位置参数、可选参数、类型检查、默认值等\n错误提示更友好\n写复杂命令行工具几乎必备\n\n\n建议：写任何对外开放的小工具，都推荐用 argparse 提升专业度和可维护性！",
    "crumbs": [
      "计算机工具简介",
      "3: Python实用进阶"
    ]
  },
  {
    "objectID": "Lessons/lesson3.html#使用-pdb-进行命令行调试",
    "href": "Lessons/lesson3.html#使用-pdb-进行命令行调试",
    "title": "3: Python实用进阶",
    "section": "使用 pdb 进行命令行调试",
    "text": "使用 pdb 进行命令行调试\n当你的代码出错了，或者你想观察代码的执行过程，print() 是最简单的调试方法，但它不够灵活。这时，pdb 就该登场了。\npdb 允许你在程序的任意位置设置一个“断点”，然后逐行执行代码，检查变量，让你像侦探一样剖析程序的每一步。\n\n如何启动 pdb？\n你只需要在你想要暂停的地方，加入下面这两行代码：\n\nimport pdb\npdb.set_trace()\n\n这就像在你的代码里设置了一个检查站。当程序运行到这里时，它会自动停下来，并给你一个 (Pdb) 的交互式提示符。\n\n\npdb 实战演练\n让我们来调试一个有问题的函数。创建一个文件 buggy_calculator.py：\n\nimport pdb\n\ndef calculate_sum(data_list):\n    total = 0\n    for item in data_list:\n        # 我们怀疑这里可能出问题，所以设置一个断点\n        pdb.set_trace() \n        total += item\n    return total\n\nnumbers = [1, 2, \"3\", 4, 5] # 列表中混入了一个字符串\nresult = calculate_sum(numbers)\nprint(f\"计算结果是: {result}\")\n\n\n在命令行运行这个脚本：\npython buggy_calculator.py\n当程序执行到 pdb.set_trace() 时，它会暂停，你的终端会显示类似这样的信息：\n&gt; /path/to/your/buggy_calculator.py(8)calculate_sum()\n-&gt; total += item\n(Pdb)\n你进入了 pdb 的调试环境！你可以输入不同的命令来控制和检查程序。",
    "crumbs": [
      "计算机工具简介",
      "3: Python实用进阶"
    ]
  },
  {
    "objectID": "Lessons/lesson3.html#pdb-常用核心命令",
    "href": "Lessons/lesson3.html#pdb-常用核心命令",
    "title": "3: Python实用进阶",
    "section": "pdb 常用核心命令",
    "text": "pdb 常用核心命令\n记住下面几个命令，你就能解决 80% 的问题：\n\nl (list): 查看当前代码及上下文。它会显示你正停在哪一行，以及周围的代码。\nn (next): 执行下一行代码。如果下一行是函数调用，它会直接执行完整个函数，不会进入函数内部。\ns (step): 执行下一行代码。如果下一行是函数调用，它会进入该函数内部，让你逐行调试函数里的代码。\nc (continue): 继续执行代码，直到遇到下一个断点或者程序结束。\np &lt;变量名&gt; (print): 打印一个变量的当前值。例如，输入 p total 或 p item。\nq (quit): 退出调试并终止程序。\n\n\n用这些命令找出 buggy_calculator.py 的问题\n程序停在了 total += item 这一行。我们先用 l 看一下代码：\n(Pdb) l\n  3     def calculate_sum(data_list):\n  4         total = 0\n  5         for item in data_list:\n  6             # 我们怀疑这里可能出问题，所以设置一个断点\n  7             import pdb; pdb.set_trace()\n  8  -&gt;         total += item\n  9         return total\n 10\n 11     numbers = [1, 2, \"3\", 4, 5] # 列表中混入了一个字符串\n 12     result = calculate_sum(numbers)\n我们想知道 total 和 item 当前的值。使用 p 命令：\n(Pdb) p total\n0\n(Pdb) p item\n1\n第一次循环没问题。我们让程序继续执行，进入下一次循环。输入 c：\n(Pdb) c\n程序会再次在断点处停下。再次检查变量：\n(Pdb) p total\n1\n(Pdb) p item\n2\n第二次循环也没问题。再次输入 c，进入第三次循环：\n(Pdb) c\n再次检查变量：\n(Pdb) p total\n3\n(Pdb) p item\n'3'\n啊哈！问题找到了！total 是整数 3，但 item 是字符串 '3'。整数和字符串不能直接用 + 相加，这会导致 TypeError。\n我们已经找到了 bug 的根源。现在输入 q 退出调试。\n(Pdb) q\n现在你知道了，问题在于 numbers 列表中的数据类型不统一。pdb 让你像用显微镜一样精确地定位了问题所在。",
    "crumbs": [
      "计算机工具简介",
      "3: Python实用进阶"
    ]
  },
  {
    "objectID": "Lessons/lesson3.html#pip-conda命令行下的包管理",
    "href": "Lessons/lesson3.html#pip-conda命令行下的包管理",
    "title": "3: Python实用进阶",
    "section": "pip & conda：命令行下的包管理",
    "text": "pip & conda：命令行下的包管理\n除了运行和调试脚本，命令行还有一项超级重要的用途——管理 Python 包和环境。\n\npip：Python 的官方包管理工具\n\n安装第三方库：\npip install requests\n查看已安装的包：\npip list\n升级包：\npip install --upgrade numpy\n卸载包：\npip uninstall requests\n指定安装版本：\npip install pandas==2.0.3\n导出依赖列表：\npip freeze &gt; requirements.txt\n根据依赖列表安装：\npip install -r requirements.txt\n\n\npip 是最常用的 Python 包管理工具，适合绝大部分纯 Python 包的安装。\n\n\n\nconda：强大的多语言环境和包管理器\n如果你用的是 Anaconda/Miniconda，或者需要管理依赖复杂、含有大量 C/C++ 库的包（如数据科学、机器学习领域常用的 numpy、pandas、scipy、pytorch 等），建议用 conda！\n\n创建新环境：\nconda create -n myenv python=3.10\n激活环境：\nconda activate myenv\n安装包：\nconda install numpy pandas matplotlib\n列出所有环境：\nconda env list\n导出环境配置：\nconda env export &gt; environment.yml\n根据配置文件还原环境：\nconda env create -f environment.yml\n删除环境：\nconda remove -n myenv --all\n\n\nconda 不仅能管理 Python 包，还能管理 R、Java、C/C++ 等语言的依赖，适合需要跨语言和复杂依赖的项目。",
    "crumbs": [
      "计算机工具简介",
      "3: Python实用进阶"
    ]
  },
  {
    "objectID": "Lessons/lesson3.html#总结",
    "href": "Lessons/lesson3.html#总结",
    "title": "3: Python实用进阶",
    "section": "总结",
    "text": "总结\n掌握命令行运行、参数传递、调试（pdb）、包管理（pip/conda），是从“会写 Python 代码”到“会用 Python 解决问题”的关键一步。这个过程也许比点击按钮更“麻烦”，但它会赋予你对程序更深刻的理解和更强的控制力。\n现在，去尝试修改 buggy_calculator.py，修复那个 bug，然后再次用命令行运行它吧！并试着用 pip 或 conda 安装你需要的包，用命令行一步步成长为真正的开发者！",
    "crumbs": [
      "计算机工具简介",
      "3: Python实用进阶"
    ]
  },
  {
    "objectID": "Lessons/lesson2.html",
    "href": "Lessons/lesson2.html",
    "title": "2: Python入门",
    "section": "",
    "text": "欢迎来到 Python 的世界！Python 是一种功能强大、用途广泛且极其易于学习的编程语言。无论你是想进入数据科学、人工智能、网站开发还是只想写一些自动化脚本，Python 都是绝佳的起点。\n本教程将从零开始，带你一步步掌握 Python 的核心知识。\n\n\n在开始编程之前，你需要在你的电脑上安装 Python 环境。\n检查是否已安装：\n打开你的终端（在 Windows 上是 命令提示符 或 PowerShell，在 macOS 或 Linux 上是 终端），然后输入：\npython --version\n或者（对于某些系统）：\npython3 --version\n如果你看到了类似 Python 3.x.x 的输出，那么恭喜你，Python 已经安装好了！如果提示命令未找到，或者版本是 2.x.x，我们强烈建议你安装最新的 Python 3 版本。\n下载和安装：\n\n访问 Python 官网：https://www.python.org/downloads/\n网站会自动检测你的操作系统并推荐合适的下载版本。点击 “Download Python” 按钮即可。\nWindows 用户请注意： 在安装过程中，请务必勾选 “Add Python to PATH” 这个选项，这会让后续操作方便很多。\n按照安装向导的提示完成安装即可。\n\nWindows安装教程\n\n\nMac自带Python\n\n\n代码编辑器推荐：\n虽然你可以用记事本写代码，但一个好的代码编辑器会让你的编程体验大大提升。对于初学者，我们推荐：\n\nVisual Studio Code (VS Code): 免费、功能强大，拥有庞大的插件生态系统。安装 Python 插件后会变得非常好用。\nPyCharm Community Edition: 由 JetBrains 公司开发的专业 Python IDE，社区版免费。\n\n\n\n\n这是编程界的传统，让我们用 Python 向世界问好。\n\n打开你的代码编辑器，新建一个文件，并将其命名为 hello.py（.py 是 Python 文件的标准扩展名）。\n在文件中输入以下代码：\n\n\nprint(\"Hello, World!\")\n\nHello, World!\n\n\n\n保存文件。\n打开终端，使用 cd 命令切换到你保存 hello.py 文件的目录。例如，如果文件在桌面上，你可以输入 cd Desktop。\n运行你的程序！在终端中输入：\n\npython hello.py\n或者（如果你的系统同时有 Python 2 和 3）：\npython3 hello.py\n你应该会在终端看到输出：\nHello, World!\n恭喜你！你已经成功运行了你的第一个 Python 程序。print() 是 Python 的一个内置函数，用于在屏幕上输出信息。\n\n\n\n\n\n注释是代码中不会被执行的部分，用于解释代码的功能，方便自己和他人阅读。\n\n单行注释： 使用 # 号。# 号之后的所有内容都会被忽略。\n\n\n# 这是一行注释，用来解释下面的代码\nprint(\"Hello, Python!\") # 这也是一行注释\n\nHello, Python!\n\n\n\n多行注释： 使用三个单引号 ''' 或三个双引号 \"\"\" 将注释内容包裹起来。\n\n\n'''\n这是一个多行注释。\n可以写很多行的说明文字。\n这部分内容不会被执行。\n'''\nprint(\"欢迎学习 Python！\")\n\n欢迎学习 Python！\n\n\n\n\n\n变量 (Variable) 就像一个带标签的盒子，你可以把数据放进去。在 Python 中，你不需要提前声明变量的类型，直接赋值即可。\n\n# 变量赋值\nmessage = \"你好，世界！\" # 字符串 (String)\nage = 20                # 整数 (Integer)\nprice = 99.99           # 浮点数 (Float)\nis_learning = True      # 布尔值 (Boolean)\n\n常见数据类型：\n\n字符串 (String / str): 文本信息，用单引号 ' ' 或双引号 \" \" 包裹。\n整数 (Integer / int): 没有小数部分的数字。\n浮点数 (Float / float): 带有小数部分的数字。\n布尔值 (Boolean / bool): 只有两个值 True (真) 和 False (假)，注意首字母大写。\n\n你可以使用 type() 函数来查看一个变量的数据类型：\n\nname = \"小明\"\nage = 18\nprint(type(name))  # 输出: &lt;class 'str'&gt;\nprint(type(age))   # 输出: &lt;class 'int'&gt;\n\n&lt;class 'str'&gt;\n&lt;class 'int'&gt;\n\n\n\n\n\n字符串是 Python 中最常用的数据类型之一。\n\n拼接 (Concatenation): 使用 + 号。\n\n\nfirst_name = \"张\"\nlast_name = \"三\"\nfull_name = first_name + last_name\nprint(full_name) # 输出: 张三\n\n张三\n\n\n\n格式化字符串 (f-string): 这是推荐的、更现代的字符串格式化方法。在字符串引号前加上 f，然后用 {} 包裹变量。\n\n\nname = \"小红\"\nage = 19\nintro = f\"我的名字是 {name}，我今年 {age} 岁了。\"\nprint(intro) # 输出: 我的名字是 小红，我今年 19 岁了。\n\n我的名字是 小红，我今年 19 岁了。\n\n\n\n常用方法:\n\n\ntext = \"  Python is Fun!  \"\nprint(text.lower())      # 全部转为小写: \"  python is fun!  \"\nprint(text.upper())      # 全部转为大写: \"  PYTHON IS FUN!  \"\nprint(text.strip())      # 去除首尾空格: \"Python is Fun!\"\nprint(text.replace(\"Fun\", \"Awesome\")) # 替换: \"  Python is Awesome!  \"\n\n  python is fun!  \n  PYTHON IS FUN!  \nPython is Fun!\n  Python is Awesome!  \n\n\n\n\n\n\n当我们需要存储一组数据时，就需要用到更复杂的数据结构。\n\n\n列表是一个有序的、可变的集合。你可以添加、删除或修改列表中的元素。用方括号 [] 定义。\n\n# 创建一个列表\nfruits = [\"苹果\", \"香蕉\", \"橙子\"]\nprint(fruits) # 输出: ['苹果', '香蕉', '橙子']\n\n# 访问元素（索引从 0 开始）\nprint(fruits[0]) # 输出: 苹果\nprint(fruits[1]) # 输出: 香蕉\n\n# 修改元素\nfruits[1] = \"西瓜\"\nprint(fruits) # 输出: ['苹果', '西瓜', '橙子']\n\n# 添加元素\nfruits.append(\"葡萄\") # 在末尾添加\nprint(fruits) # 输出: ['苹果', '西瓜', '橙子', '葡萄']\n\n# 删除元素\nfruits.remove(\"西瓜\")\nprint(fruits) # 输出: ['苹果', '橙子', '葡萄']\n\n# 获取列表长度\nprint(len(fruits)) # 输出: 3\n\n['苹果', '香蕉', '橙子']\n苹果\n香蕉\n['苹果', '西瓜', '橙子']\n['苹果', '西瓜', '橙子', '葡萄']\n['苹果', '橙子', '葡萄']\n3\n\n\n\n\n\n元组是一个有序的、不可变的集合。一旦创建，就不能修改。用圆括号 () 定义。\n\n# 创建一个元组\npoint = (10, 20)\nprint(point) # 输出: (10, 20)\n\n# 访问元素\nprint(point[0]) # 输出: 10\n\n# 尝试修改元组会报错\n# point[0] = 15 # 这行代码会引发 TypeError\n\n(10, 20)\n10\n\n\n\n何时使用元组？ 当你希望数据是只读的、不被意外修改时，例如坐标点、配置信息等。\n\n\n\n\n字典是一个无序的、键值对 (key-value) 的集合。每个元素都由一个唯一的 键 (key) 和对应的 值 (value) 组成。用花括号 {} 定义。\n\n# 创建一个字典\nstudent = {\n    \"name\": \"李四\",\n    \"age\": 22,\n    \"city\": \"北京\"\n}\nprint(student) # 输出: {'name': '李四', 'age': 22, 'city': '北京'}\n\n# 访问值 (通过键)\nprint(student[\"name\"]) # 输出: 李四\nprint(student[\"age\"])  # 输出: 22\n\n# 添加或修改键值对\nstudent[\"email\"] = \"lisi@example.com\" # 添加新键值对\nstudent[\"age\"] = 23                   # 修改已有的值\nprint(student) # 输出: {'name': '李四', 'age': 23, 'city': '北京', 'email': 'lisi@example.com'}\n\n# 删除键值对\ndel student[\"city\"]\nprint(student) # 输出: {'name': '李四', 'age': 23, 'email': 'lisi@example.com'}\n\n{'name': '李四', 'age': 22, 'city': '北京'}\n李四\n22\n{'name': '李四', 'age': 23, 'city': '北京', 'email': 'lisi@example.com'}\n{'name': '李四', 'age': 23, 'email': 'lisi@example.com'}\n\n\n\n\n\n\n流程控制让你的代码可以根据不同的条件执行不同的路径，或者重复执行某些任务。\n\n\n\nage = 18\n\nif age &lt; 18:\n    print(\"你是未成年人。\")\nelif age == 18:\n    print(\"你刚满 18 岁。\")\nelse:\n    print(\"你是成年人。\")\n\n# 注意：\n# 1. 条件后面要加冒号 :\n# 2. 下一级的代码块需要缩进（通常是 4 个空格）\n# 3. `elif` 是 \"else if\" 的缩写，可以有多个。\n# 4. `else` 是可选的。\n\n你刚满 18 岁。\n\n\n\n\n\n\n\nfor 循环用于遍历一个序列（如列表、元组、字符串或范围）。\n\n# 遍历列表\nfruits = [\"苹果\", \"香蕉\", \"橙子\"]\nfor fruit in fruits:\n    print(f\"我喜欢吃 {fruit}\")\n\n# 使用 range() 函数进行固定次数的循环\n# range(5) 会生成从 0 到 4 的数字序列\nfor i in range(5):\n    print(f\"这是第 {i+1} 次循环\")\n\n我喜欢吃 苹果\n我喜欢吃 香蕉\n我喜欢吃 橙子\n这是第 1 次循环\n这是第 2 次循环\n这是第 3 次循环\n这是第 4 次循环\n这是第 5 次循环\n\n\n\n\n\nwhile 循环在给定条件为 True 时会一直执行。\n\ncount = 0\nwhile count &lt; 5:\n    print(f\"当前的数字是: {count}\")\n    count = count + 1 # 必须更新循环变量，否则会造成无限循环！\n\nprint(\"循环结束！\")\n\n当前的数字是: 0\n当前的数字是: 1\n当前的数字是: 2\n当前的数字是: 3\n当前的数字是: 4\n循环结束！\n\n\n\n\n\n\n\n函数是一段可重复使用的代码块，用于执行特定的任务。使用函数可以使你的代码更有条理、更易于维护。\n\n\n\n# 定义一个简单的函数\ndef greet():\n    print(\"你好！欢迎使用本程序。\")\n\n# 调用函数\ngreet()\ngreet()\n\n你好！欢迎使用本程序。\n你好！欢迎使用本程序。\n\n\n\n\n\n函数可以接受输入（参数）并产生输出（返回值）。\n\n# 带参数的函数\ndef greet_user(name):\n    \"\"\"这是一个文档字符串，用于解释函数的功能。\"\"\"\n    print(f\"你好，{name}！\")\n\ngreet_user(\"小王\") # 输出: 你好，小王！\ngreet_user(\"小李\") # 输出: 你好，小李！\n\n\n# 带参数和返回值的函数\ndef add(a, b):\n    \"\"\"这个函数计算两个数的和并返回结果。\"\"\"\n    result = a + b\n    return result\n\nsum_result = add(5, 3)\nprint(f\"5 + 3 = {sum_result}\") # 输出: 5 + 3 = 8\n\n你好，小王！\n你好，小李！\n5 + 3 = 8\n\n\n\n\n\n\nPython 的强大之处在于其庞大的标准库和第三方库生态系统。\n\n模块 (Module): 一个 .py 文件就是一个模块。你可以使用 import 语句来使用其他模块中定义的函数或变量。\n库 (Library): 库是相关模块的集合。\n\n示例：使用 random 模块生成随机数\nrandom 是 Python 的一个标准库模块，无需额外安装。\n\nimport random # 导入 random 模块\n\n# 生成一个 1 到 10 之间的随机整数\nrandom_number = random.randint(1, 10)\nprint(f\"生成的随机数是: {random_number}\")\n\n# 从列表中随机选择一个元素\nfruits = [\"苹果\", \"香蕉\", \"橙子\", \"西瓜\"]\nrandom_fruit = random.choice(fruits)\nprint(f\"今天的水果是: {random_fruit}\")\n\n生成的随机数是: 4\n今天的水果是: 西瓜\n\n\n安装第三方库：\n如果想使用非标准库（例如用于数据分析的 pandas，或网络请求的 requests），你需要使用 pip（Python 的包管理器）来安装。\n打开终端并输入：\npip install requests\npip install pandas\n\n\n\nPython 支持面向对象编程（OOP, Object-Oriented Programming），这是一种模拟现实世界思考问题的方法。通过类和对象，我们可以组织更复杂的代码，构建出具有良好结构和可扩展性的程序。\n\n\n\n让代码更贴近现实世界，更容易理解和维护\n数据和功能绑定在一起，便于复用\n可以写出更大的项目，比如游戏、网站、软件等\n\n\n\n\n\n类是一个模板，用来描述一类事物的共同属性和行为。\n对象是根据类创建的具体实例。类好比蓝图，对象好比房子。\n\n举例：用类描述学生，每个学生就是一个对象。\n\nclass Student:\n    pass  # 空语句，暂时不定义内容\n\ns1 = Student()  # 创建一个学生对象\ns2 = Student()  # 再创建一个学生对象\n\n\n\n\n属性和方法是类的“成员”。\n- 属性（变量）：对象的状态或特征\n- 方法（函数）：对象的行为或动作\n\n\n\n每次创建对象时，都会自动调用 __init__\n用于给新对象赋初值\n\n\nclass Student:\n    def __init__(self, name, age):\n        self.name = name  # 实例属性\n        self.age = age\n\ns = Student(\"小明\", 18)\nprint(s.name) # 输出: 小明\nprint(s.age)  # 输出: 18\n\n小明\n18\n\n\n注意：self 总是指向当前对象本身。\n\n\n\n\n普通方法都必须有 self 参数，表示操作的是哪个对象\n\n\nclass Student:\n    def __init__(self, name):\n        self.name = name\n\n    def say_hello(self):\n        print(f\"大家好，我是{self.name}\")\n\ns = Student(\"小明\")\ns.say_hello()  # 输出: 大家好，我是小明\n\n大家好，我是小明\n\n\n\n\n\n\n实例属性：每个对象自己的数据，用 self.xxx 定义\n类属性：所有对象共享的数据，直接在类内定义\n\n\nclass Dog:\n    species = \"犬科\"  # 类属性\n\n    def __init__(self, name):\n        self.name = name  # 实例属性\n\ndog1 = Dog(\"旺财\")\ndog2 = Dog(\"小黑\")\nprint(dog1.species)  # 输出: 犬科\nprint(dog2.species)  # 输出: 犬科\n\n犬科\n犬科\n\n\n\n\n\n\n\n\n\n继承允许一个类（子类）获得另一个类（父类）的所有成员。\n方便代码复用，比如所有动物都会吃东西。\n\n\nclass Animal:\n    def eat(self):\n        print(\"吃东西\")\n\nclass Dog(Animal):\n    def bark(self):\n        print(\"汪汪！\")\n\nd = Dog()\nd.eat()  # 输出: 吃东西\nd.bark() # 输出: 汪汪！\n\n吃东西\n汪汪！\n\n\n\n\n\n\n子类可以重写父类的方法，实现不同的行为。\n\n\nclass Animal:\n    def speak(self):\n        print(\"动物叫\")\n\nclass Cat(Animal):\n    def speak(self):\n        print(\"喵喵！\")\n\nc = Cat()\nc.speak()  # 输出: 喵喵！\n\n喵喵！\n\n\n\n\n\n\n多态：同一个方法名，不同子类有不同实现，调用时自动选择对应的方法。\n\n\nclass Animal:\n    def speak(self):\n        print(\"动物叫\")\n\nclass Dog(Animal):\n    def speak(self):\n        self.bark()\n\n    def bark(self):\n        print(\"汪汪！\")\n\nclass Cat(Animal):\n    def speak(self):\n        print(\"喵喵！\")\n\nanimals = [Dog(), Cat()]\nfor animal in animals:\n    animal.speak()\n# 输出:\n# 汪汪！\n# 喵喵！\n\n汪汪！\n喵喵！\n\n\n\n\n\n\n\n封装就是隐藏对象的内部细节，只暴露必要的接口。\nPython 通过下划线约定变量/方法的访问权限。\n\n\n\n\n变量名\n说明\n\n\n\n\nname\n公有，外部可访问\n\n\n_name\n受保护，不建议外部访问\n\n\n__name\n私有，类外无法直接访问\n\n\n\n\nclass Person:\n    def __init__(self, name):\n        self.name = name      # 公有属性\n        self._age = 18        # 受保护属性\n        self.__salary = 5000  # 私有属性\n\n    def get_salary(self):\n        return self.__salary\n\np = Person(\"小李\")\nprint(p.name)       # 正常访问\nprint(p._age)       # 可以访问，但不建议\n# print(p.__salary)  # 会报错\nprint(p.get_salary()) # 推荐通过方法访问私有属性\n\n小李\n18\n5000\n\n\n\n\n\nPython 有很多以 双下划线开头和结尾的“魔法方法”，让对象参与各种内置操作。\n\n__init__：初始化对象\n__str__：定义 print(对象) 时的输出\n__len__：定义 len(对象) 的行为\n\n\nclass Book:\n    def __init__(self, title):\n        self.title = title\n\n    def __str__(self):\n        return f\"《{self.title}》\"\n\nb = Book(\"Python入门\")\nprint(b)  # 输出: 《Python入门》\n\n《Python入门》\n\n\n\n\n\n\nclass Student:\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def show(self):\n        print(f\"{self.name} 的成绩是 {self.score}\")\n\n# 管理多个学生\nstudents = [\n    Student(\"小明\", 90),\n    Student(\"小红\", 95),\n    Student(\"小刚\", 88)\n]\n\n# 遍历所有学生\nfor stu in students:\n    stu.show()\n\n小明 的成绩是 90\n小红 的成绩是 95\n小刚 的成绩是 88\n\n\n\n\n\n\n对象是什么？ 现实世界的事物，比如“小明”、一辆汽车、一本书\n类是什么？ 模型或模板，比如“学生类”、“汽车类”\n属性是什么？ 事物的特征，比如“姓名”、“颜色”\n方法是什么？ 事物的行为，比如“学习”、“启动”\n\n\n\n\n\n课程回放：\n\n\n讲义：\n讲义\n\n\n\n恭喜你完成了 Python 的基础入门！你现在已经掌握了编写简单 Python 程序所需的核心知识。\n接下来，你可以根据你的兴趣选择深入学习的方向：\n\n网站开发: 学习 Django 或 Flask 框架。\n数据科学/机器学习: 学习 NumPy, Pandas, Matplotlib, Scikit-learn 等库。\n自动化脚本: 深入学习文件操作、网络请求等。\n游戏开发: 探索 Pygame 库。\n\n最重要的一点是：多写代码，多练习！ 尝试解决一些小程序问题，比如：\n\n写一个简单的计算器。\n写一个猜数字游戏。\n写一个程序来整理你电脑上的文件。\n\n如果想系统学习Python，可阅读《Python编程从入门到实践》.",
    "crumbs": [
      "计算机工具简介",
      "2: Python入门"
    ]
  },
  {
    "objectID": "Lessons/lesson2.html#python-入门完全指南",
    "href": "Lessons/lesson2.html#python-入门完全指南",
    "title": "2: Python入门",
    "section": "",
    "text": "欢迎来到 Python 的世界！Python 是一种功能强大、用途广泛且极其易于学习的编程语言。无论你是想进入数据科学、人工智能、网站开发还是只想写一些自动化脚本，Python 都是绝佳的起点。\n本教程将从零开始，带你一步步掌握 Python 的核心知识。\n\n\n在开始编程之前，你需要在你的电脑上安装 Python 环境。\n检查是否已安装：\n打开你的终端（在 Windows 上是 命令提示符 或 PowerShell，在 macOS 或 Linux 上是 终端），然后输入：\npython --version\n或者（对于某些系统）：\npython3 --version\n如果你看到了类似 Python 3.x.x 的输出，那么恭喜你，Python 已经安装好了！如果提示命令未找到，或者版本是 2.x.x，我们强烈建议你安装最新的 Python 3 版本。\n下载和安装：\n\n访问 Python 官网：https://www.python.org/downloads/\n网站会自动检测你的操作系统并推荐合适的下载版本。点击 “Download Python” 按钮即可。\nWindows 用户请注意： 在安装过程中，请务必勾选 “Add Python to PATH” 这个选项，这会让后续操作方便很多。\n按照安装向导的提示完成安装即可。\n\nWindows安装教程\n\n\nMac自带Python\n\n\n代码编辑器推荐：\n虽然你可以用记事本写代码，但一个好的代码编辑器会让你的编程体验大大提升。对于初学者，我们推荐：\n\nVisual Studio Code (VS Code): 免费、功能强大，拥有庞大的插件生态系统。安装 Python 插件后会变得非常好用。\nPyCharm Community Edition: 由 JetBrains 公司开发的专业 Python IDE，社区版免费。\n\n\n\n\n这是编程界的传统，让我们用 Python 向世界问好。\n\n打开你的代码编辑器，新建一个文件，并将其命名为 hello.py（.py 是 Python 文件的标准扩展名）。\n在文件中输入以下代码：\n\n\nprint(\"Hello, World!\")\n\nHello, World!\n\n\n\n保存文件。\n打开终端，使用 cd 命令切换到你保存 hello.py 文件的目录。例如，如果文件在桌面上，你可以输入 cd Desktop。\n运行你的程序！在终端中输入：\n\npython hello.py\n或者（如果你的系统同时有 Python 2 和 3）：\npython3 hello.py\n你应该会在终端看到输出：\nHello, World!\n恭喜你！你已经成功运行了你的第一个 Python 程序。print() 是 Python 的一个内置函数，用于在屏幕上输出信息。\n\n\n\n\n\n注释是代码中不会被执行的部分，用于解释代码的功能，方便自己和他人阅读。\n\n单行注释： 使用 # 号。# 号之后的所有内容都会被忽略。\n\n\n# 这是一行注释，用来解释下面的代码\nprint(\"Hello, Python!\") # 这也是一行注释\n\nHello, Python!\n\n\n\n多行注释： 使用三个单引号 ''' 或三个双引号 \"\"\" 将注释内容包裹起来。\n\n\n'''\n这是一个多行注释。\n可以写很多行的说明文字。\n这部分内容不会被执行。\n'''\nprint(\"欢迎学习 Python！\")\n\n欢迎学习 Python！\n\n\n\n\n\n变量 (Variable) 就像一个带标签的盒子，你可以把数据放进去。在 Python 中，你不需要提前声明变量的类型，直接赋值即可。\n\n# 变量赋值\nmessage = \"你好，世界！\" # 字符串 (String)\nage = 20                # 整数 (Integer)\nprice = 99.99           # 浮点数 (Float)\nis_learning = True      # 布尔值 (Boolean)\n\n常见数据类型：\n\n字符串 (String / str): 文本信息，用单引号 ' ' 或双引号 \" \" 包裹。\n整数 (Integer / int): 没有小数部分的数字。\n浮点数 (Float / float): 带有小数部分的数字。\n布尔值 (Boolean / bool): 只有两个值 True (真) 和 False (假)，注意首字母大写。\n\n你可以使用 type() 函数来查看一个变量的数据类型：\n\nname = \"小明\"\nage = 18\nprint(type(name))  # 输出: &lt;class 'str'&gt;\nprint(type(age))   # 输出: &lt;class 'int'&gt;\n\n&lt;class 'str'&gt;\n&lt;class 'int'&gt;\n\n\n\n\n\n字符串是 Python 中最常用的数据类型之一。\n\n拼接 (Concatenation): 使用 + 号。\n\n\nfirst_name = \"张\"\nlast_name = \"三\"\nfull_name = first_name + last_name\nprint(full_name) # 输出: 张三\n\n张三\n\n\n\n格式化字符串 (f-string): 这是推荐的、更现代的字符串格式化方法。在字符串引号前加上 f，然后用 {} 包裹变量。\n\n\nname = \"小红\"\nage = 19\nintro = f\"我的名字是 {name}，我今年 {age} 岁了。\"\nprint(intro) # 输出: 我的名字是 小红，我今年 19 岁了。\n\n我的名字是 小红，我今年 19 岁了。\n\n\n\n常用方法:\n\n\ntext = \"  Python is Fun!  \"\nprint(text.lower())      # 全部转为小写: \"  python is fun!  \"\nprint(text.upper())      # 全部转为大写: \"  PYTHON IS FUN!  \"\nprint(text.strip())      # 去除首尾空格: \"Python is Fun!\"\nprint(text.replace(\"Fun\", \"Awesome\")) # 替换: \"  Python is Awesome!  \"\n\n  python is fun!  \n  PYTHON IS FUN!  \nPython is Fun!\n  Python is Awesome!  \n\n\n\n\n\n\n当我们需要存储一组数据时，就需要用到更复杂的数据结构。\n\n\n列表是一个有序的、可变的集合。你可以添加、删除或修改列表中的元素。用方括号 [] 定义。\n\n# 创建一个列表\nfruits = [\"苹果\", \"香蕉\", \"橙子\"]\nprint(fruits) # 输出: ['苹果', '香蕉', '橙子']\n\n# 访问元素（索引从 0 开始）\nprint(fruits[0]) # 输出: 苹果\nprint(fruits[1]) # 输出: 香蕉\n\n# 修改元素\nfruits[1] = \"西瓜\"\nprint(fruits) # 输出: ['苹果', '西瓜', '橙子']\n\n# 添加元素\nfruits.append(\"葡萄\") # 在末尾添加\nprint(fruits) # 输出: ['苹果', '西瓜', '橙子', '葡萄']\n\n# 删除元素\nfruits.remove(\"西瓜\")\nprint(fruits) # 输出: ['苹果', '橙子', '葡萄']\n\n# 获取列表长度\nprint(len(fruits)) # 输出: 3\n\n['苹果', '香蕉', '橙子']\n苹果\n香蕉\n['苹果', '西瓜', '橙子']\n['苹果', '西瓜', '橙子', '葡萄']\n['苹果', '橙子', '葡萄']\n3\n\n\n\n\n\n元组是一个有序的、不可变的集合。一旦创建，就不能修改。用圆括号 () 定义。\n\n# 创建一个元组\npoint = (10, 20)\nprint(point) # 输出: (10, 20)\n\n# 访问元素\nprint(point[0]) # 输出: 10\n\n# 尝试修改元组会报错\n# point[0] = 15 # 这行代码会引发 TypeError\n\n(10, 20)\n10\n\n\n\n何时使用元组？ 当你希望数据是只读的、不被意外修改时，例如坐标点、配置信息等。\n\n\n\n\n字典是一个无序的、键值对 (key-value) 的集合。每个元素都由一个唯一的 键 (key) 和对应的 值 (value) 组成。用花括号 {} 定义。\n\n# 创建一个字典\nstudent = {\n    \"name\": \"李四\",\n    \"age\": 22,\n    \"city\": \"北京\"\n}\nprint(student) # 输出: {'name': '李四', 'age': 22, 'city': '北京'}\n\n# 访问值 (通过键)\nprint(student[\"name\"]) # 输出: 李四\nprint(student[\"age\"])  # 输出: 22\n\n# 添加或修改键值对\nstudent[\"email\"] = \"lisi@example.com\" # 添加新键值对\nstudent[\"age\"] = 23                   # 修改已有的值\nprint(student) # 输出: {'name': '李四', 'age': 23, 'city': '北京', 'email': 'lisi@example.com'}\n\n# 删除键值对\ndel student[\"city\"]\nprint(student) # 输出: {'name': '李四', 'age': 23, 'email': 'lisi@example.com'}\n\n{'name': '李四', 'age': 22, 'city': '北京'}\n李四\n22\n{'name': '李四', 'age': 23, 'city': '北京', 'email': 'lisi@example.com'}\n{'name': '李四', 'age': 23, 'email': 'lisi@example.com'}\n\n\n\n\n\n\n流程控制让你的代码可以根据不同的条件执行不同的路径，或者重复执行某些任务。\n\n\n\nage = 18\n\nif age &lt; 18:\n    print(\"你是未成年人。\")\nelif age == 18:\n    print(\"你刚满 18 岁。\")\nelse:\n    print(\"你是成年人。\")\n\n# 注意：\n# 1. 条件后面要加冒号 :\n# 2. 下一级的代码块需要缩进（通常是 4 个空格）\n# 3. `elif` 是 \"else if\" 的缩写，可以有多个。\n# 4. `else` 是可选的。\n\n你刚满 18 岁。\n\n\n\n\n\n\n\nfor 循环用于遍历一个序列（如列表、元组、字符串或范围）。\n\n# 遍历列表\nfruits = [\"苹果\", \"香蕉\", \"橙子\"]\nfor fruit in fruits:\n    print(f\"我喜欢吃 {fruit}\")\n\n# 使用 range() 函数进行固定次数的循环\n# range(5) 会生成从 0 到 4 的数字序列\nfor i in range(5):\n    print(f\"这是第 {i+1} 次循环\")\n\n我喜欢吃 苹果\n我喜欢吃 香蕉\n我喜欢吃 橙子\n这是第 1 次循环\n这是第 2 次循环\n这是第 3 次循环\n这是第 4 次循环\n这是第 5 次循环\n\n\n\n\n\nwhile 循环在给定条件为 True 时会一直执行。\n\ncount = 0\nwhile count &lt; 5:\n    print(f\"当前的数字是: {count}\")\n    count = count + 1 # 必须更新循环变量，否则会造成无限循环！\n\nprint(\"循环结束！\")\n\n当前的数字是: 0\n当前的数字是: 1\n当前的数字是: 2\n当前的数字是: 3\n当前的数字是: 4\n循环结束！\n\n\n\n\n\n\n\n函数是一段可重复使用的代码块，用于执行特定的任务。使用函数可以使你的代码更有条理、更易于维护。\n\n\n\n# 定义一个简单的函数\ndef greet():\n    print(\"你好！欢迎使用本程序。\")\n\n# 调用函数\ngreet()\ngreet()\n\n你好！欢迎使用本程序。\n你好！欢迎使用本程序。\n\n\n\n\n\n函数可以接受输入（参数）并产生输出（返回值）。\n\n# 带参数的函数\ndef greet_user(name):\n    \"\"\"这是一个文档字符串，用于解释函数的功能。\"\"\"\n    print(f\"你好，{name}！\")\n\ngreet_user(\"小王\") # 输出: 你好，小王！\ngreet_user(\"小李\") # 输出: 你好，小李！\n\n\n# 带参数和返回值的函数\ndef add(a, b):\n    \"\"\"这个函数计算两个数的和并返回结果。\"\"\"\n    result = a + b\n    return result\n\nsum_result = add(5, 3)\nprint(f\"5 + 3 = {sum_result}\") # 输出: 5 + 3 = 8\n\n你好，小王！\n你好，小李！\n5 + 3 = 8\n\n\n\n\n\n\nPython 的强大之处在于其庞大的标准库和第三方库生态系统。\n\n模块 (Module): 一个 .py 文件就是一个模块。你可以使用 import 语句来使用其他模块中定义的函数或变量。\n库 (Library): 库是相关模块的集合。\n\n示例：使用 random 模块生成随机数\nrandom 是 Python 的一个标准库模块，无需额外安装。\n\nimport random # 导入 random 模块\n\n# 生成一个 1 到 10 之间的随机整数\nrandom_number = random.randint(1, 10)\nprint(f\"生成的随机数是: {random_number}\")\n\n# 从列表中随机选择一个元素\nfruits = [\"苹果\", \"香蕉\", \"橙子\", \"西瓜\"]\nrandom_fruit = random.choice(fruits)\nprint(f\"今天的水果是: {random_fruit}\")\n\n生成的随机数是: 4\n今天的水果是: 西瓜\n\n\n安装第三方库：\n如果想使用非标准库（例如用于数据分析的 pandas，或网络请求的 requests），你需要使用 pip（Python 的包管理器）来安装。\n打开终端并输入：\npip install requests\npip install pandas\n\n\n\nPython 支持面向对象编程（OOP, Object-Oriented Programming），这是一种模拟现实世界思考问题的方法。通过类和对象，我们可以组织更复杂的代码，构建出具有良好结构和可扩展性的程序。\n\n\n\n让代码更贴近现实世界，更容易理解和维护\n数据和功能绑定在一起，便于复用\n可以写出更大的项目，比如游戏、网站、软件等\n\n\n\n\n\n类是一个模板，用来描述一类事物的共同属性和行为。\n对象是根据类创建的具体实例。类好比蓝图，对象好比房子。\n\n举例：用类描述学生，每个学生就是一个对象。\n\nclass Student:\n    pass  # 空语句，暂时不定义内容\n\ns1 = Student()  # 创建一个学生对象\ns2 = Student()  # 再创建一个学生对象\n\n\n\n\n属性和方法是类的“成员”。\n- 属性（变量）：对象的状态或特征\n- 方法（函数）：对象的行为或动作\n\n\n\n每次创建对象时，都会自动调用 __init__\n用于给新对象赋初值\n\n\nclass Student:\n    def __init__(self, name, age):\n        self.name = name  # 实例属性\n        self.age = age\n\ns = Student(\"小明\", 18)\nprint(s.name) # 输出: 小明\nprint(s.age)  # 输出: 18\n\n小明\n18\n\n\n注意：self 总是指向当前对象本身。\n\n\n\n\n普通方法都必须有 self 参数，表示操作的是哪个对象\n\n\nclass Student:\n    def __init__(self, name):\n        self.name = name\n\n    def say_hello(self):\n        print(f\"大家好，我是{self.name}\")\n\ns = Student(\"小明\")\ns.say_hello()  # 输出: 大家好，我是小明\n\n大家好，我是小明\n\n\n\n\n\n\n实例属性：每个对象自己的数据，用 self.xxx 定义\n类属性：所有对象共享的数据，直接在类内定义\n\n\nclass Dog:\n    species = \"犬科\"  # 类属性\n\n    def __init__(self, name):\n        self.name = name  # 实例属性\n\ndog1 = Dog(\"旺财\")\ndog2 = Dog(\"小黑\")\nprint(dog1.species)  # 输出: 犬科\nprint(dog2.species)  # 输出: 犬科\n\n犬科\n犬科\n\n\n\n\n\n\n\n\n\n继承允许一个类（子类）获得另一个类（父类）的所有成员。\n方便代码复用，比如所有动物都会吃东西。\n\n\nclass Animal:\n    def eat(self):\n        print(\"吃东西\")\n\nclass Dog(Animal):\n    def bark(self):\n        print(\"汪汪！\")\n\nd = Dog()\nd.eat()  # 输出: 吃东西\nd.bark() # 输出: 汪汪！\n\n吃东西\n汪汪！\n\n\n\n\n\n\n子类可以重写父类的方法，实现不同的行为。\n\n\nclass Animal:\n    def speak(self):\n        print(\"动物叫\")\n\nclass Cat(Animal):\n    def speak(self):\n        print(\"喵喵！\")\n\nc = Cat()\nc.speak()  # 输出: 喵喵！\n\n喵喵！\n\n\n\n\n\n\n多态：同一个方法名，不同子类有不同实现，调用时自动选择对应的方法。\n\n\nclass Animal:\n    def speak(self):\n        print(\"动物叫\")\n\nclass Dog(Animal):\n    def speak(self):\n        self.bark()\n\n    def bark(self):\n        print(\"汪汪！\")\n\nclass Cat(Animal):\n    def speak(self):\n        print(\"喵喵！\")\n\nanimals = [Dog(), Cat()]\nfor animal in animals:\n    animal.speak()\n# 输出:\n# 汪汪！\n# 喵喵！\n\n汪汪！\n喵喵！\n\n\n\n\n\n\n\n封装就是隐藏对象的内部细节，只暴露必要的接口。\nPython 通过下划线约定变量/方法的访问权限。\n\n\n\n\n变量名\n说明\n\n\n\n\nname\n公有，外部可访问\n\n\n_name\n受保护，不建议外部访问\n\n\n__name\n私有，类外无法直接访问\n\n\n\n\nclass Person:\n    def __init__(self, name):\n        self.name = name      # 公有属性\n        self._age = 18        # 受保护属性\n        self.__salary = 5000  # 私有属性\n\n    def get_salary(self):\n        return self.__salary\n\np = Person(\"小李\")\nprint(p.name)       # 正常访问\nprint(p._age)       # 可以访问，但不建议\n# print(p.__salary)  # 会报错\nprint(p.get_salary()) # 推荐通过方法访问私有属性\n\n小李\n18\n5000\n\n\n\n\n\nPython 有很多以 双下划线开头和结尾的“魔法方法”，让对象参与各种内置操作。\n\n__init__：初始化对象\n__str__：定义 print(对象) 时的输出\n__len__：定义 len(对象) 的行为\n\n\nclass Book:\n    def __init__(self, title):\n        self.title = title\n\n    def __str__(self):\n        return f\"《{self.title}》\"\n\nb = Book(\"Python入门\")\nprint(b)  # 输出: 《Python入门》\n\n《Python入门》\n\n\n\n\n\n\nclass Student:\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def show(self):\n        print(f\"{self.name} 的成绩是 {self.score}\")\n\n# 管理多个学生\nstudents = [\n    Student(\"小明\", 90),\n    Student(\"小红\", 95),\n    Student(\"小刚\", 88)\n]\n\n# 遍历所有学生\nfor stu in students:\n    stu.show()\n\n小明 的成绩是 90\n小红 的成绩是 95\n小刚 的成绩是 88\n\n\n\n\n\n\n对象是什么？ 现实世界的事物，比如“小明”、一辆汽车、一本书\n类是什么？ 模型或模板，比如“学生类”、“汽车类”\n属性是什么？ 事物的特征，比如“姓名”、“颜色”\n方法是什么？ 事物的行为，比如“学习”、“启动”\n\n\n\n\n\n课程回放：\n\n\n讲义：\n讲义\n\n\n\n恭喜你完成了 Python 的基础入门！你现在已经掌握了编写简单 Python 程序所需的核心知识。\n接下来，你可以根据你的兴趣选择深入学习的方向：\n\n网站开发: 学习 Django 或 Flask 框架。\n数据科学/机器学习: 学习 NumPy, Pandas, Matplotlib, Scikit-learn 等库。\n自动化脚本: 深入学习文件操作、网络请求等。\n游戏开发: 探索 Pygame 库。\n\n最重要的一点是：多写代码，多练习！ 尝试解决一些小程序问题，比如：\n\n写一个简单的计算器。\n写一个猜数字游戏。\n写一个程序来整理你电脑上的文件。\n\n如果想系统学习Python，可阅读《Python编程从入门到实践》.",
    "crumbs": [
      "计算机工具简介",
      "2: Python入门"
    ]
  },
  {
    "objectID": "Lessons/lesson4.html",
    "href": "Lessons/lesson4.html",
    "title": "1: Git与GitHub的应用",
    "section": "",
    "text": "欢迎来到版本控制的世界！本指南将带你深入了解 Git 和 GitHub，从基本概念到日常协作流程，并使用图表让复杂的概念变得一目了然。无论你是编程新手还是想系统学习的开发者，这篇教程都将是你的得力助手。\n\n\n想象一下你正在进行一个复杂的项目，无论是写代码、写论文还是设计作品。你一定会遇到以下问题：\n\n混乱的文件管理：项目_v1.zip, 项目_v2_final.zip, 项目_final_final_我发誓是最终版.zip… 这种方式既原始又低效。\n无法追溯的错误：你今天写的代码导致整个项目无法运行，但你不记得昨天做了哪些修改，想恢复到之前的版本变得异常困难。\n协作冲突：你和你的同伴修改了同一个文件，当你们试图合并工作时，一个人的修改覆盖了另一个人的，造成了“代码冲突”的噩梦。\n\n版本控制系统 (Version Control System, VCS) 正是为解决这些问题而生的。\nGit 是当今最流行、最强大的分布式版本控制系统。它就像一个精密的时光机和协作中心，能够：\n\n记录每一次变更：对文件的每一次增、删、改，Git 都会拍下一张“快照”(snapshot)。\n随时回溯历史：你可以轻松地将整个项目恢复到过去的任意一个“快照”状态。\n支持并行开发：通过“分支”功能，团队成员可以在不互相干扰的独立空间里开发新功能。\n高效解决冲突：当不同人的修改发生冲突时，Git 提供了工具来帮助你清晰地合并它们。\n\nGitHub 又是什么呢？ 它是一个基于云的代码托管平台。如果说 Git 是你本地的“时光机”，那 GitHub 就是这个“时光机”的云端枢纽和社交网络。它提供了：\n\n远程仓库：一个安全的地方来存储你的代码和所有版本历史。\n协作工具：强大的 Pull Request、Code Review 和 Issue Tracking 功能，让团队协作变得前所未有的高效。\n个人名片：一个展示你技术实力的平台，你的 GitHub 主页就是程序员最好的简历。\n\n总结：Git 是工具，负责版本控制；GitHub 是平台，负责代码托管与协作。\n\n\n\n\n\n\nWindows: 访问 git-scm.com/download/win 下载安装包。安装时，建议一路使用默认选项，它会自动安装 Git Bash，一个在 Windows 上模拟 Linux 命令行的强大工具。\nmacOS:\n\n最简单的方式是安装 Xcode Command Line Tools。打开“终端”(Terminal) 并输入 xcode-select --install。\n或者使用 Homebrew (推荐) 安装：brew install git。\n\nLinux (Debian/Ubuntu): 打开终端并输入 sudo apt-get install git。\n\n安装后，打开终端 (或 Git Bash) 输入 git --version，如果看到版本号，说明安装成功。\n\n\n\n安装 Git 后，第一件事就是设置你的用户名和邮箱。这个身份信息会附加到你的每一次“提交”(commit) 上，让别人知道是谁做的修改。\n# 设置你的 GitHub 用户名\ngit config --global user.name \"Your GitHub Username\"\n\n# 设置你的 GitHub 注册邮箱\ngit config --global user.email \"your.email@example.com\"\n--global 标志表示这是全局配置，你电脑上所有的 Git 项目都会默认使用这个配置。\n\n\n\n\nGit 的核心在于其三个主要区域的流转。理解了这个模型，你就理解了 Git 的一半。\n\n工作区 (Working Directory): 你在电脑上能直接看到和编辑的项目文件夹。\n暂存区 (Staging Area/Index): 一个虚拟的区域，用于临时存放你希望包含在下一次提交中的变更。它像一个购物车的概念，你可以把修改好的东西一件件放进去，最后统一“结账”。\n本地仓库 (Local Repository): .git 隐藏文件夹，存放了项目所有的版本历史“快照”。一旦变更被提交到这里，它就永久地记录下来了。\n\n\n\n下面这张图清晰地展示了文件在三个区域之间的流转过程：\n\n\n\n\n\ngraph TD\n    A[\"工作区&lt;br&gt;(Working Directory)\"] -- \"git add\" --&gt; B[\"暂存区&lt;br&gt;(Staging Area)\"]\n    B -- \"git commit\" --&gt; C[\"本地仓库&lt;br&gt;(Local Repository)\"]\n    C -- \"git checkout\" --&gt; A\n    A -- \"编辑文件&lt;br&gt;(Edit files)\" --&gt; A\n\n\n\n\n\n\n\n\n\n\n初始化仓库 (git init)\n\n在电脑上创建一个新文件夹，例如 git-project。\n通过终端进入该文件夹：cd path/to/git-project。\n执行初始化命令： bash     git init 这个命令会在当前目录下创建一个名为 .git 的子目录，你的本地仓库就此诞生。\n\n检查状态 (git status) git status 是你最应该频繁使用的命令。它会告诉你当前仓库的状态：哪些文件被修改了？哪些文件在暂存区？\n创建文件并添加到暂存区 (git add)\n\n在 git-project 文件夹中创建一个 README.md 文件，并写入 “Hello, Git!”。\n现在运行 git status，你会看到 README.md 出现在 “Untracked files” (未跟踪文件) 列表中。\n使用 git add 命令来跟踪这个文件，并将其变更放入暂存区。\n# 添加指定文件到暂存区\ngit add README.md\n\n# 如果想添加所有已修改或新增的文件，使用点号\n# git add .\n再次运行 git status，你会看到 README.md 现在处于 “Changes to be committed” (待提交的变更) 列表中。\n\n提交变更到仓库 (git commit) 当暂存区里的内容准备就绪后，就可以使用 git commit 将它们“拍摄快照”并存入本地仓库。\n# -m 参数允许你直接在命令行提供提交信息\ngit commit -m \"Initial commit: Create README.md\"\n编写好的 Commit Message 至关重要！ 它应该简洁明了地描述本次提交的目的。一个好的习惯是使用 “动词+宾语” 的格式，例如 “Fix: user login bug” 或 “Feat: add user profile page”。\n查看提交历史 (git log) 想回顾你走过的路吗？git log 会按时间倒序列出所有的提交记录，包括哈希值 (唯一ID)、作者、日期和提交信息。\n\n\n\n\n\n现在，你的项目只存在于你的电脑上。让我们把它推送到 GitHub，实现云端备份和远程协作。\n\n\n\n\n\n\n\ngraph TD\n    subgraph \"Your Computer\"\n        A[\"本地仓库(Local Repo)\"]\n    end\n\n    subgraph \"GitHub Cloud\"\n        B[\"远程仓库(Remote Repo)\"]\n    end\n\n    A -- \"git push\" --&gt; B\n    B -- \"git pull / git clone\" --&gt; A\n\n\n\n\n\n\n\n\n\n\n在 GitHub 创建远程仓库\n\n登录 GitHub，点击右上角 “+” -&gt; “New repository”。\n填写仓库名称 (建议与本地文件夹同名，如 git-project)。\n保持 “Public” (公开) 或选择 “Private” (私有)。\n非常重要：不要勾选任何 “Initialize this repository with…” 的选项，因为我们已经有了一个本地仓库。\n点击 “Create repository”。\n\n关联本地与远程 (git remote add) 创建后，GitHub 会提供一个 URL。复制这个 HTTPS 或 SSH 格式的 URL。回到你的终端，运行：\n# 将 '你的仓库URL' 替换成你刚刚复制的地址\ngit remote add origin 你的仓库URL\n\ngit remote add：添加一个远程仓库的引用。\norigin：是这个远程仓库的默认别名，你也可以取别的名字，但 origin 是约定俗成的。\n\n推送本地变更 (git push) 最后，将你本地 main 分支上的所有提交推送到远程仓库 origin。\ngit push -u origin main\n\npush：推送动作。\n-u (或 --set-upstream)：建立本地 main 分支与远程 origin/main 分支的联系。这个参数只需要在第一次推送时使用。之后，你只需要简单地运行 git push。\norigin：远程仓库的别名。\nmain：你要推送的本地分支名。\n\n现在，刷新你的 GitHub 仓库页面，代码已经成功上传！\n\n\n\n\n\n分支 (Branch) 是 Git 最强大的功能之一。它允许你从主线 (通常是 main 分支) 创建一个独立的副本，在新功能开发、Bug 修复等工作中，你可以在这个副本上自由地实验，而不会影响到主线的稳定性。\n\n\n\n\n\n\n\ngitGraph\n   commit id: \"Initial\"\n   branch feature-A\n   checkout feature-A\n   commit id: \"Add button\"\n   commit id: \"Style button\"\n   checkout main\n   merge feature-A\n   commit id: \"Release v1.0\"\n\n\n\n\n\n\n上图展示了：\n\n从 main 分支创建了一个 feature-A 分支。\n在 feature-A 上进行了两次提交 (开发新功能)。\n开发完成后，切换回 main 分支。\n将 feature-A 分支上的所有工作合并 (merge) 回 main 分支。\n\n\n\n\n\n查看所有分支:\ngit branch\n星号 * 标记的是你当前所在的分支。\n创建新分支:\ngit branch &lt;分支名&gt;\n# 例如: git branch new-feature\n切换分支:\ngit checkout &lt;分支名&gt;\n# 例如: git checkout new-feature\n创建并立即切换到新分支 (常用):\ngit checkout -b &lt;新分支名&gt;\n# 例如: git checkout -b another-feature\n合并分支: 首先，切换到你希望接纳变更的分支 (目标分支)，通常是 main。\ngit checkout main\n然后，执行合并命令，将其他分支的变更合并进来。\ngit merge &lt;要合并的分支名&gt;\n# 例如: git merge new-feature\n删除分支: 当一个分支的工作已经合并完成，通常会将其删除以保持仓库整洁。\ngit branch -d &lt;分支名&gt;\n\n\n\n\n\n\n\n\n\n\n%%{init: { 'logLevel': 'debug', 'theme': 'base', 'gitGraph': {'showBranches': true, 'showCommitLabel': true, 'mainBranchName': 'main'}} }%%\ngitGraph\n    commit id: \"初始化项目\"\n    branch develop\n    checkout develop\n    commit id: \"开发环境配置\"\n    \n    %% --- 功能A开发 ---\n    branch feat/user-login\n    checkout feat/user-login\n    commit id: \"实现UI界面\"\n    commit id: \"完成后端API对接\"\n    \n    %% --- 在功能A开发的同时，主干发现紧急bug ---\n    checkout main\n    branch hotfix/bug-payment-api\n    checkout hotfix/bug-payment-api\n    commit id: \"紧急修复支付掉单Bug\"\n    checkout main\n    merge hotfix/bug-payment-api tag: \"v1.0.1\"\n    \n    %% --- 紧急修复也需要合并到develop分支 ---\n    checkout develop\n    merge main id: \"同步紧急修复\"\n    \n    %% --- 功能A开发完成，合并回develop ---\n    checkout develop\n    merge feat/user-login id: \"合并用户登录功能\"\n    \n    %% --- 功能B开始开发 ---\n    branch feat/data-report\n    checkout feat/data-report\n    commit id: \"设计报表模型\"\n    commit id: \"完成报表前端\"\n    checkout develop\n    \n    %% --- 功能C也开始开发 ---\n    branch feat/performance-opt\n    checkout feat/performance-opt\n    commit id: \"优化数据库查询\"\n    \n    %% --- 功能B开发完成，合并回develop ---\n    checkout develop\n    merge feat/data-report id: \"合并数据报表功能\"\n    \n    %% --- 功能C开发完成，合并回develop ---\n    checkout develop\n    merge feat/performance-opt id: \"合并性能优化\"\n    \n    %% --- 准备发布新版本 ---\n    branch release/v1.1.0\n    checkout release/v1.1.0\n    commit id: \"版本文档和最终测试\"\n    \n    %% --- 正式发布：合并到main并打上标签 ---\n    checkout main\n    merge release/v1.1.0 tag: \"v1.1.0\"\n    \n    %% --- 将发布分支的修改也合并回develop ---\n    checkout develop\n    merge release/v1.1.0 id: \"同步发布版本v1.1.0的修改\"\n\n\n\n\n\n\n\n在真实的项目中，你通常会从一个已经存在的项目开始工作。\n\n克隆远程仓库 (git clone) 要获取 GitHub 上的项目到你的本地，使用 git clone。\n# 替换为项目的URL\ngit clone https://github.com/some-user/some-project.git\n这个命令会自动创建项目文件夹，初始化 .git 仓库，并自动设置好远程别名 origin，还会将项目的所有数据都拉取下来。\n保持本地更新 (git pull) 在你开始一天的工作前，或者在准备开发新功能前，务必从远程仓库拉取最新的变更，确保你的本地版本是最新的。\ngit pull origin main\n# 如果已经设置了上游分支，可以直接用 git pull\ngit pull 实际上是 git fetch (从远程拉取最新数据) 和 git merge (将远程分支合并到本地) 的一个快捷命令。\nGitHub Flow：一个标准的协作模型 这是一个被广泛采用的、简单高效的协作流程：\n\n从 main 分支创建一个描述性命名的新分支 (git checkout -b fix-login-bug)。\n在新分支上进行编码和提交。\n将你的新分支推送到 GitHub (git push origin fix-login-bug)。\n在 GitHub 上，为你的分支创建一个 Pull Request (PR)。PR 是一个请求，请求项目维护者审查你的代码，并将其合并到 main 分支。\n团队成员在 PR 上进行讨论和代码审查 (Code Review)。\n一旦审查通过，项目维护者会在 GitHub 网站上点击合并 (Merge Pull Request) 按钮。\n合并后，你可以安全地删除你的功能分支。\n\n\n\n\n\n现在，你已经掌握了 Git 和 GitHub 的核心技能，是时候将它们付诸实践，创建一个所有开发者都梦寐以求的“技术名片”——你的个人网站。GitHub 提供了一项名为 GitHub Pages 的免费服务，可以让你轻松地将你的代码仓库变成一个公开的网站。\n\n\n网页是由三种核心技术构建的：\n\nHTML (HyperText Markup Language): 定义了网页的结构和内容。比如，标题、段落、图片、链接等。\nCSS (Cascading Style Sheets): 负责网页的样式和外观。比如，颜色、字体、布局、边距等。\nJavaScript: 赋予网页交互性和动态功能。比如，响应用户点击、表单验证、动画效果等。\n\n我们将创建一个只包含 HTML 和 CSS 的简单静态页面，并将其部署到 GitHub Pages。\n\n\n\n\n创建一个特殊的仓库 登录 GitHub。点击右上角的“+”号，选择 “New repository”。这一步至关重要：\n\nRepository name (仓库名称) 必须是 &lt;你的GitHub用户名&gt;.github.io。例如，如果你的用户名是 octocat，那么仓库名必须是 octocat.github.io。\n必须设置为 Public (公开)。\n可以勾选 “Add a README file” 来初始化仓库，这会使后续的克隆操作更简单。\n\n克隆仓库到本地 进入你刚刚创建的仓库页面，点击绿色的 “&lt;&gt; Code” 按钮，复制 HTTPS URL。然后，在你的电脑终端中运行 git clone：\n# 将URL替换为你自己的仓库URL\ngit clone https://github.com/YourUsername/yourusername.github.io.git\n创建你的主页文件 使用 cd 命令进入刚刚克隆下来的文件夹：\ncd yourusername.github.io\n创建一个名为 index.html 的文件。这个文件名是特殊的，当别人访问你的网站时，GitHub Pages 会默认显示这个文件的内容。在 index.html 文件中写入以下基础 HTML 代码：\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"zh-CN\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;我的个人主页&lt;/title&gt;\n    &lt;style&gt;\n        body { font-family: sans-serif; line-height: 1.6; margin: 40px; background-color: #f4f4f4; color: #333; }\n        .container { max-width: 800px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }\n        h1 { color: #0366d6; }\n        a { color: #0366d6; text-decoration: none; }\n        a:hover { text-decoration: underline; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;h1&gt;欢迎来到我的世界！&lt;/h1&gt;\n        &lt;p&gt;你好，我是 [你的名字]。这是我用 GitHub Pages 搭建的个人网站。&lt;/p&gt;\n        &lt;p&gt;你可以在 &lt;a href=\"https://github.com/YourUsername\" target=\"_blank\"&gt;这里&lt;/a&gt; 找到我的 GitHub 主页，关注我的开源项目。&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n提示: 记得将 [你的名字] 和 YourUsername 替换成你自己的信息。\n\n提交并推送到 GitHub 现在，按照我们学过的标准 Git 流程，将你的新主页上传到 GitHub。\n# 1. 将所有新文件和修改添加到暂存区\ngit add .\n\n# 2. 提交变更，并附上有意义的信息\ngit commit -m \"Feat: Create initial homepage\"\n\n# 3. 将本地提交推送到远程仓库\ngit push origin main\n在 GitHub Settings 中配置 Pages 默认情况下，名为 &lt;username&gt;.github.io 的仓库会自动启用 GitHub Pages。但了解设置过程对所有项目都至关重要。\n\n在浏览器中打开你的 GitHub 仓库页面。\n点击仓库导航栏右侧的 “Settings” 标签。\n在左侧的菜单中，找到并点击 “Pages”。\n在 “Build and deployment” (构建与部署) 部分，你会看到 “Source” (源) 的选项。请确保它的设置为 “Deploy from a branch” (从分支部署)。\n在下方的 “Branch” (分支) 设置中：\n\n\n选择你刚刚推送代码的分支，通常是 main (或者 master)。\n文件夹选项保持默认的 / (root)。\n点击 “Save”。\n\n\n保存后，页面顶部会出现一个蓝色的提示框，告诉你 “Your site is live at https://&lt;你的用户名&gt;.github.io”。有时，GitHub 需要一两分钟来完成部署（这个过程被称为 Action）。你可以点击提示框中的链接查看你的网站。\n\n见证奇迹！ 访问 https://&lt;你的GitHub用户名&gt;.github.io，你应该就能看到你刚刚创建的、拥有简单样式的个人主页了！\n\n现在，你拥有了一个可以向全世界展示的个人网站。你可以继续学习 HTML 和 CSS 来美化它，或者添加你的项目作品集，让它成为你真正的在线简历。\n\n\n\n\n恭喜你完成了这份详细的指南！现在你应该对 Git 和 GitHub 有了扎实的理解。\n\n核心理念：版本控制是为了追踪历史和促进协作。\n本地三区：工作区 -&gt; git add -&gt; 暂存区 -&gt; git commit -&gt; 本地仓库。\n远程交互：git clone 开始，git pull 更新，git push 分享。\n分支是关键：始终在独立的分支上工作，通过 Pull Request 合并，以保证 main 分支的稳定。",
    "crumbs": [
      "计算机实战应用",
      "1: Git与GitHub的应用"
    ]
  },
  {
    "objectID": "Lessons/lesson4.html#git-与-github-入门指南",
    "href": "Lessons/lesson4.html#git-与-github-入门指南",
    "title": "1: Git与GitHub的应用",
    "section": "",
    "text": "欢迎来到版本控制的世界！本指南将带你深入了解 Git 和 GitHub，从基本概念到日常协作流程，并使用图表让复杂的概念变得一目了然。无论你是编程新手还是想系统学习的开发者，这篇教程都将是你的得力助手。\n\n\n想象一下你正在进行一个复杂的项目，无论是写代码、写论文还是设计作品。你一定会遇到以下问题：\n\n混乱的文件管理：项目_v1.zip, 项目_v2_final.zip, 项目_final_final_我发誓是最终版.zip… 这种方式既原始又低效。\n无法追溯的错误：你今天写的代码导致整个项目无法运行，但你不记得昨天做了哪些修改，想恢复到之前的版本变得异常困难。\n协作冲突：你和你的同伴修改了同一个文件，当你们试图合并工作时，一个人的修改覆盖了另一个人的，造成了“代码冲突”的噩梦。\n\n版本控制系统 (Version Control System, VCS) 正是为解决这些问题而生的。\nGit 是当今最流行、最强大的分布式版本控制系统。它就像一个精密的时光机和协作中心，能够：\n\n记录每一次变更：对文件的每一次增、删、改，Git 都会拍下一张“快照”(snapshot)。\n随时回溯历史：你可以轻松地将整个项目恢复到过去的任意一个“快照”状态。\n支持并行开发：通过“分支”功能，团队成员可以在不互相干扰的独立空间里开发新功能。\n高效解决冲突：当不同人的修改发生冲突时，Git 提供了工具来帮助你清晰地合并它们。\n\nGitHub 又是什么呢？ 它是一个基于云的代码托管平台。如果说 Git 是你本地的“时光机”，那 GitHub 就是这个“时光机”的云端枢纽和社交网络。它提供了：\n\n远程仓库：一个安全的地方来存储你的代码和所有版本历史。\n协作工具：强大的 Pull Request、Code Review 和 Issue Tracking 功能，让团队协作变得前所未有的高效。\n个人名片：一个展示你技术实力的平台，你的 GitHub 主页就是程序员最好的简历。\n\n总结：Git 是工具，负责版本控制；GitHub 是平台，负责代码托管与协作。\n\n\n\n\n\n\nWindows: 访问 git-scm.com/download/win 下载安装包。安装时，建议一路使用默认选项，它会自动安装 Git Bash，一个在 Windows 上模拟 Linux 命令行的强大工具。\nmacOS:\n\n最简单的方式是安装 Xcode Command Line Tools。打开“终端”(Terminal) 并输入 xcode-select --install。\n或者使用 Homebrew (推荐) 安装：brew install git。\n\nLinux (Debian/Ubuntu): 打开终端并输入 sudo apt-get install git。\n\n安装后，打开终端 (或 Git Bash) 输入 git --version，如果看到版本号，说明安装成功。\n\n\n\n安装 Git 后，第一件事就是设置你的用户名和邮箱。这个身份信息会附加到你的每一次“提交”(commit) 上，让别人知道是谁做的修改。\n# 设置你的 GitHub 用户名\ngit config --global user.name \"Your GitHub Username\"\n\n# 设置你的 GitHub 注册邮箱\ngit config --global user.email \"your.email@example.com\"\n--global 标志表示这是全局配置，你电脑上所有的 Git 项目都会默认使用这个配置。\n\n\n\n\nGit 的核心在于其三个主要区域的流转。理解了这个模型，你就理解了 Git 的一半。\n\n工作区 (Working Directory): 你在电脑上能直接看到和编辑的项目文件夹。\n暂存区 (Staging Area/Index): 一个虚拟的区域，用于临时存放你希望包含在下一次提交中的变更。它像一个购物车的概念，你可以把修改好的东西一件件放进去，最后统一“结账”。\n本地仓库 (Local Repository): .git 隐藏文件夹，存放了项目所有的版本历史“快照”。一旦变更被提交到这里，它就永久地记录下来了。\n\n\n\n下面这张图清晰地展示了文件在三个区域之间的流转过程：\n\n\n\n\n\ngraph TD\n    A[\"工作区&lt;br&gt;(Working Directory)\"] -- \"git add\" --&gt; B[\"暂存区&lt;br&gt;(Staging Area)\"]\n    B -- \"git commit\" --&gt; C[\"本地仓库&lt;br&gt;(Local Repository)\"]\n    C -- \"git checkout\" --&gt; A\n    A -- \"编辑文件&lt;br&gt;(Edit files)\" --&gt; A\n\n\n\n\n\n\n\n\n\n\n初始化仓库 (git init)\n\n在电脑上创建一个新文件夹，例如 git-project。\n通过终端进入该文件夹：cd path/to/git-project。\n执行初始化命令： bash     git init 这个命令会在当前目录下创建一个名为 .git 的子目录，你的本地仓库就此诞生。\n\n检查状态 (git status) git status 是你最应该频繁使用的命令。它会告诉你当前仓库的状态：哪些文件被修改了？哪些文件在暂存区？\n创建文件并添加到暂存区 (git add)\n\n在 git-project 文件夹中创建一个 README.md 文件，并写入 “Hello, Git!”。\n现在运行 git status，你会看到 README.md 出现在 “Untracked files” (未跟踪文件) 列表中。\n使用 git add 命令来跟踪这个文件，并将其变更放入暂存区。\n# 添加指定文件到暂存区\ngit add README.md\n\n# 如果想添加所有已修改或新增的文件，使用点号\n# git add .\n再次运行 git status，你会看到 README.md 现在处于 “Changes to be committed” (待提交的变更) 列表中。\n\n提交变更到仓库 (git commit) 当暂存区里的内容准备就绪后，就可以使用 git commit 将它们“拍摄快照”并存入本地仓库。\n# -m 参数允许你直接在命令行提供提交信息\ngit commit -m \"Initial commit: Create README.md\"\n编写好的 Commit Message 至关重要！ 它应该简洁明了地描述本次提交的目的。一个好的习惯是使用 “动词+宾语” 的格式，例如 “Fix: user login bug” 或 “Feat: add user profile page”。\n查看提交历史 (git log) 想回顾你走过的路吗？git log 会按时间倒序列出所有的提交记录，包括哈希值 (唯一ID)、作者、日期和提交信息。\n\n\n\n\n\n现在，你的项目只存在于你的电脑上。让我们把它推送到 GitHub，实现云端备份和远程协作。\n\n\n\n\n\n\n\ngraph TD\n    subgraph \"Your Computer\"\n        A[\"本地仓库(Local Repo)\"]\n    end\n\n    subgraph \"GitHub Cloud\"\n        B[\"远程仓库(Remote Repo)\"]\n    end\n\n    A -- \"git push\" --&gt; B\n    B -- \"git pull / git clone\" --&gt; A\n\n\n\n\n\n\n\n\n\n\n在 GitHub 创建远程仓库\n\n登录 GitHub，点击右上角 “+” -&gt; “New repository”。\n填写仓库名称 (建议与本地文件夹同名，如 git-project)。\n保持 “Public” (公开) 或选择 “Private” (私有)。\n非常重要：不要勾选任何 “Initialize this repository with…” 的选项，因为我们已经有了一个本地仓库。\n点击 “Create repository”。\n\n关联本地与远程 (git remote add) 创建后，GitHub 会提供一个 URL。复制这个 HTTPS 或 SSH 格式的 URL。回到你的终端，运行：\n# 将 '你的仓库URL' 替换成你刚刚复制的地址\ngit remote add origin 你的仓库URL\n\ngit remote add：添加一个远程仓库的引用。\norigin：是这个远程仓库的默认别名，你也可以取别的名字，但 origin 是约定俗成的。\n\n推送本地变更 (git push) 最后，将你本地 main 分支上的所有提交推送到远程仓库 origin。\ngit push -u origin main\n\npush：推送动作。\n-u (或 --set-upstream)：建立本地 main 分支与远程 origin/main 分支的联系。这个参数只需要在第一次推送时使用。之后，你只需要简单地运行 git push。\norigin：远程仓库的别名。\nmain：你要推送的本地分支名。\n\n现在，刷新你的 GitHub 仓库页面，代码已经成功上传！\n\n\n\n\n\n分支 (Branch) 是 Git 最强大的功能之一。它允许你从主线 (通常是 main 分支) 创建一个独立的副本，在新功能开发、Bug 修复等工作中，你可以在这个副本上自由地实验，而不会影响到主线的稳定性。\n\n\n\n\n\n\n\ngitGraph\n   commit id: \"Initial\"\n   branch feature-A\n   checkout feature-A\n   commit id: \"Add button\"\n   commit id: \"Style button\"\n   checkout main\n   merge feature-A\n   commit id: \"Release v1.0\"\n\n\n\n\n\n\n上图展示了：\n\n从 main 分支创建了一个 feature-A 分支。\n在 feature-A 上进行了两次提交 (开发新功能)。\n开发完成后，切换回 main 分支。\n将 feature-A 分支上的所有工作合并 (merge) 回 main 分支。\n\n\n\n\n\n查看所有分支:\ngit branch\n星号 * 标记的是你当前所在的分支。\n创建新分支:\ngit branch &lt;分支名&gt;\n# 例如: git branch new-feature\n切换分支:\ngit checkout &lt;分支名&gt;\n# 例如: git checkout new-feature\n创建并立即切换到新分支 (常用):\ngit checkout -b &lt;新分支名&gt;\n# 例如: git checkout -b another-feature\n合并分支: 首先，切换到你希望接纳变更的分支 (目标分支)，通常是 main。\ngit checkout main\n然后，执行合并命令，将其他分支的变更合并进来。\ngit merge &lt;要合并的分支名&gt;\n# 例如: git merge new-feature\n删除分支: 当一个分支的工作已经合并完成，通常会将其删除以保持仓库整洁。\ngit branch -d &lt;分支名&gt;\n\n\n\n\n\n\n\n\n\n\n%%{init: { 'logLevel': 'debug', 'theme': 'base', 'gitGraph': {'showBranches': true, 'showCommitLabel': true, 'mainBranchName': 'main'}} }%%\ngitGraph\n    commit id: \"初始化项目\"\n    branch develop\n    checkout develop\n    commit id: \"开发环境配置\"\n    \n    %% --- 功能A开发 ---\n    branch feat/user-login\n    checkout feat/user-login\n    commit id: \"实现UI界面\"\n    commit id: \"完成后端API对接\"\n    \n    %% --- 在功能A开发的同时，主干发现紧急bug ---\n    checkout main\n    branch hotfix/bug-payment-api\n    checkout hotfix/bug-payment-api\n    commit id: \"紧急修复支付掉单Bug\"\n    checkout main\n    merge hotfix/bug-payment-api tag: \"v1.0.1\"\n    \n    %% --- 紧急修复也需要合并到develop分支 ---\n    checkout develop\n    merge main id: \"同步紧急修复\"\n    \n    %% --- 功能A开发完成，合并回develop ---\n    checkout develop\n    merge feat/user-login id: \"合并用户登录功能\"\n    \n    %% --- 功能B开始开发 ---\n    branch feat/data-report\n    checkout feat/data-report\n    commit id: \"设计报表模型\"\n    commit id: \"完成报表前端\"\n    checkout develop\n    \n    %% --- 功能C也开始开发 ---\n    branch feat/performance-opt\n    checkout feat/performance-opt\n    commit id: \"优化数据库查询\"\n    \n    %% --- 功能B开发完成，合并回develop ---\n    checkout develop\n    merge feat/data-report id: \"合并数据报表功能\"\n    \n    %% --- 功能C开发完成，合并回develop ---\n    checkout develop\n    merge feat/performance-opt id: \"合并性能优化\"\n    \n    %% --- 准备发布新版本 ---\n    branch release/v1.1.0\n    checkout release/v1.1.0\n    commit id: \"版本文档和最终测试\"\n    \n    %% --- 正式发布：合并到main并打上标签 ---\n    checkout main\n    merge release/v1.1.0 tag: \"v1.1.0\"\n    \n    %% --- 将发布分支的修改也合并回develop ---\n    checkout develop\n    merge release/v1.1.0 id: \"同步发布版本v1.1.0的修改\"\n\n\n\n\n\n\n\n在真实的项目中，你通常会从一个已经存在的项目开始工作。\n\n克隆远程仓库 (git clone) 要获取 GitHub 上的项目到你的本地，使用 git clone。\n# 替换为项目的URL\ngit clone https://github.com/some-user/some-project.git\n这个命令会自动创建项目文件夹，初始化 .git 仓库，并自动设置好远程别名 origin，还会将项目的所有数据都拉取下来。\n保持本地更新 (git pull) 在你开始一天的工作前，或者在准备开发新功能前，务必从远程仓库拉取最新的变更，确保你的本地版本是最新的。\ngit pull origin main\n# 如果已经设置了上游分支，可以直接用 git pull\ngit pull 实际上是 git fetch (从远程拉取最新数据) 和 git merge (将远程分支合并到本地) 的一个快捷命令。\nGitHub Flow：一个标准的协作模型 这是一个被广泛采用的、简单高效的协作流程：\n\n从 main 分支创建一个描述性命名的新分支 (git checkout -b fix-login-bug)。\n在新分支上进行编码和提交。\n将你的新分支推送到 GitHub (git push origin fix-login-bug)。\n在 GitHub 上，为你的分支创建一个 Pull Request (PR)。PR 是一个请求，请求项目维护者审查你的代码，并将其合并到 main 分支。\n团队成员在 PR 上进行讨论和代码审查 (Code Review)。\n一旦审查通过，项目维护者会在 GitHub 网站上点击合并 (Merge Pull Request) 按钮。\n合并后，你可以安全地删除你的功能分支。\n\n\n\n\n\n现在，你已经掌握了 Git 和 GitHub 的核心技能，是时候将它们付诸实践，创建一个所有开发者都梦寐以求的“技术名片”——你的个人网站。GitHub 提供了一项名为 GitHub Pages 的免费服务，可以让你轻松地将你的代码仓库变成一个公开的网站。\n\n\n网页是由三种核心技术构建的：\n\nHTML (HyperText Markup Language): 定义了网页的结构和内容。比如，标题、段落、图片、链接等。\nCSS (Cascading Style Sheets): 负责网页的样式和外观。比如，颜色、字体、布局、边距等。\nJavaScript: 赋予网页交互性和动态功能。比如，响应用户点击、表单验证、动画效果等。\n\n我们将创建一个只包含 HTML 和 CSS 的简单静态页面，并将其部署到 GitHub Pages。\n\n\n\n\n创建一个特殊的仓库 登录 GitHub。点击右上角的“+”号，选择 “New repository”。这一步至关重要：\n\nRepository name (仓库名称) 必须是 &lt;你的GitHub用户名&gt;.github.io。例如，如果你的用户名是 octocat，那么仓库名必须是 octocat.github.io。\n必须设置为 Public (公开)。\n可以勾选 “Add a README file” 来初始化仓库，这会使后续的克隆操作更简单。\n\n克隆仓库到本地 进入你刚刚创建的仓库页面，点击绿色的 “&lt;&gt; Code” 按钮，复制 HTTPS URL。然后，在你的电脑终端中运行 git clone：\n# 将URL替换为你自己的仓库URL\ngit clone https://github.com/YourUsername/yourusername.github.io.git\n创建你的主页文件 使用 cd 命令进入刚刚克隆下来的文件夹：\ncd yourusername.github.io\n创建一个名为 index.html 的文件。这个文件名是特殊的，当别人访问你的网站时，GitHub Pages 会默认显示这个文件的内容。在 index.html 文件中写入以下基础 HTML 代码：\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"zh-CN\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;我的个人主页&lt;/title&gt;\n    &lt;style&gt;\n        body { font-family: sans-serif; line-height: 1.6; margin: 40px; background-color: #f4f4f4; color: #333; }\n        .container { max-width: 800px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }\n        h1 { color: #0366d6; }\n        a { color: #0366d6; text-decoration: none; }\n        a:hover { text-decoration: underline; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;h1&gt;欢迎来到我的世界！&lt;/h1&gt;\n        &lt;p&gt;你好，我是 [你的名字]。这是我用 GitHub Pages 搭建的个人网站。&lt;/p&gt;\n        &lt;p&gt;你可以在 &lt;a href=\"https://github.com/YourUsername\" target=\"_blank\"&gt;这里&lt;/a&gt; 找到我的 GitHub 主页，关注我的开源项目。&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n提示: 记得将 [你的名字] 和 YourUsername 替换成你自己的信息。\n\n提交并推送到 GitHub 现在，按照我们学过的标准 Git 流程，将你的新主页上传到 GitHub。\n# 1. 将所有新文件和修改添加到暂存区\ngit add .\n\n# 2. 提交变更，并附上有意义的信息\ngit commit -m \"Feat: Create initial homepage\"\n\n# 3. 将本地提交推送到远程仓库\ngit push origin main\n在 GitHub Settings 中配置 Pages 默认情况下，名为 &lt;username&gt;.github.io 的仓库会自动启用 GitHub Pages。但了解设置过程对所有项目都至关重要。\n\n在浏览器中打开你的 GitHub 仓库页面。\n点击仓库导航栏右侧的 “Settings” 标签。\n在左侧的菜单中，找到并点击 “Pages”。\n在 “Build and deployment” (构建与部署) 部分，你会看到 “Source” (源) 的选项。请确保它的设置为 “Deploy from a branch” (从分支部署)。\n在下方的 “Branch” (分支) 设置中：\n\n\n选择你刚刚推送代码的分支，通常是 main (或者 master)。\n文件夹选项保持默认的 / (root)。\n点击 “Save”。\n\n\n保存后，页面顶部会出现一个蓝色的提示框，告诉你 “Your site is live at https://&lt;你的用户名&gt;.github.io”。有时，GitHub 需要一两分钟来完成部署（这个过程被称为 Action）。你可以点击提示框中的链接查看你的网站。\n\n见证奇迹！ 访问 https://&lt;你的GitHub用户名&gt;.github.io，你应该就能看到你刚刚创建的、拥有简单样式的个人主页了！\n\n现在，你拥有了一个可以向全世界展示的个人网站。你可以继续学习 HTML 和 CSS 来美化它，或者添加你的项目作品集，让它成为你真正的在线简历。\n\n\n\n\n恭喜你完成了这份详细的指南！现在你应该对 Git 和 GitHub 有了扎实的理解。\n\n核心理念：版本控制是为了追踪历史和促进协作。\n本地三区：工作区 -&gt; git add -&gt; 暂存区 -&gt; git commit -&gt; 本地仓库。\n远程交互：git clone 开始，git pull 更新，git push 分享。\n分支是关键：始终在独立的分支上工作，通过 Pull Request 合并，以保证 main 分支的稳定。",
    "crumbs": [
      "计算机实战应用",
      "1: Git与GitHub的应用"
    ]
  },
  {
    "objectID": "Lessons/lesson7.html",
    "href": "Lessons/lesson7.html",
    "title": "4: 基于Python的科学计算",
    "section": "",
    "text": "Python凭借其简洁的语法和强大的库生态系统，已成为科学计算和数据分析领域首选的编程语言之一。本文档将引导你从基础的数值计算开始，逐步深入到更复杂的科学计算领域，并辅含有可视化的代码示例来帮助理解。",
    "crumbs": [
      "计算机实战应用",
      "4: 基于Python的科学计算"
    ]
  },
  {
    "objectID": "Lessons/lesson7.html#核心库科学计算的基石",
    "href": "Lessons/lesson7.html#核心库科学计算的基石",
    "title": "4: 基于Python的科学计算",
    "section": "核心库：科学计算的基石",
    "text": "核心库：科学计算的基石\nPython的科学计算能力主要构建在几个核心库之上。掌握它们是进行高效科学计算的前提。\n\nNumPy (Numerical Python): 提供了多维数组对象（ndarray），以及对这些数组进行操作的各种函数。是几乎所有科学计算库的基础。\nSciPy (Scientific Python): 基于NumPy，提供了大量用于科学和工程计算的算法，如优化、积分、插值、信号处理、线性代数等。\nPandas: 提供了高性能、易于使用的数据结构（如DataFrame）和数据分析工具，特别适合处理结构化数据。\nMatplotlib: 一个功能强大、灵活的绘图库，可以创建各种静态、动态、交互式的图表。",
    "crumbs": [
      "计算机实战应用",
      "4: 基于Python的科学计算"
    ]
  },
  {
    "objectID": "Lessons/lesson7.html#一numpy-高效的数值计算",
    "href": "Lessons/lesson7.html#一numpy-高效的数值计算",
    "title": "4: 基于Python的科学计算",
    "section": "一、NumPy: 高效的数值计算",
    "text": "一、NumPy: 高效的数值计算\nNumPy的核心是ndarray对象，它是一个n维数组，可以存储同类型的数据。与Python原生的列表相比，ndarray在数值计算上效率更高，内存占用也更少。\n\n1.1 创建数组\n你可以从Python列表或元组创建NumPy数组。\n\nimport numpy as np\n\n# 从列表创建一维数组\na = np.array([1, 2, 3, 4, 5])\nprint(f\"1D Array: {a}\")\nprint(f\"Shape: {a.shape}\")\n\n# 创建一个3x3的二维数组\nb = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(\"2D Array:\\n\", b)\n\n# 创建特定类型的数组\nc = np.zeros((2, 4))  # 2x4的全零数组\nd = np.ones((3, 3), dtype=np.int16) # 3x3的全一整数数组\ne = np.arange(0, 10, 2) # 从0到10，步长为2的数组\nf = np.linspace(0, 1, 5) # 从0到1，生成5个等间距的数\n\n1D Array: [1 2 3 4 5]\nShape: (5,)\n2D Array:\n [[1 2 3]\n [4 5 6]\n [7 8 9]]\n\n\n\n\n1.2 数组运算：向量化\nNumPy的强大之处在于其“向量化”运算。你可以在整个数组上执行操作，而无需编写显式的循环，这使得代码更简洁、执行速度更快。\n\nimport numpy as np\n\na = np.array([10, 20, 30, 40])\nb = np.array([1, 2, 3, 4])\n\n# 元素级运算\nc = a - b  # [ 9 18 27 36]\nd = a * b  # [ 10  40  90 160]\ne = a**2   # [100 400 900 1600]\nf = np.sin(a) # 对每个元素计算正弦值\n\nprint(f\"a - b = {c}\")\nprint(f\"a * b = {d}\")\n\n# 矩阵运算\nA = np.array([[1, 1], [0, 1]])\nB = np.array([[2, 0], [3, 4]])\n\nprint(\"Element-wise product:\\n\", A * B)\nprint(\"Matrix product (dot product):\\n\", A @ B) # 或者 np.dot(A, B)\n\na - b = [ 9 18 27 36]\na * b = [ 10  40  90 160]\nElement-wise product:\n [[2 0]\n [0 4]]\nMatrix product (dot product):\n [[5 4]\n [3 4]]\n\n\n\n\n1.3 索引和切片\nNumPy的索引和切片机制非常灵活，与Python列表类似，但功能更强大，支持多维操作。\n\nimport numpy as np\n\narr = np.arange(10) # [0 1 2 3 4 5 6 7 8 9]\n\n# 切片\nprint(arr[2:5]) # [2 3 4]\n\n# 多维数组索引\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(f\"Element at row 1, col 2: {matrix[1, 2]}\") # 6\n\n# 切片多维数组\nprint(\"First two rows:\\n\", matrix[:2, :])\nprint(\"First column:\\n\", matrix[:, 0])\n\n[2 3 4]\nElement at row 1, col 2: 6\nFirst two rows:\n [[1 2 3]\n [4 5 6]]\nFirst column:\n [1 4 7]",
    "crumbs": [
      "计算机实战应用",
      "4: 基于Python的科学计算"
    ]
  },
  {
    "objectID": "Lessons/lesson7.html#二scipy-科学计算算法库",
    "href": "Lessons/lesson7.html#二scipy-科学计算算法库",
    "title": "4: 基于Python的科学计算",
    "section": "二、SciPy: 科学计算算法库",
    "text": "二、SciPy: 科学计算算法库\n如果说NumPy是基础的数据结构，那么SciPy就是建立在这个基础之上的算法工具箱。它包含了许多预先构建好、经过优化的函数来解决常见的科学计算问题。\n\n2.1 数值积分 (Numerical Integration)\nSciPy的integrate模块可以处理数值积分问题。例如，计算函数 \\(f(x) = e^{-x^2}\\) 在 \\([0, \\infty)\\) 上的积分。\n\\[\\int_{0}^{\\infty} e^{-x^2} dx\\]\n这个积分的解析解是 \\(\\frac{\\sqrt{\\pi}}{2}\\)。\n\nimport numpy as np\nfrom scipy.integrate import quad\n\n# 定义被积函数\ndef integrand(x):\n    return np.exp(-x**2)\n\n# quad 函数返回两个值：积分结果和估计的误差\nresult, error = quad(integrand, 0, np.inf)\n\nprint(f\"Numerical result: {result}\")\nprint(f\"Analytical result: {np.sqrt(np.pi) / 2}\")\nprint(f\"Estimated error: {error}\")\n\nNumerical result: 0.8862269254527579\nAnalytical result: 0.8862269254527579\nEstimated error: 7.101318390472462e-09\n\n\n\n\n2.2 优化 (Optimization)\nscipy.optimize 模块提供了一系列函数来寻找函数的最小值或根。例如，我们来寻找函数 \\(f(x) = (x-2)^2 + 3\\) 的最小值。\n\nfrom scipy.optimize import minimize\n\n# 定义目标函数\ndef objective_function(x):\n    return (x - 2)**2 + 3\n\n# 使用minimize函数寻找最小值，需要提供一个初始猜测值\n# 'BFGS' 是一种常用的优化算法\nresult = minimize(objective_function, x0=0, method='BFGS')\n\nprint(result)\nprint(f\"\\nMinimum found at x = {result.x[0]}\")\n\n  message: Optimization terminated successfully.\n  success: True\n   status: 0\n      fun: 3.0\n        x: [ 2.000e+00]\n      nit: 2\n      jac: [ 0.000e+00]\n hess_inv: [[ 5.000e-01]]\n     nfev: 6\n     njev: 3\n\nMinimum found at x = 1.99999998937739\n\n\n\n\n2.3 信号处理 (Signal Processing)\nSciPy的signal模块是处理信号的利器。例如，我们可以对一个含有噪声的信号进行滤波。\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import signal\n\n# 生成信号\nt = np.linspace(0, 1, 1000, endpoint=False)\n# 一个干净的5Hz正弦波\nclean_signal = np.sin(2 * np.pi * 5 * t)\n# 添加高斯白噪声\nnoise = np.random.randn(len(t)) * 0.5\nnoisy_signal = clean_signal + noise\n\n# 设计一个巴特沃斯低通滤波器\nb, a = signal.butter(4, 0.03, 'low') # 4阶，截止频率为0.03\n\n# 应用滤波器\nfiltered_signal = signal.filtfilt(b, a, noisy_signal)\n\n# 可视化\nplt.figure(figsize=(12, 6))\nplt.plot(t, noisy_signal, label='Noisy Signal', alpha=0.7)\nplt.plot(t, filtered_signal, label='Filtered Signal', linewidth=2)\nplt.plot(t, clean_signal, label='Clean Signal', linestyle='--', color='black')\nplt.title('Signal Filtering Example')\nplt.xlabel('Time [s]')\nplt.ylabel('Amplitude')\nplt.legend()\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "计算机实战应用",
      "4: 基于Python的科学计算"
    ]
  },
  {
    "objectID": "Lessons/lesson7.html#三pandas-强大的数据处理",
    "href": "Lessons/lesson7.html#三pandas-强大的数据处理",
    "title": "4: 基于Python的科学计算",
    "section": "三、Pandas: 强大的数据处理",
    "text": "三、Pandas: 强大的数据处理\nPandas是处理和分析结构化数据的标准库。它的核心数据结构是Series（一维）和DataFrame（二维），可以让你用直观的方式对数据进行切片、筛选、分组、聚合等操作。\n\nimport pandas as pd\n\n# 创建一个DataFrame\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],\n    'Age': [25, 30, 35, 28, 22],\n    'City': ['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix'],\n    'Salary': [70000, 80000, 90000, 75000, 65000]\n}\ndf = pd.DataFrame(data)\n\nprint(\"Original DataFrame:\")\nprint(df)\n\n# 数据筛选\nprint(\"\\nPeople older than 30:\")\nprint(df[df['Age'] &gt; 30])\n\n# 分组和聚合\n# 按城市计算平均薪水\naverage_salary_by_city = df.groupby('City')['Salary'].mean()\nprint(\"\\nAverage salary by city:\")\nprint(average_salary_by_city)\n\nOriginal DataFrame:\n      Name  Age         City  Salary\n0    Alice   25     New York   70000\n1      Bob   30  Los Angeles   80000\n2  Charlie   35      Chicago   90000\n3    David   28      Houston   75000\n4      Eva   22      Phoenix   65000\n\nPeople older than 30:\n      Name  Age     City  Salary\n2  Charlie   35  Chicago   90000\n\nAverage salary by city:\nCity\nChicago        90000.0\nHouston        75000.0\nLos Angeles    80000.0\nNew York       70000.0\nPhoenix        65000.0\nName: Salary, dtype: float64",
    "crumbs": [
      "计算机实战应用",
      "4: 基于Python的科学计算"
    ]
  },
  {
    "objectID": "Lessons/lesson7.html#四matplotlib-数据可视化",
    "href": "Lessons/lesson7.html#四matplotlib-数据可视化",
    "title": "4: 基于Python的科学计算",
    "section": "四、Matplotlib: 数据可视化",
    "text": "四、Matplotlib: 数据可视化\n“一图胜千言”。Matplotlib是Python中最基础也最强大的绘图库，能够创建出版质量的图表。\n\n实例：布朗运动与正态分布\n布朗运动（或称维纳过程）是模拟粒子随机游走的数学模型。它与正态分布有着深刻的联系：大量独立粒子经过一段时间的布朗运动后，它们最终位置的分布会趋向于一个正态分布。\n这个现象是中心极限定理的一个直观体现。我们可以通过模拟成千上万条独立的布朗运动轨迹来验证这一点。\n\n模拟过程:\n\n我们模拟 N 个粒子，每个粒子都从原点 (0) 出发。\n每个粒子都运动 M 个时间步。\n在每个时间步 dt 内，粒子的位移是一个服从正态分布的随机数（均值为0，方差为 dt）。\n一个粒子的总位移是所有步位移的累加。\n\n理论:\n\n根据理论，在总时间 T = M * dt 后，所有粒子最终位置 X(T) 的分布应该是一个均值为 0，方差为 T 的正态分布，即 \\(X(T) \\sim \\mathcal{N}(0, T)\\)。\n\n\n下面的代码将模拟这个过程并进行可视化。\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\n# --- 1. 定义模拟参数 ---\nnum_paths = 5000  # 模拟的粒子（路径）数量\nnum_steps = 1000  # 每条路径的时间步数\ndt = 0.01         # 每个时间步的长度\nT = num_steps * dt # 总时间\n\n# --- 2. 生成布朗运动路径 ---\n# 为每条路径的每一步生成一个随机位移\n# 位移服从均值为0, 标准差为sqrt(dt)的正态分布\nrandom_steps = np.random.normal(0, np.sqrt(dt), (num_paths, num_steps))\n\n# 计算每条路径在每个时间点的位置\n# 使用cumsum(axis=1)对时间步进行累加\n# 在开头插入0，表示所有路径都从0开始\ninitial_positions = np.zeros((num_paths, 1))\npaths = np.concatenate((initial_positions, random_steps), axis=1)\npaths = np.cumsum(paths, axis=1)\n\n# 创建时间轴\ntime_axis = np.linspace(0, T, num_steps + 1)\n\n# --- 3. 可视化部分 ---\n\n# 图1：展示几条样本路径\nplt.figure(figsize=(10, 6))\n# 只画前50条路径，否则会很乱\nfor i in range(50):\n    plt.plot(time_axis, paths[i, :])\n\nplt.title('Sample Brownian Motion Paths')\nplt.xlabel('Time')\nplt.ylabel('Position')\nplt.grid(True)\nplt.show()\n\nfinal_positions = paths[:, -1]\n\n# 计算理论上的正态分布参数\nmu = 0\nsigma = np.sqrt(T)\n\n# 创建用于绘制理论曲线的x轴\nx_theory = np.linspace(mu - 4*sigma, mu + 4*sigma, 200)\n# 计算理论正态分布的概率密度函数 (PDF)\npdf_theory = norm.pdf(x_theory, loc=mu, scale=sigma)\n\nplt.figure(figsize=(10, 6))\n\n# 绘制最终位置的直方图\n# density=True 表示将直方图面积归一化，以便与PDF比较\nplt.hist(final_positions, bins=50, density=True, alpha=0.7, label=f'Final Positions of {num_paths} Paths')\n\n# 叠加理论上的正态分布曲线\nplt.plot(x_theory, pdf_theory, 'r-', lw=2, label=f'Normal Distribution (mu=0, sigma={sigma:.2f})')\n\nplt.title('Distribution of Final Positions after Time T')\nplt.xlabel('Final Position')\nplt.ylabel('Probability Density')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n结果分析: 第一张图展示了粒子随机游走的轨迹。第二张图是核心，它清晰地显示了5000个粒子在运动10秒后，其最终位置的分布（蓝色直方图）与理论上的正态分布曲线（红色）完美吻合。这直观地证明了布朗运动与正态分布之间的深刻联系。",
    "crumbs": [
      "计算机实战应用",
      "4: 基于Python的科学计算"
    ]
  },
  {
    "objectID": "Lessons/lesson7.html#五进阶话题符号计算与机器学习",
    "href": "Lessons/lesson7.html#五进阶话题符号计算与机器学习",
    "title": "4: 基于Python的科学计算",
    "section": "五、进阶话题：符号计算与机器学习",
    "text": "五、进阶话题：符号计算与机器学习\n\n5.1 SymPy: 符号计算\n与NumPy和SciPy进行数值计算不同，SymPy可以进行符号计算（代数运算）。这意味着你可以处理数学表达式，而不是数值。\n\nimport sympy as sp\n\n# 定义符号\nx, y = sp.symbols('x y')\n\n# 创建表达式\nexpr = (x + y)**2\nprint(f\"Original expression: {expr}\")\n\n# 展开表达式\nexpanded_expr = sp.expand(expr)\nprint(f\"Expanded expression: {expanded_expr}\") # x**2 + 2*x*y + y**2\n\n# 对表达式求导\nderivative_expr = sp.diff(expanded_expr, x)\nprint(f\"Derivative with respect to x: {derivative_expr}\") # 2*x + 2*y\n\n# 解方程 x**2 - 4 = 0\nsolutions = sp.solve(x**2 - 4, x)\nprint(f\"Solutions for x**2 - 4 = 0 are: {solutions}\") # [-2, 2]\n\nOriginal expression: (x + y)**2\nExpanded expression: x**2 + 2*x*y + y**2\nDerivative with respect to x: 2*x + 2*y\nSolutions for x**2 - 4 = 0 are: [-2, 2]\n\n\n\n\n5.2 Scikit-learn: 机器学习\nScikit-learn是建立在NumPy, SciPy和Matplotlib之上的机器学习库，提供了大量易于使用的监督学习和无监督学习算法。\n这里是一个简单的线性回归示例。\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.linear_model import LinearRegression\n\n# 创建一些样本数据\n# X 必须是二维数组\nX = np.array([[1], [2], [3], [4], [5], [6]])\ny = np.array([1.5, 3.8, 6.5, 8.2, 11.5, 13.8])\n\n# 创建并训练模型\nmodel = LinearRegression()\nmodel.fit(X, y)\n\n# 预测\nX_new = np.array([[0], [7]])\ny_pred = model.predict(X_new)\n\n# 打印模型参数\nprint(f\"Intercept: {model.intercept_}\") # 截距\nprint(f\"Coefficient: {model.coef_[0]}\") # 斜率\n\n# 可视化结果\nplt.figure(figsize=(8, 6))\nplt.scatter(X, y, color='blue', label='Actual Data')\nplt.plot(X_new, y_pred, color='red', linewidth=2, label='Linear Fit')\nplt.title('Simple Linear Regression')\nplt.xlabel('X')\nplt.ylabel('y')\nplt.legend()\nplt.grid(True)\nplt.show()\n\nIntercept: -1.080000000000001\nCoefficient: 2.4657142857142857",
    "crumbs": [
      "计算机实战应用",
      "4: 基于Python的科学计算"
    ]
  },
  {
    "objectID": "Lessons/lesson7.html#结论",
    "href": "Lessons/lesson7.html#结论",
    "title": "4: 基于Python的科学计算",
    "section": "结论",
    "text": "结论\nPython通过其强大的科学计算库生态系统，为研究人员、工程师和数据科学家提供了一套完整、高效且易于上手的工具。从基础的数组操作到复杂的机器学习模型，你都可以在Python中找到解决方案。希望本文档能为你开启Python科学计算的大门。继续探索，不断实践，你将能利用Python解决更多有趣的实际问题。",
    "crumbs": [
      "计算机实战应用",
      "4: 基于Python的科学计算"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "计算机入门",
    "section": "",
    "text": "Tip\n\n\n\n欢迎来到 Coding Summer 2025！\n在人工智能技术与社会各领域深度融合的背景下，计算思维与编程技能已成为文科研究与职业发展的关键能力。本培训旨在帮助非计算机专业的同学理解计算机科学的核心逻辑，掌握现代编程工具，并能将其应用于各自的学科领域，从而在人工智能时代获得独特的交叉学科优势。\n我们相信，代码是赋能思想的工具。本课程将引导你从零开始，构建坚实的计算机知识体系。",
    "crumbs": [
      "计算机入门"
    ]
  },
  {
    "objectID": "index.html#课程目标与内容",
    "href": "index.html#课程目标与内容",
    "title": "计算机入门",
    "section": "课程目标与内容",
    "text": "课程目标与内容\n本培训课程体系完整，分为三大模块，由浅入深，旨在帮助学员建立全面的知识结构。\n\n课程模块概览\n\n\n\n\n\n\n\n\n模块\n内容\n预计学习时长\n\n\n\n\n模块一：计算机科学基础\n构建扎实的理论与编程基础，清晰阐释计算机科学的基本范式\n5小时\n\n\n模块二：核心编程应用实践\n将编程技能应用于解决实际问题，培养数据获取、处理与分析能力\n8小时\n\n\n模块三：计算机与经济金融前沿\n探索计算机技术在经济金融领域的前沿应用，了解行业发展趋势\n6小时\n\n\n\n\n\n详细课程内容\n\n模块一：计算机科学基础\n\n\n\n\n\n\n\n\n课程\n内容\n预计学习时长\n\n\n\n\n计算机科学与程序设计语言导论\n讲解计算机系统的基本工作原理，分析不同编程语言（如 Python 与 C++）的设计哲学及核心应用领域\n1小时\n\n\nPython 语言入门\n系统讲授 Python 的核心语法，包括变量、数据结构、流程控制、函数，并介绍面向对象编程（OOP）的基本思想\n2小时\n\n\nPython 实用进阶\n重点培养在命令行环境下进行程序开发与调试的能力，讲解参数处理及使用 pdb 进行代码调试的方法\n2小时\n\n\n\n\n\n模块二：核心编程应用实践\n\n\n\n\n\n\n\n\n课程\n内容\n预计学习时长\n\n\n\n\n版本控制与项目协作\n讲授 Git 与 GitHub 的使用，使其掌握现代软件开发中的标准化项目管理与协作流程\n2小时\n\n\n网络数据采集\n学习 Python 爬虫 的原理与实践，掌握从静态及动态网站自动获取公开数据的技术\n2小时\n\n\n数据分析与可视化\n介绍如何使用 Matplotlib 和 Seaborn 等库进行数据可视化，将数据以直观的图形方式呈现\n2小时\n\n\n科学计算\n讲授如何运用 NumPy 和 SciPy 等库进行高效的科学计算，为学术研究中的数据处理提供支持\n2小时\n\n\n\n\n\n模块三：计算机与经济金融前沿\n\n\n\n\n\n\n\n\n课程\n内容\n预计学习时长\n\n\n\n\n量化金融分享\n探讨计算机技术在量化交易、金融建模和风险管理中的应用，了解量化分析师工作内容\n2小时\n\n\nOM/OR分享\n介绍运筹学与运营管理中的计算机应用，包括优化算法、模拟仿真及决策支持系统\n2小时\n\n\n大模型分享\n讲解大型语言模型在金融分析、市场预测和智能投顾领域的创新应用及未来发展趋势\n2小时\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n本课程不要求任何计算机科学的先修知识。\n\n\n\n\n\n开始学习\n点击下方链接，开始课程第一讲的学习。\n➡️ 第一课：计算机科学基础与程序设计语言",
    "crumbs": [
      "计算机入门"
    ]
  },
  {
    "objectID": "readme.html",
    "href": "readme.html",
    "title": "Coding Summer 2025",
    "section": "",
    "text": "论到解放子女，本是极平常的事，当然不必有什么讨论。但中国的老年，中了旧习惯旧思想的毒太深了，决定悟不过来。譬如早晨听到乌鸦叫，少年毫不介意，迷信的老人，却总须颓唐半天。虽然很可怜，然而也无法可救。没有法，便只能先从觉醒的人开手，各自解放了自己的孩子。自己背着因袭的重担，肩住了黑暗的闸门，放他们到宽阔光明的地方去；此后幸福的度日，合理的做人。\n–鲁迅"
  },
  {
    "objectID": "Lessons/lesson5.html",
    "href": "Lessons/lesson5.html",
    "title": "2: Python爬虫原理与实践",
    "section": "",
    "text": "在我们开始写代码之前，必须先稳固地掌握爬虫的内在逻辑。\n\n\n网络爬虫，本质上是一个自动化的程序。它的核心任务是模拟人类访问网页的行为，但速度和规模远超人类。\n\n人类访问网页：打开浏览器 -&gt; 输入网址 (URL) -&gt; 回车 -&gt; 浏览器发送请求 -&gt; 服务器返回HTML代码 -&gt; 浏览器将代码渲染成我们看到的图文并茂的页面。\n爬虫访问网页：执行程序 -&gt; 指定URL -&gt; 程序发送请求 -&gt; 服务器返回HTML代码 -&gt; 程序不渲染，而是直接解析这份纯文本的HTML代码，寻找并提取数据。\n\n关键区别在于“渲染”和“解析”。浏览器负责美观地展示，而爬虫负责高效地提取。\n\n\n\n你的爬虫程序通过HTTP协议与网站服务器对话。最常见的两种对话方式是 GET 和 POST。\n\nGET 请求：就像在浏览器地址栏输入网址后回车。这是最常见的请求，用于获取（GET）网页数据。我们的绝大多数抓取任务都从GET请求开始。\nPOST 请求：通常用于向服务器提交（POST）数据，例如填写登录表单、提交搜索关键词等。有些需要登录或搜索后才能看到内容的页面，就需要模拟POST请求。\n\n\n\n\n爬虫获取到的就是一堆HTML（超文本标记语言）代码。你需要能看懂它的基本结构，才能知道去哪里找数据。\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;网页标题&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"content\"&gt;\n        &lt;h1&gt;这是一个主标题&lt;/h1&gt;\n        &lt;p id=\"intro\"&gt;这是一个段落。&lt;/p&gt;\n        &lt;a href=\"/about.html\"&gt;关于我们&lt;/a&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n标签 (Tag)：由尖括号包围，如&lt;html&gt;, &lt;h1&gt;, &lt;p&gt;, &lt;a&gt;。它们定义了内容的类型和结构。\n属性 (Attribute)：在标签内部，提供额外信息，如class=\"content\"，id=\"intro\"，href=\"/about.html\"。属性是我们定位数据的关键线索。\n\n\n\n\n正则表达式（Regular Expression，简称Regex）是一种用于文本匹配的模式语言，它在爬虫中扮演着重要角色，特别是当HTML结构不规则或需要提取特定格式的内容时。\n\n\n\n\n\n\n\n\n\n\n符号\n含义\n例子\n\n\n\n\n.\n匹配任意单个字符\na.c 匹配 “abc”, “adc”, “a2c” 等\n\n\n*\n匹配前面的表达式0次或多次\na*b 匹配 “b”, “ab”, “aab” 等\n\n\n+\n匹配前面的表达式1次或多次\na+b 匹配 “ab”, “aab” 等，但不匹配 “b”\n\n\n?\n匹配前面的表达式0次或1次\na?b 匹配 “b” 或 “ab”\n\n\n[]\n匹配方括号内任意一个字符\n[abc] 匹配 “a”, “b” 或 “c”\n\n\n[^]\n匹配除方括号内字符外的任何字符\n[^abc] 匹配除 “a”, “b”, “c” 外的任何字符\n\n\n()\n创建捕获组\n(abc) 将 “abc” 作为一个组捕获\n\n\n 匹配任意数字\n\\d{4} 匹配四位数字，如 “2025”\n\n\n\n\n匹配字母、数字或下划线\n\\w+ 匹配单词\n\n\n\n匹配空白字符（空格、制表符等）\na\\sb 匹配 “a b”\n\n\n\n\n\n\nPython通过re模块提供正则表达式支持：\n\nimport re\n\n# 示例：提取邮箱地址\ntext = \"联系我：lyubh22@gmail.com，或者通过微信：13120040612\"\n\n# 匹配邮箱\nemail_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\nemails = re.findall(email_pattern, text)\nprint(\"邮箱:\", emails)  # 输出: ['lyubh22@gmail.com']\n\n# 匹配电话号码\nphone_pattern = r'\\d{11}'\nphones = re.findall(phone_pattern, text)\nprint(\"电话:\", phones)  # 输出: ['13120040612']\n\n邮箱: ['lyubh22@gmail.com']\n电话: ['13120040612']\n\n\n\n\n\n当BeautifulSoup无法精确定位元素时，正则表达式可以派上用场：\n\nimport requests\nimport re\nfrom bs4 import BeautifulSoup\n\n# 假设我们要从网页中提取所有发表年份\nurl = 'https://lyubh.cn'\nresponse = requests.get(url)\nsoup = BeautifulSoup(response.text, 'html.parser')\n\n# 用正则表达式匹配所有\"20XX-XX\"格式的年月\ndate_pattern = r'20\\d{2}-\\d{2}'\nall_text = soup.get_text()\npublication_dates = re.findall(date_pattern, all_text)\n\nprint(\"发现的出版日期:\", publication_dates)\n\n发现的出版日期: []\n\n\n正则表达式虽然强大，但过于复杂的表达式可能难以维护。在实际爬虫开发中，应该先尝试使用BeautifulSoup等结构化解析工具，当这些工具无法满足需求时再考虑使用正则表达式。",
    "crumbs": [
      "计算机实战应用",
      "2: Python爬虫原理与实践"
    ]
  },
  {
    "objectID": "Lessons/lesson5.html#第一章爬虫基础与核心原理再探",
    "href": "Lessons/lesson5.html#第一章爬虫基础与核心原理再探",
    "title": "2: Python爬虫原理与实践",
    "section": "",
    "text": "在我们开始写代码之前，必须先稳固地掌握爬虫的内在逻辑。\n\n\n网络爬虫，本质上是一个自动化的程序。它的核心任务是模拟人类访问网页的行为，但速度和规模远超人类。\n\n人类访问网页：打开浏览器 -&gt; 输入网址 (URL) -&gt; 回车 -&gt; 浏览器发送请求 -&gt; 服务器返回HTML代码 -&gt; 浏览器将代码渲染成我们看到的图文并茂的页面。\n爬虫访问网页：执行程序 -&gt; 指定URL -&gt; 程序发送请求 -&gt; 服务器返回HTML代码 -&gt; 程序不渲染，而是直接解析这份纯文本的HTML代码，寻找并提取数据。\n\n关键区别在于“渲染”和“解析”。浏览器负责美观地展示，而爬虫负责高效地提取。\n\n\n\n你的爬虫程序通过HTTP协议与网站服务器对话。最常见的两种对话方式是 GET 和 POST。\n\nGET 请求：就像在浏览器地址栏输入网址后回车。这是最常见的请求，用于获取（GET）网页数据。我们的绝大多数抓取任务都从GET请求开始。\nPOST 请求：通常用于向服务器提交（POST）数据，例如填写登录表单、提交搜索关键词等。有些需要登录或搜索后才能看到内容的页面，就需要模拟POST请求。\n\n\n\n\n爬虫获取到的就是一堆HTML（超文本标记语言）代码。你需要能看懂它的基本结构，才能知道去哪里找数据。\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;网页标题&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"content\"&gt;\n        &lt;h1&gt;这是一个主标题&lt;/h1&gt;\n        &lt;p id=\"intro\"&gt;这是一个段落。&lt;/p&gt;\n        &lt;a href=\"/about.html\"&gt;关于我们&lt;/a&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n标签 (Tag)：由尖括号包围，如&lt;html&gt;, &lt;h1&gt;, &lt;p&gt;, &lt;a&gt;。它们定义了内容的类型和结构。\n属性 (Attribute)：在标签内部，提供额外信息，如class=\"content\"，id=\"intro\"，href=\"/about.html\"。属性是我们定位数据的关键线索。\n\n\n\n\n正则表达式（Regular Expression，简称Regex）是一种用于文本匹配的模式语言，它在爬虫中扮演着重要角色，特别是当HTML结构不规则或需要提取特定格式的内容时。\n\n\n\n\n\n\n\n\n\n\n符号\n含义\n例子\n\n\n\n\n.\n匹配任意单个字符\na.c 匹配 “abc”, “adc”, “a2c” 等\n\n\n*\n匹配前面的表达式0次或多次\na*b 匹配 “b”, “ab”, “aab” 等\n\n\n+\n匹配前面的表达式1次或多次\na+b 匹配 “ab”, “aab” 等，但不匹配 “b”\n\n\n?\n匹配前面的表达式0次或1次\na?b 匹配 “b” 或 “ab”\n\n\n[]\n匹配方括号内任意一个字符\n[abc] 匹配 “a”, “b” 或 “c”\n\n\n[^]\n匹配除方括号内字符外的任何字符\n[^abc] 匹配除 “a”, “b”, “c” 外的任何字符\n\n\n()\n创建捕获组\n(abc) 将 “abc” 作为一个组捕获\n\n\n 匹配任意数字\n\\d{4} 匹配四位数字，如 “2025”\n\n\n\n\n匹配字母、数字或下划线\n\\w+ 匹配单词\n\n\n\n匹配空白字符（空格、制表符等）\na\\sb 匹配 “a b”\n\n\n\n\n\n\nPython通过re模块提供正则表达式支持：\n\nimport re\n\n# 示例：提取邮箱地址\ntext = \"联系我：lyubh22@gmail.com，或者通过微信：13120040612\"\n\n# 匹配邮箱\nemail_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}'\nemails = re.findall(email_pattern, text)\nprint(\"邮箱:\", emails)  # 输出: ['lyubh22@gmail.com']\n\n# 匹配电话号码\nphone_pattern = r'\\d{11}'\nphones = re.findall(phone_pattern, text)\nprint(\"电话:\", phones)  # 输出: ['13120040612']\n\n邮箱: ['lyubh22@gmail.com']\n电话: ['13120040612']\n\n\n\n\n\n当BeautifulSoup无法精确定位元素时，正则表达式可以派上用场：\n\nimport requests\nimport re\nfrom bs4 import BeautifulSoup\n\n# 假设我们要从网页中提取所有发表年份\nurl = 'https://lyubh.cn'\nresponse = requests.get(url)\nsoup = BeautifulSoup(response.text, 'html.parser')\n\n# 用正则表达式匹配所有\"20XX-XX\"格式的年月\ndate_pattern = r'20\\d{2}-\\d{2}'\nall_text = soup.get_text()\npublication_dates = re.findall(date_pattern, all_text)\n\nprint(\"发现的出版日期:\", publication_dates)\n\n发现的出版日期: []\n\n\n正则表达式虽然强大，但过于复杂的表达式可能难以维护。在实际爬虫开发中，应该先尝试使用BeautifulSoup等结构化解析工具，当这些工具无法满足需求时再考虑使用正则表达式。",
    "crumbs": [
      "计算机实战应用",
      "2: Python爬虫原理与实践"
    ]
  },
  {
    "objectID": "Lessons/lesson5.html#第二章环境准备与第一个静态爬虫",
    "href": "Lessons/lesson5.html#第二章环境准备与第一个静态爬虫",
    "title": "2: Python爬虫原理与实践",
    "section": "第二章：环境准备与第一个静态爬虫",
    "text": "第二章：环境准备与第一个静态爬虫\n现在，让我们卷起袖子，开始动手！\n\n2.1 搭建你的爬虫工作室\n\n安装 Python: 确保你的电脑上安装了Python 3。\n安装必备库: 打开你的终端或命令行工具，安装我们即将使用的两个核心库。\npip install requests\npip install beautifulsoup4\n\nrequests: 负责发送HTTP请求，从网站获取HTML。\nbeautifulsoup4: 负责解析HTML，帮我们轻松提取数据。\n\n\n\n\n2.2 实战：抓取学者主页上的信息\n目标：自动抓取学者主页（如 https://lyubh.cn）上的姓名、简介、新闻动态，以及每一篇论文的标题、作者和会议。\n\n第一步：分析目标网页（侦察工作）\n在浏览器中打开目标网页，右键点击你想要爬取的内容，选择“检查”或“审查元素”。你会看到类似这样的 HTML 结构：\n&lt;!-- 姓名 --&gt;\n&lt;h1&gt;Bohan Lyu&lt;/h1&gt;\n\n&lt;!-- 简介 --&gt;\n&lt;p&gt;\n  I am an undergruduate at Tsinghua University. I'm interested in ML and NLP topics. My works are published in ICML and ACL.\n&lt;/p&gt;\n\n&lt;!-- 新闻 --&gt;\n&lt;h2 id=\"News\"&gt;News&lt;/h2&gt;\n&lt;ul&gt;\n  &lt;li&gt;2025-07 Goedel-Prover is accepted to COLM 2025!&lt;/li&gt;\n  ...\n&lt;/ul&gt;\n\n&lt;!-- 论文条目，title、作者、会议分布在同一个&lt;tr&gt;里 --&gt;\n&lt;tr class=\"paper-row\"&gt;\n  &lt;td&gt;...&lt;/td&gt;\n  &lt;td&gt;\n    &lt;div&gt;\n      &lt;h3&gt;Goedel-Prover: A Frontier Model for Open-Source Automated Theorem Proving&lt;/h3&gt;\n      &lt;br&gt;\n      Yong Lin*, Shange Tang*, &lt;b&gt;Bohan Lyu&lt;/b&gt;, Jiayun Wu, ...\n      &lt;br&gt;\n      &lt;em&gt;COLM 2025&lt;/em&gt;\n      ...\n    &lt;/div&gt;\n  &lt;/td&gt;\n&lt;/tr&gt;\n侦察结论：\n\n姓名在 &lt;h1&gt; 标签里。\n简介在第一个 &lt;p&gt; 标签里。\n新闻在 &lt;h2 id=\"News\"&gt; 后的 &lt;ul&gt; 里。\n论文信息在 &lt;tr class=\"paper-row\"&gt; 里，标题是 &lt;h3&gt;，作者是 &lt;h3&gt; 下方的所有文本，会议在 &lt;em&gt; 内。\n\n第二步：编写Python代码\n\nimport requests\nfrom bs4 import BeautifulSoup, NavigableString, Tag\n\nurl = 'https://lyubh.cn'\n\ntry:\n    response = requests.get(url)\n    response.raise_for_status()\n    soup = BeautifulSoup(response.text, 'html.parser')\n\n    # Name\n    name = soup.find('h1').text.strip() if soup.find('h1') else 'Name not found'\n\n    # Introduction\n    intro_section = soup.find('p')\n    intro_text = intro_section.text.strip() if intro_section else ''\n\n    # News\n    news_items = []\n    news_ul = soup.find('h2', id='News')\n    if news_ul:\n        news_ul = news_ul.find_next('ul')\n        if news_ul:\n            for li in news_ul.find_all('li'):\n                news_items.append(li.text.strip())\n\n    # Publications with full authors and venue\n    publications = []\n    for tr in soup.find_all('tr', class_='paper-row'):\n        h3 = tr.find('h3')\n        if h3:\n            title = h3.text.strip()\n\n            # 下面拼接所有作者节点（包括&lt;b&gt;、普通文本等），直到遇到&lt;em&gt;或者&lt;p&gt;为止\n            authors = []\n            node = h3.next_sibling\n            while node:\n                if isinstance(node, Tag) and node.name in ['em', 'p']:\n                    break\n                # 跳过换行等\n                if isinstance(node, NavigableString):\n                    t = node.strip()\n                    if t:\n                        authors.append(t)\n                elif isinstance(node, Tag):\n                    t = node.get_text(strip=True)\n                    if t:\n                        authors.append(t)\n                node = node.next_sibling\n\n            authors_str = ' '.join(authors).replace(' ,', ',').replace('  ', ' ').replace('\\n', '').strip()\n            # venue\n            venue_elem = tr.find('em')\n            venue = venue_elem.text.strip() if venue_elem else ''\n            publications.append({\n                'title': title,\n                'authors': authors_str,\n                'venue': venue\n            })\n\n    # 输出\n    print(f\"Name: {name}\")\n    print(f\"\\nIntroduction: {intro_text}\")\n\n    print(\"\\nRecent News:\")\n    for item in news_items[:3]:\n        print(f\"- {item}\")\n\n    print(\"\\nSelected Publications:\")\n    for i, pub in enumerate(publications[:3], 1):\n        print(f\"{i}. {pub['title']}\")\n        print(f\"    Authors: {pub['authors']}\")\n        print(f\"    Venue: {pub['venue']}\\n\")\n\nexcept requests.exceptions.RequestException as e:\n    print(f\"Error: Could not connect to website {url}. Reason: {e}\")\n\nName: Name not found\n\nIntroduction: If you are not redirected automatically, please click here.\n\nRecent News:\n\nSelected Publications:",
    "crumbs": [
      "计算机实战应用",
      "2: Python爬虫原理与实践"
    ]
  },
  {
    "objectID": "Lessons/lesson5.html#第三章进阶爬取技术",
    "href": "Lessons/lesson5.html#第三章进阶爬取技术",
    "title": "2: Python爬虫原理与实践",
    "section": "第三章：进阶爬取技术",
    "text": "第三章：进阶爬取技术\n抓取单个页面只是开始，真正的威力在于处理列表和多个页面。\n\n3.1 爬取列表页数据（“爬列表”）\n目标：抓取一个虚构的图书商店（http://books.toscrape.com - 这是一个真实的、为爬虫练习而生的网站）第一页所有书的标题和价格。\n侦察工作： 打开网站，用开发者工具检查一本书。你会发现，每一本书的信息都在一个&lt;article class=\"product_pod\"&gt;标签里。书名在&lt;h3&gt;标签的&lt;a&gt;标签里，价格在&lt;p class=\"price_color\"&gt;标签里。\n代码实现：\n\nimport requests\nfrom bs4 import BeautifulSoup\nimport csv # 引入csv库，用于保存数据\n\n# 目标URL\nurl = 'http://books.toscrape.com/'\n\nresponse = requests.get(url)\nsoup = BeautifulSoup(response.text, 'html.parser')\n\n# 1. 定位所有包含书籍信息的article标签\n# find_all()会返回一个包含所有匹配项的列表\nbooks = soup.find_all('article', class_='product_pod')\n\nbook_data = [] # 创建一个列表来存储所有书籍信息\n\n# 2. 循环处理每一本书\nfor book in books:\n    # 在每个book标签内继续查找标题和价格\n    # 注意这里的路径查找方式\n    title = book.h3.a['title']\n    price = book.find('p', class_='price_color').text\n    \n    # 打印出来看看\n    print(f\"书名: {title}, 价格: {price}\")\n    \n    # 将提取的数据存入字典，再添加到列表中\n    book_data.append({'title': title, 'price': price})\n\nprint(book_data)\n\n书名: A Light in the Attic, 价格: Â£51.77\n书名: Tipping the Velvet, 价格: Â£53.74\n书名: Soumission, 价格: Â£50.10\n书名: Sharp Objects, 价格: Â£47.82\n书名: Sapiens: A Brief History of Humankind, 价格: Â£54.23\n书名: The Requiem Red, 价格: Â£22.65\n书名: The Dirty Little Secrets of Getting Your Dream Job, 价格: Â£33.34\n书名: The Coming Woman: A Novel Based on the Life of the Infamous Feminist, Victoria Woodhull, 价格: Â£17.93\n书名: The Boys in the Boat: Nine Americans and Their Epic Quest for Gold at the 1936 Berlin Olympics, 价格: Â£22.60\n书名: The Black Maria, 价格: Â£52.15\n书名: Starving Hearts (Triangular Trade Trilogy, #1), 价格: Â£13.99\n书名: Shakespeare's Sonnets, 价格: Â£20.66\n书名: Set Me Free, 价格: Â£17.46\n书名: Scott Pilgrim's Precious Little Life (Scott Pilgrim #1), 价格: Â£52.29\n书名: Rip it Up and Start Again, 价格: Â£35.02\n书名: Our Band Could Be Your Life: Scenes from the American Indie Underground, 1981-1991, 价格: Â£57.25\n书名: Olio, 价格: Â£23.88\n书名: Mesaerion: The Best Science Fiction Stories 1800-1849, 价格: Â£37.59\n书名: Libertarianism for Beginners, 价格: Â£51.33\n书名: It's Only the Himalayas, 价格: Â£45.17\n[{'title': 'A Light in the Attic', 'price': 'Â£51.77'}, {'title': 'Tipping the Velvet', 'price': 'Â£53.74'}, {'title': 'Soumission', 'price': 'Â£50.10'}, {'title': 'Sharp Objects', 'price': 'Â£47.82'}, {'title': 'Sapiens: A Brief History of Humankind', 'price': 'Â£54.23'}, {'title': 'The Requiem Red', 'price': 'Â£22.65'}, {'title': 'The Dirty Little Secrets of Getting Your Dream Job', 'price': 'Â£33.34'}, {'title': 'The Coming Woman: A Novel Based on the Life of the Infamous Feminist, Victoria Woodhull', 'price': 'Â£17.93'}, {'title': 'The Boys in the Boat: Nine Americans and Their Epic Quest for Gold at the 1936 Berlin Olympics', 'price': 'Â£22.60'}, {'title': 'The Black Maria', 'price': 'Â£52.15'}, {'title': 'Starving Hearts (Triangular Trade Trilogy, #1)', 'price': 'Â£13.99'}, {'title': \"Shakespeare's Sonnets\", 'price': 'Â£20.66'}, {'title': 'Set Me Free', 'price': 'Â£17.46'}, {'title': \"Scott Pilgrim's Precious Little Life (Scott Pilgrim #1)\", 'price': 'Â£52.29'}, {'title': 'Rip it Up and Start Again', 'price': 'Â£35.02'}, {'title': 'Our Band Could Be Your Life: Scenes from the American Indie Underground, 1981-1991', 'price': 'Â£57.25'}, {'title': 'Olio', 'price': 'Â£23.88'}, {'title': 'Mesaerion: The Best Science Fiction Stories 1800-1849', 'price': 'Â£37.59'}, {'title': 'Libertarianism for Beginners', 'price': 'Â£51.33'}, {'title': \"It's Only the Himalayas\", 'price': 'Â£45.17'}]\n\n\n\n\n3.2 循环爬取多个页面（“循环爬”/翻页）\n目标：抓取books.toscrape.com前5页所有书的信息。\n侦察工作： 在第一页底部，找到“next”按钮。检查它的HTML，你会看到一个&lt;a&gt;标签，它的href属性指向下一页的地址（catalogue/page-2.html）。这给了我们构建下一页URL的规律。\n代码实现：\n\nimport requests\nfrom bs4 import BeautifulSoup\nimport time # 引入时间库，用于设置延时\n\nbase_url = 'http://books.toscrape.com/catalogue/'\nall_book_data = []\n\n# 循环爬取前3页\nfor i in range(1, 4): # 从第1页到第3页\n    # 构造每一页的完整URL\n    url = f\"{base_url}page-{i}.html\"\n    print(f\"正在抓取页面: {url}\")\n    \n    response = requests.get(url)\n    \n    # 如果页面不存在，则跳出循环\n    if response.status_code != 200:\n        print(f\"页面 {url} 不存在，停止抓取。\")\n        break\n        \n    soup = BeautifulSoup(response.text, 'html.parser')\n    books = soup.find_all('article', class_='product_pod')\n\n    for book in books:\n        title = book.h3.a['title']\n        price = book.find('p', class_='price_color').text\n        all_book_data.append({'title': title, 'price': price})\n    \n    # 做一个有礼貌的爬虫，每次请求后暂停一下\n    print(f\"页面 {i} 抓取完毕，暂停1秒...\")\n    time.sleep(1) \n\nprint(f\"\\n全部 {len(all_book_data)} 本书的信息抓取完毕！\")\n\nprint(all_book_data)\n\n正在抓取页面: http://books.toscrape.com/catalogue/page-1.html\n页面 1 抓取完毕，暂停1秒...\n正在抓取页面: http://books.toscrape.com/catalogue/page-2.html\n页面 2 抓取完毕，暂停1秒...\n正在抓取页面: http://books.toscrape.com/catalogue/page-3.html\n页面 3 抓取完毕，暂停1秒...\n\n全部 60 本书的信息抓取完毕！\n[{'title': 'A Light in the Attic', 'price': 'Â£51.77'}, {'title': 'Tipping the Velvet', 'price': 'Â£53.74'}, {'title': 'Soumission', 'price': 'Â£50.10'}, {'title': 'Sharp Objects', 'price': 'Â£47.82'}, {'title': 'Sapiens: A Brief History of Humankind', 'price': 'Â£54.23'}, {'title': 'The Requiem Red', 'price': 'Â£22.65'}, {'title': 'The Dirty Little Secrets of Getting Your Dream Job', 'price': 'Â£33.34'}, {'title': 'The Coming Woman: A Novel Based on the Life of the Infamous Feminist, Victoria Woodhull', 'price': 'Â£17.93'}, {'title': 'The Boys in the Boat: Nine Americans and Their Epic Quest for Gold at the 1936 Berlin Olympics', 'price': 'Â£22.60'}, {'title': 'The Black Maria', 'price': 'Â£52.15'}, {'title': 'Starving Hearts (Triangular Trade Trilogy, #1)', 'price': 'Â£13.99'}, {'title': \"Shakespeare's Sonnets\", 'price': 'Â£20.66'}, {'title': 'Set Me Free', 'price': 'Â£17.46'}, {'title': \"Scott Pilgrim's Precious Little Life (Scott Pilgrim #1)\", 'price': 'Â£52.29'}, {'title': 'Rip it Up and Start Again', 'price': 'Â£35.02'}, {'title': 'Our Band Could Be Your Life: Scenes from the American Indie Underground, 1981-1991', 'price': 'Â£57.25'}, {'title': 'Olio', 'price': 'Â£23.88'}, {'title': 'Mesaerion: The Best Science Fiction Stories 1800-1849', 'price': 'Â£37.59'}, {'title': 'Libertarianism for Beginners', 'price': 'Â£51.33'}, {'title': \"It's Only the Himalayas\", 'price': 'Â£45.17'}, {'title': 'In Her Wake', 'price': 'Â£12.84'}, {'title': 'How Music Works', 'price': 'Â£37.32'}, {'title': 'Foolproof Preserving: A Guide to Small Batch Jams, Jellies, Pickles, Condiments, and More: A Foolproof Guide to Making Small Batch Jams, Jellies, Pickles, Condiments, and More', 'price': 'Â£30.52'}, {'title': 'Chase Me (Paris Nights #2)', 'price': 'Â£25.27'}, {'title': 'Black Dust', 'price': 'Â£34.53'}, {'title': 'Birdsong: A Story in Pictures', 'price': 'Â£54.64'}, {'title': \"America's Cradle of Quarterbacks: Western Pennsylvania's Football Factory from Johnny Unitas to Joe Montana\", 'price': 'Â£22.50'}, {'title': 'Aladdin and His Wonderful Lamp', 'price': 'Â£53.13'}, {'title': 'Worlds Elsewhere: Journeys Around Shakespeareâ\\x80\\x99s Globe', 'price': 'Â£40.30'}, {'title': 'Wall and Piece', 'price': 'Â£44.18'}, {'title': 'The Four Agreements: A Practical Guide to Personal Freedom', 'price': 'Â£17.66'}, {'title': 'The Five Love Languages: How to Express Heartfelt Commitment to Your Mate', 'price': 'Â£31.05'}, {'title': 'The Elephant Tree', 'price': 'Â£23.82'}, {'title': 'The Bear and the Piano', 'price': 'Â£36.89'}, {'title': \"Sophie's World\", 'price': 'Â£15.94'}, {'title': 'Penny Maybe', 'price': 'Â£33.29'}, {'title': 'Maude (1883-1993):She Grew Up with the country', 'price': 'Â£18.02'}, {'title': 'In a Dark, Dark Wood', 'price': 'Â£19.63'}, {'title': 'Behind Closed Doors', 'price': 'Â£52.22'}, {'title': \"You can't bury them all: Poems\", 'price': 'Â£33.63'}, {'title': 'Slow States of Collapse: Poems', 'price': 'Â£57.31'}, {'title': 'Reasons to Stay Alive', 'price': 'Â£26.41'}, {'title': 'Private Paris (Private #10)', 'price': 'Â£47.61'}, {'title': '#HigherSelfie: Wake Up Your Life. Free Your Soul. Find Your Tribe.', 'price': 'Â£23.11'}, {'title': 'Without Borders (Wanderlove #1)', 'price': 'Â£45.07'}, {'title': 'When We Collided', 'price': 'Â£31.77'}, {'title': 'We Love You, Charlie Freeman', 'price': 'Â£50.27'}, {'title': 'Untitled Collection: Sabbath Poems 2014', 'price': 'Â£14.27'}, {'title': 'Unseen City: The Majesty of Pigeons, the Discreet Charm of Snails & Other Wonders of the Urban Wilderness', 'price': 'Â£44.18'}, {'title': 'Unicorn Tracks', 'price': 'Â£18.78'}, {'title': 'Unbound: How Eight Technologies Made Us Human, Transformed Society, and Brought Our World to the Brink', 'price': 'Â£25.52'}, {'title': 'Tsubasa: WoRLD CHRoNiCLE 2 (Tsubasa WoRLD CHRoNiCLE #2)', 'price': 'Â£16.28'}, {'title': 'Throwing Rocks at the Google Bus: How Growth Became the Enemy of Prosperity', 'price': 'Â£31.12'}, {'title': 'This One Summer', 'price': 'Â£19.49'}, {'title': 'Thirst', 'price': 'Â£17.27'}, {'title': 'The Torch Is Passed: A Harding Family Story', 'price': 'Â£19.09'}, {'title': 'The Secret of Dreadwillow Carse', 'price': 'Â£56.13'}, {'title': 'The Pioneer Woman Cooks: Dinnertime: Comfort Classics, Freezer Food, 16-Minute Meals, and Other Delicious Ways to Solve Supper!', 'price': 'Â£56.41'}, {'title': 'The Past Never Ends', 'price': 'Â£56.50'}, {'title': 'The Natural History of Us (The Fine Art of Pretending #2)', 'price': 'Â£45.22'}]",
    "crumbs": [
      "计算机实战应用",
      "2: Python爬虫原理与实践"
    ]
  },
  {
    "objectID": "Lessons/lesson5.html#第四章攻克动态网站动态爬",
    "href": "Lessons/lesson5.html#第四章攻克动态网站动态爬",
    "title": "2: Python爬虫原理与实践",
    "section": "第四章：攻克动态网站（“动态爬”）",
    "text": "第四章：攻克动态网站（“动态爬”）\n挑战：很多现代网站使用JavaScript在页面加载后才动态地载入数据。你用requests直接请求，只能拿到一个空壳HTML，数据根本不在里面。\n例子：一个股价实时更新的页面，或者无限滚动的社交媒体。\n解决方案：使用浏览器自动化工具，如Selenium。\nSelenium可以驱动一个真实的浏览器（如Chrome或Firefox）去加载网页。它会等待所有JavaScript执行完毕，渲染出最终的页面，然后我们再从这个完整的页面中提取数据。\n\n4.1 安装与配置 Selenium\n\n安装 Selenium 库:\npip install selenium\n下载 WebDriver: Selenium需要一个叫做WebDriver的驱动程序来控制浏览器。你需要下载与你的浏览器版本完全对应的WebDriver。\n\nChrome用户: 搜索 “ChromeDriver” 下载。\nFirefox用户: 搜索 “GeckoDriver” 下载。\n下载后，将chromedriver.exe（或geckodriver.exe）放到你的Python脚本所在的文件夹，或者一个系统路径下。\n\n\n\n\n4.2 实战：抓取动态加载的数据\n目标：抓取一个虚构的、由JS加载名言的网站 (http://quotes.toscrape.com/js/) 的第一页所有名言。\n侦察工作： 如果你直接用requests请求这个URL，会发现返回的HTML里根本没有名言数据。但用浏览器打开，名言却清晰可见。这就是JS动态加载的证据。\n代码实现：\n\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom bs4 import BeautifulSoup\nimport time\n\n# --- Selenium 设置 ---\n# 指定WebDriver的路径（如果不在系统路径下）\n# driver_path = 'path/to/your/chromedriver.exe'\n# driver = webdriver.Chrome(executable_path=driver_path)\ndriver = webdriver.Chrome() # 假设chromedriver在PATH中\n\nurl = 'http://quotes.toscrape.com/js/'\ndriver.get(url)\n\ntry:\n    # --- 等待动态内容加载 ---\n    # 设置一个最长等待时间（10秒）\n    # 等待直到class为'quote'的元素出现\n    WebDriverWait(driver, 10).until(\n        EC.presence_of_element_located((By.CLASS_NAME, \"quote\"))\n    )\n\n    # 此刻，浏览器中的页面已经完全加载好了\n    # 获取渲染后的页面源代码\n    html_content = driver.page_source\n    \n    # --- 使用BeautifulSoup解析 ---\n    soup = BeautifulSoup(html_content, 'html.parser')\n    \n    quotes = soup.find_all('div', class_='quote')\n    \n    for quote in quotes:\n        text = quote.find('span', class_='text').text\n        author = quote.find('small', class_='author').text\n        print(f\"'{text}' - {author}\")\n        \nfinally:\n    # 完成后务必关闭浏览器，释放资源\n    time.sleep(2) # 稍等片刻，方便观察\n    driver.quit()\n\n动态爬取小结：\n\n优点：能抓取几乎所有“所见即所得”的网页内容，是终极解决方案。\n缺点：速度慢（因为要真实加载整个浏览器），消耗资源多。\n\n更高效的动态抓取思路（高级）： 在开发者工具的“Network”标签页下，筛选XHR或Fetch请求。你往往能找到JS用来获取数据的那个后台API接口。如果能找到这个接口，你就可以直接用requests去请求这个API，获取返回的JSON数据，这比启动整个Selenium快得多！",
    "crumbs": [
      "计算机实战应用",
      "2: Python爬虫原理与实践"
    ]
  },
  {
    "objectID": "Lessons/lesson6.html",
    "href": "Lessons/lesson6.html",
    "title": "3: Python数据可视化",
    "section": "",
    "text": "数据可视化是数据科学中连接数据与决策的关键桥梁。它不仅仅是制作图表，更是一门将原始、复杂的数据集转化为富有洞察力的视觉故事的艺术和科学。通过图形化的方式，我们能够更直观地识别数据中的模式、发现隐藏的趋势、理解变量间的关系并快速定位异常值。在众多数据科学工具中，Python 凭借其简洁的语法和强大的库生态系统，已成为执行数据可视化任务的首选语言。本指南将系统地引导你，从掌握最基础的静态绘图开始，一步步进阶到能够构建复杂、动态的交互式可视化应用。",
    "crumbs": [
      "计算机实战应用",
      "3: Python数据可视化"
    ]
  },
  {
    "objectID": "Lessons/lesson6.html#为什么选择-python-进行数据可视化",
    "href": "Lessons/lesson6.html#为什么选择-python-进行数据可视化",
    "title": "3: Python数据可视化",
    "section": "🎨 为什么选择 Python 进行数据可视化？",
    "text": "🎨 为什么选择 Python 进行数据可视化？\nPython 在数据科学领域的统治地位并非偶然，其在可视化方面的优势尤为突出：\n\n易于学习与使用：相较于 R 或 Java 等其他语言，Python 的语法更接近自然语言，使得初学者可以快速上手，将主要精力集中在数据分析本身，而非复杂的编程语法上。\n强大的库生态系统：Python 拥有一个无与伦比的开源库集合。\n\nMatplotlib 是这个生态的基石，提供底层的、全面的绘图控制。\nSeaborn 在 Matplotlib 之上提供了更高级的统计绘图接口，让美观的图表唾手可得。\nPlotly 和 Bokeh 则将可视化带入了现代 Web 时代，专注于交互性和动态展示。\n\n无缝的社区支持：得益于其庞大的用户和开发者社区，几乎任何你能想到的可视化问题，都已经有了现成的教程、代码示例或解决方案。Stack Overflow、GitHub 和各类博客是学习路上的宝贵资源。\n卓越的集成性：可视化通常是数据处理流程的最后一步。Python 的可视化库能与数据处理的“三驾马车”——Pandas (数据处理)、NumPy (数值计算) 和 Scikit-learn (机器学习)——无缝集成，形成一个从数据清洗、分析到可视化的流畅工作流。",
    "crumbs": [
      "计算机实战应用",
      "3: Python数据可视化"
    ]
  },
  {
    "objectID": "Lessons/lesson6.html#matplotlib可视化的基石",
    "href": "Lessons/lesson6.html#matplotlib可视化的基石",
    "title": "3: Python数据可视化",
    "section": "Matplotlib：可视化的基石",
    "text": "Matplotlib：可视化的基石\nMatplotlib 是 Python 可视化世界的奠基者和核心。它诞生于 2003 年，其设计初衷是模仿 MATLAB 的绘图功能，因此它拥有一个非常成熟和稳定的 API。几乎所有 Python 中的静态图表，无论多么复杂，都可以用 Matplotlib 实现。学习 Matplotlib 不仅是学习一个库，更是理解图形如何被一层层构建起来的过程——从画布 (Figure) 到坐标系 (Axes)，再到线条、点、标签等每一个独立的元素。这种精细的控制力是它最大的优势，也是其略显复杂的根源。\n\n安装 Matplotlib\n通过 pip 包管理器可以轻松安装：\npip install matplotlib\n\n\n基础绘图：解构一张图表\n在 Matplotlib 中，推荐使用其面向对象的接口进行绘图，这能让你对图表的各个部分有更清晰的控制。一个基本的绘图流程如下：\n\n创建画布 (Figure) 和坐标系 (Axes)：plt.subplots() 是最常用的方法，它像是在画纸上为你准备好了一块准备作画的区域。\n在坐标系上绘图：调用 ax 对象的方法（如 ax.plot(), ax.scatter()）来添加数据。\n定制图表元素：通过 ax 的 set_ 系列方法（如 set_title(), set_xlabel()）来添加标题、坐标轴标签等。\n显示图形：最后调用 plt.show() 将最终结果渲染出来。\n\n\n1. 折线图 (Line Plot)\n折线图是展示连续数据趋势最基础也最有效的工具，尤其适合于时间序列数据。\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 准备一组平滑的、有代表性的数据\n# np.linspace 在 0 到 10 之间生成 100 个等间距的点\nx = np.linspace(0, 10, 100)\n# 计算每个 x 点对应的正弦值\ny = np.sin(x)\n\n# 1. 创建画布(fig)和坐标系(ax)\nfig, ax = plt.subplots(figsize=(8, 5)) # figsize可以控制图形的尺寸\n\n# 2. 在坐标系(ax)上绘制折线图\n# 'label' 参数用于后续图例的生成\nax.plot(x, y, label='sin(x)', color='blue', linewidth=2)\n\n# 3. 定制图表的标题和坐标轴标签，增加可读性\nax.set_title('Simple Sine Wave')\nax.set_xlabel('X-axis')\nax.set_ylabel('Y-axis')\n# ax.grid(True, linestyle='--', alpha=0.6) # 添加网格线，使数值读取更容易\nax.legend() # 显示图例\n\n# 4. 显示最终的图形\nplt.show()\n\n\n\n\n\n\n\n\n\n\n2. 散点图 (Scatter Plot)\n散点图是探索两个数值变量之间是否存在关联的利器。每个点代表一个数据样本，其在 x-y 平面上的位置由两个变量的值决定。\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 使用 NumPy 生成两组随机数据来模拟两个变量\nnp.random.seed(42) # 设置随机种子以保证结果可复现\nx = np.random.rand(50) * 10\ny = np.random.rand(50) * 10\n\n# 直接使用 plt 接口进行快速绘图，这对于简单图表更便捷\nplt.figure(figsize=(8, 5)) # 创建一个新画布\nplt.scatter(x, y, c='red', alpha=0.6, edgecolors='black') # c是颜色, alpha是透明度, edgecolors是点的边缘颜色\n\n# 添加标题和标签\nplt.title('Basic Scatter Plot')\nplt.xlabel('X Value')\nplt.ylabel('Y Value')\n\n# 显示图形\nplt.show()\n\n\n\n\n\n\n\n\n\n\n3. 条形图 (Bar Chart)\n当需要比较不同类别之间的数值大小时，条形图是最佳选择。它的高度或长度直观地表示了数值的大小。\n\nimport matplotlib.pyplot as plt\n\n# 准备离散的类别和它们对应的数值\ncategories = ['Group A', 'Group B', 'Group C', 'Group D']\nvalues = [23, 45, 58, 32]\n\nplt.figure(figsize=(8, 5))\n# plt.bar() 用于创建垂直条形图，plt.barh() 用于创建水平条形图\nplt.bar(categories, values, color=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728']) # 为每个条形指定不同颜色\n\n# 添加标题和标签\nplt.title('Categorical Bar Chart')\nplt.xlabel('Category')\nplt.ylabel('Value')\n# 在每个条形图上方显示具体数值\nfor i, value in enumerate(values):\n    plt.text(i, value + 1, str(value), ha='center')\n\n# 显示图形\nplt.show()\n\n\n\n\n\n\n\n\n\n\n4. 直方图 (Histogram)\n直方图是理解单个数值变量分布情况的核心工具。它将数值范围分割成若干个“箱子”(bins)，然后统计落入每个箱子的数据点数量。\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 生成 1000 个服从标准正态分布的随机数\ndata = np.random.randn(1000)\n\nplt.figure(figsize=(8, 5))\n# bins 参数非常关键，它决定了分布的精细程度\n# edgecolor='black' 让每个条柱的边界更清晰\nplt.hist(data, bins=30, color='skyblue', edgecolor='black')\n\n# 添加标题和标签\nplt.title('Data Distribution Histogram')\nplt.xlabel('Value')\nplt.ylabel('Frequency')\n\n# 显示图形\nplt.show()",
    "crumbs": [
      "计算机实战应用",
      "3: Python数据可视化"
    ]
  },
  {
    "objectID": "Lessons/lesson6.html#seaborn更美观的统计图表",
    "href": "Lessons/lesson6.html#seaborn更美观的统计图表",
    "title": "3: Python数据可视化",
    "section": "📊 Seaborn：更美观的统计图表",
    "text": "📊 Seaborn：更美观的统计图表\nSeaborn 是在 Matplotlib 基础上进行的一次华丽封装。它的出现解决了 Matplotlib 的两大痛点：复杂的参数设置和不够现代的默认样式。Seaborn 的核心理念是让统计绘图变得简单，它提供了大量专门为展示统计信息而设计的图表类型，并且能够直接识别和使用 Pandas DataFrame 的列名，极大地简化了数据准备的过程。你只需要一行代码，就能创建出在 Matplotlib 中可能需要十几行代码才能实现的复杂图表。\n\n安装 Seaborn\npip install seaborn pandas\n\n\n常用统计图\n我们将使用 Seaborn 内置的 tips (餐厅小费) 数据集来展示其强大功能。这个数据集记录了顾客的账单总额、支付的小费、性别、是否吸烟等信息。\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Seaborn 加载数据集非常方便\ntips = sns.load_dataset(\"tips\")\n\n# 设置 Seaborn 的美学风格\nsns.set_theme(style=\"whitegrid\", palette=\"muted\")\n\n\n1. 关系图 (Relational Plot)\nscatterplot 是 Seaborn 的明星函数之一。除了基本的 x-y 关系，它还能通过 hue, style, size 等参数，将多达五个维度的信息压缩到一张二维图表中，极大地提升了信息密度。\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\ntips = sns.load_dataset(\"tips\")\nplt.figure(figsize=(10, 6))\n\n# hue: 按 'time' (晚餐/午餐) 对点进行着色\n# style: 按 'smoker' (是否吸烟) 改变点的形状\n# size: 按 'size' (用餐人数) 改变点的大小\nsns.scatterplot(data=tips, x=\"total_bill\", y=\"tip\", hue=\"time\", style=\"smoker\", size=\"size\")\n\n# 添加一个更具信息量的标题\nplt.title('Tip Amount vs. Total Bill by Time, Smoker Status, and Party Size')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n2. 分类图 (Categorical Plot) - 小提琴图 (Violin Plot)\n当箱形图（Box Plot）不足以展示数据分布的细节时，小提琴图是绝佳的替代品。它将箱形图与核密度估计（KDE）图相结合，不仅展示了数据的四分位数，还通过外部的形状展示了数据的完整分布密度，尤其适合于比较多组数据的分布形态。\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\ntips = sns.load_dataset(\"tips\")\nplt.figure(figsize=(10, 6))\n\n# x: 类别轴 (星期几)\n# y: 数值轴 (账单总额)\n# hue: 在每个类别内再按 'smoker' 进行二次分类\n# split=True: 将 hue 分类的两个小提琴合并到一起，便于比较\nsns.violinplot(data=tips, x=\"day\", y=\"total_bill\", hue=\"smoker\", split=True, inner=\"quartile\")\n\nplt.title('Total Bill Distribution by Day and Smoker Status')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n3. 热力图 (Heatmap)\n热力图是一种将矩阵数据可视化的强大工具，它通过颜色的深浅来直观地表示数值的大小。它最经典的应用场景是展示变量间的相关性矩阵，让人一眼就能看出哪些变量是强相关的。\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\n# 计算 tips 数据集中数值列的相关性矩阵\nnumeric_cols = tips.select_dtypes(include=np.number)\ncorrelation_matrix = numeric_cols.corr()\n\nplt.figure(figsize=(8, 6))\n# annot=True: 在每个单元格中显示数值\n# fmt=\".2f\": 数值格式化为两位小数\n# cmap='coolwarm': 使用一个冷暖色调的色彩映射，正相关为暖色，负相关为冷色\nsns.heatmap(correlation_matrix, annot=True, fmt=\".2f\", cmap='coolwarm')\n\nplt.title('Correlation Matrix of Tips Dataset')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n4. 配对图 (Pair Plot)\npairplot 是探索性数据分析（EDA）的终极武器。它能快速生成数据集中所有数值变量两两之间的关系图矩阵。在矩阵的对角线上，是每个变量自身的分布直方图或核密度图；在非对角线的位置，是两个变量之间的散点图。这让你能够在一个宏观的视角下审视整个数据集的结构。\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# 加载著名的鸢尾花数据集\niris = sns.load_dataset(\"iris\")\n\n# hue=\"species\": 根据花的品种对所有图表进行着色，这使得不同类别间的差异一目了然\n# markers: 为不同品种指定不同的标记形状，增强区分度\nsns.pairplot(iris, hue=\"species\", markers=[\"o\", \"s\", \"D\"])\n\nplt.suptitle('Pairwise Relationships in the Iris Dataset', y=1.02) # 添加总标题\nplt.show()",
    "crumbs": [
      "计算机实战应用",
      "3: Python数据可视化"
    ]
  },
  {
    "objectID": "Lessons/lesson6.html#plotly交互式图表的未来",
    "href": "Lessons/lesson6.html#plotly交互式图表的未来",
    "title": "3: Python数据可视化",
    "section": "✨ Plotly：交互式图表的未来",
    "text": "✨ Plotly：交互式图表的未来\n当静态图表无法满足你的探索需求时，Plotly 便登场了。Plotly 是一家科技公司，也是一个强大的 Python 库，其核心目标是创建具有丰富交互能力的、出版物级别的图表。用户可以缩放、平移、选择数据区域，以及通过鼠标悬停查看精确的数值。这极大地增强了数据探索的深度和广度。Plotly Express 作为其高级接口，秉承“用最少的代码做最多的事”的原则，让创建复杂的交互式图表变得前所未有的简单。\n\n安装 Plotly\npip install plotly\n\n\n创建交互式图表\nPlotly 生成的图表本质上是 JSON 数据结构，由 Plotly.js（一个 JavaScript 库）在浏览器中进行渲染。这意味着你可以轻松地将它们嵌入到网页、Jupyter Notebook、或者导出为独立的 HTML 文件。\n\n1. 交互式散点图\n这个例子展示了 Plotly Express 如何仅用一行核心代码就创建一个信息丰富的交互式散点图。\n\nimport plotly.express as px\n\n# Plotly Express 内置了大量方便的数据集，包括著名的 Gapminder 数据\ngapminder = px.data.gapminder().query(\"year==2007\")\n\n# x, y, color, size, hover_data 等参数都直接对应 DataFrame 的列名\nfig = px.scatter(gapminder,\n                 x=\"gdpPercap\",       # x轴：人均GDP\n                 y=\"lifeExp\",         # y轴：预期寿命\n                 color=\"continent\",   # 点的颜色：按大洲划分\n                 size='pop',          # 点的大小：按人口划分\n                 hover_name=\"country\",# 鼠标悬停时显示的名称\n                 log_x=True,          # x轴使用对数尺度，以便更好地展示GDP差异\n                 size_max=60)         # 控制点的最大尺寸\n\nfig.update_layout(title_text='GDP per Capita vs. Life Expectancy (2007)')\nfig.show()\n\n                            \n                                            \n\n\n\n\n2. 交互式地图（Choropleth Map）\n地理空间可视化是 Plotly 的一大亮点。制作等值区域图（Choropleth Map）非常直观，你只需要提供地理位置编码（如国家代码）和对应的数值即可。\n\nimport plotly.express as px\n\n# 同样使用 Gapminder 数据，但这次是多年的数据\ngapminder_all_years = px.data.gapminder()\n\n# animation_frame: 指定按'year'列创建动画帧\n# animation_group: 指定'country'作为动画中保持一致的对象\n# color_continuous_scale: 指定连续颜色的主题\n# projection: 选择地图的投影方式\nfig = px.choropleth(gapminder_all_years,\n                    locations=\"iso_alpha\", # 使用 ISO Alpha-3 国家代码进行地理定位\n                    color=\"lifeExp\",       # 区域的颜色深浅由预期寿命决定\n                    hover_name=\"country\",  # 悬停名称\n                    animation_frame=\"year\",# 创建一个时间滑块动画\n                    color_continuous_scale=px.colors.sequential.Plasma,\n                    title=\"Global Life Expectancy Over Time\")\n\nfig.show()\n\n                            \n                                            \n\n\n\n\n3. 3D 散点图\nPlotly 让 3D 可视化变得触手可及。你可以通过鼠标拖拽来自由地旋转、缩放和平移 3D 场景，从任何角度观察数据的空间分布。\n\nimport plotly.express as px\n\n# 加载鸢尾花数据集\niris = px.data.iris()\n\n# 创建一个 3D 散点图，探索三个花瓣/花萼特征之间的关系\nfig = px.scatter_3d(iris,\n                    x='sepal_length',\n                    y='sepal_width',\n                    z='petal_width',\n                    color='species',\n                    symbol='species',  # 为不同种类使用不同形状的标记\n                    title=\"3D View of Iris Dataset Features\")\n\nfig.update_layout(margin=dict(l=0, r=0, b=0, t=40)) # 调整边距以更好地展示\nfig.show()",
    "crumbs": [
      "计算机实战应用",
      "3: Python数据可视化"
    ]
  },
  {
    "objectID": "Lessons/lesson6.html#如何选择合适的工具",
    "href": "Lessons/lesson6.html#如何选择合适的工具",
    "title": "3: Python数据可视化",
    "section": "🤔 如何选择合适的工具？",
    "text": "🤔 如何选择合适的工具？\n面对如此多的选择，关键在于理解你的核心需求。下面是一个更详细的决策指南：\n\n\n\n\n\n\n\n\n\n库\n主要优点\n最佳使用场景\n不太适合的场景\n\n\n\n\nMatplotlib\n极致控制力：可定制图表的每一个细节。稳定、成熟，是学术出版的首选。\n1. 需要精确布局和标注的学术论文图表。&lt;br&gt;2. 创建全新的、非标准的图表类型。&lt;br&gt;3. 作为其他库（如 Seaborn）的底层进行微调。\n1. 快速制作交互式图表。&lt;br&gt;2. 简单的探索性数据分析（代码相对繁琐）。\n\n\nSeaborn\n统计之美：API 简洁优雅，专为统计分析设计。与 Pandas 结合极佳，默认样式美观。\n1. 探索性数据分析 (EDA)，快速洞察数据分布和关系。&lt;br&gt;2. 展示变量间的统计相关性（如相关性热图、回归图）。\n1. 高度定制化的非统计类图表。&lt;br&gt;2. 构建复杂的交互式仪表盘。\n\n\nPlotly\n现代交互：图表美观、交互体验流畅。支持 3D、动画和地理图，易于分享 (HTML)。\n1. 商业智能 (BI) 报告和在线演示。&lt;br&gt;2. 创建需要用户交互探索的 Web 图表。&lt;br&gt;3. 制作引人注目的动画和 3D 可视化。\n1. 对性能要求极高的超大规模数据集实时渲染。&lt;br&gt;2. 简单的静态图表（可能有些大材小用）。\n\n\nBokeh\n应用构建：专为 Web 设计，可构建复杂的数据应用。支持流数据，交互逻辑强大。\n1. 构建复杂的仪表盘，包含图表联动、下拉菜单、滑块等控件。&lt;br&gt;2. 需要实时更新数据的流数据监控应用。\n1. 静态图表的制作（不如 Matplotlib/Seaborn 直接）。&lt;br&gt;2. 对非 Web 输出（如 PDF, PNG）有高质量要求时。\n\n\n\n经验法则：\n\n日常探索与分析：你的起点应该是 Seaborn。它能用最少的代码满足你 80% 的统计绘图需求。当需要交互时，无缝切换到 Plotly Express。\n发表论文或书籍：使用 Seaborn 或 Plotly 进行初步绘图，然后用 Matplotlib 对字体、分辨率、布局等细节进行最后的精修，以满足出版要求。\n构建交互式 Web 应用：如果你的目标是一个独立的、可交互的网页或仪表盘，Plotly 和 Bokeh 是你的不二之选。Plotly 在单图表的华丽度和易用性上略有优势，而 Bokeh 在构建多组件联动的复杂应用时提供了更强的灵活性。",
    "crumbs": [
      "计算机实战应用",
      "3: Python数据可视化"
    ]
  },
  {
    "objectID": "Lessons/lesson1.html",
    "href": "Lessons/lesson1.html",
    "title": "1: 计算机科学基础与程序语言",
    "section": "",
    "text": "对于很多初学者而言，“编程”、“代码”这些词汇可能听起来像是另一个世界的语言，充满了神秘感和距离感。大家可能会觉得，我们又不当程序员，为什么要了解这些？\n其实，在今天这个高度数字化的时代，了解一些计算机科学的基本逻辑，能帮助我们更好地理解我们所生活的世界，提升解决问题的能力，甚至在未来的职业生涯中带来意想不到的优势。\n这篇介绍的目的，不是让大家成为专业的程序员，而是揭开编程的神秘面纱，让大家明白它到底是什么，以及它如何驱动我们每天使用的软件和应用。\n\n\n想象一下，你想让一位只会说英语的朋友帮你去图书馆借一本书。你必须用英语，按照清晰的逻辑（比如：先走到图书馆 -&gt; 然后找到特定区域 -&gt; 根据书名找到书架 -&gt; 最后办理借阅手续），一步步地告诉他该怎么做。\n程序设计语言（Programming Language），就是我们与计算机沟通的“语言”。\n计算机本质上只懂由 0 和 1 组成的“机器语言”，这对人类来说太复杂了。于是，科学家们发明了各种程序设计语言，让我们能用更接近人类自然语言的方式，给计算机下达一系列清晰、无歧义的指令，告诉它“做什么”以及“怎么做”。\n当我们写好的指令（我们称之为源代码）被计算机执行后，就能实现各种各样的功能——比如你正在使用的微信、你浏览的淘宝、你观看的视频，背后都是由千百万行代码构成的复杂程序。\n\n\n\n在众多编程语言中，C 和 C++ 是两座无法绕过的高峰。\n\n\nC 语言诞生于上世纪 70 年代，是一位真正的“元老”。它的设计哲学是简洁、高效、贴近底层硬件。你可以把它想象成手动挡的汽车，虽然操作起来比自动挡复杂，需要你精确控制离合和油门，但它能让你最大程度地掌控汽车的性能，开得飞快。\n\n特点：\n\n执行效率极高：代码被转换成机器指令后，几乎没有多余的动作，运行速度非常快。\n控制力强：可以直接操作内存（计算机存储数据的地方），像一个精密的外科医生，能精确控制计算机的每一个细节。\n过程导向：编程的思维方式是“一步一步做什么”，像一个流程图。\n\n\n\n\n\n随着软件越来越复杂，人们发现单纯用 C 语言来构建大型项目（比如一个操作系统或一个大型游戏）太困难了。于是，在 C 语言的基础上，C++ 诞生了。\nC++ 完全兼容 C 语言，并在此之上增加了一个强大的新特性——面向对象编程（Object-Oriented Programming, OOP）。\n这是什么意思呢？想象一下，你要盖一栋房子。\n\nC 语言的方式（过程导向）：你会思考步骤，“先打地基 -&gt; 再砌墙 -&gt; 然后封顶 -&gt; 最后装修……”\nC++ 的方式（面向对象）：你会先思考这栋房子由哪些“对象”组成，比如“柱子”、“墙壁”、“窗户”、“门”。你会先设计好每个“对象”应该长什么样、有什么功能（比如窗户可以打开和关闭），然后再把这些预制好的对象“组装”成一栋房子。\n\n这种“面向对象”的思想，让 C++ 更适合开发规模宏大、逻辑复杂的软件系统。\n\n特点：\n\n继承了 C 语言的高效和底层控制力。\n通过“面向对象”思想，让代码的组织、复用和维护变得更加容易。\n功能极其强大，但也因此变得非常复杂，学习曲线陡峭。\n\n\n\n\n\n我们用 C/C++ 写下的代码（例如一个 .cpp 文件），计算机是看不懂的。它需要经历一个“翻译”和“组装”的过程，才能变成一个可以执行的程序（比如 Windows 上的 .exe 文件）。这个过程主要分为两步：\n\n编译（Compilation）\n\n编译器（Compiler） 就像一个语言翻译官。它会检查你的 C++ 代码有没有语法错误（比如拼写错了、标点不对等）。\n如果没问题，编译器会把你的代码“翻译”成一种更低级的语言——汇编语言（Assembly Language），并最终生成目标文件（Object File），里面是接近机器码的指令。\n\n链接（Linking）\n\n一个大型软件可能由成百上千个代码文件组成，每个文件都会被编译成一个目标文件。同时，我们的代码可能还会用到一些系统自带的功能库（比如处理屏幕显示、文件读写的功能）。\n链接器（Linker） 的工作就像一个项目经理，它会把所有这些零散的目标文件和你用到的系统功能库“链接”在一起，组装成一个完整的、可执行的程序。\n\n\n\n\n\n编译过程的中间产物——汇编语言，是机器语言的助记符形式。它和机器指令是一一对应的，但比纯粹的 0101 串更容易让人理解。例如，一条让 CPU 做加法运算的机器码可能是 10000011 11000011，对应的汇编指令可能是 ADD AX, BX。\n最终，程序运行时，这些指令会被加载到内存中。中央处理器（CPU），作为计算机的大脑，会一条一条地读取这些指令，并在其内部的运算单元和寄存器中执行它们（比如进行加减乘除、数据移动、逻辑判断等），从而完成程序指定的功能。\n总结一下 C/C++ 的世界：\n\n你写的 C++ 代码 -&gt; [编译器] -&gt; 汇编语言/目标文件 -&gt; [链接器] -&gt; 可执行程序 -&gt; [CPU] -&gt; 完成功能\n\n\n\n\n\n讲完了复杂的 C/C++，我们再来看 Python，你会瞬间感觉轻松很多。\nPython 的设计哲学是优雅、明确、简单。它不像 C++ 那样需要你手动管理内存，也不需要复杂的编译、链接过程。它是一种解释型语言 (Interpreted Language)。\n\n解释型 vs. 编译型：如果说 C++ 的编译器是把整本书一次性翻译完再出版，那么 Python 的解释器 (Interpreter) 就是一个同声传译。你说一句（写一行代码），它就翻译一句并立刻执行一句。这使得开发和调试过程变得非常快速和直观。\n\n\n\n这是初学者最容易混淆的地方。很多人以为下载一个 PyCharm 就是装了 Python。让我们用一个清晰的类比来区分它们：\n\nPython (语言本身)\n\n是什么：它就是“英语”这门语言本身，包含所有的词汇、语法规则。它是核心，是一切的基础。\n如何体现：你从 Python 官网下载的那个安装包，就是Python 解释器，是让你的电脑能够听懂 Python 这门语言的“翻译官”。\n\nPyCharm (IDE - 集成开发环境)\n\n是什么：它是一个高级的“Word 文档处理器”，专门用来写“英语作文”（Python 代码）。它提供了语法高亮（帮你区分动词名词）、自动补全（输入 pri 就提示 print）、错误检查、一键运行等便利功能。\n类比：你完全可以在记事本（最简单的文本编辑器）里写 Python 代码，但用 PyCharm 会让你的写作体验和效率大大提升。PyCharm 是写代码的工具，而不是语言本身。\n\nPip (包管理器)\n\n是什么：它是 Python 官方自带的“应用商店”。Python 的强大之处在于有海量的第三方库 (Library/Package)，这些库封装了各种强大的功能（比如数据分析、人工智能）。\n如何工作：当你想用一个叫 pandas 的库来分析数据时，你不需要自己去网站下载，只需在命令行里输入 pip install pandas，pip 就会自动帮你找到、下载并安装好这个库。\n\nConda (环境与包管理器)\n\n是什么：Conda 是一个更强大的“项目总管家”。它不仅有 Pip 的功能（也能安装库），还有一个核心功能——环境管理。\n为什么需要它：想象一下，你的项目A需要1.0版本的 pandas，而项目B需要2.0版本的 pandas，如果都装在系统里就会冲突。Conda 可以为你创建两个完全隔离的“房间”（环境），A房间里装1.0版，B房间里装2.0版，互不干扰。这对于管理复杂项目至关重要。\n\n\n总结一下：\n\n你决定用 Python (语言) 来完成一个任务。于是你打开 PyCharm (写作工具) 开始写代码。写到一半，你发现需要一个特殊工具，就用 Pip 或 Conda (应用商店) 下载了一个叫 pandas 的库 (功能包)来帮你处理数据。\n\n\n\n\n\n\n\n\n特性比较\nC / C++\nPython\n\n\n\n\n性能\n极致，像风一样快\n足够用，但比 C++ 慢（因为是解释执行）\n\n\n开发效率\n较低，代码长，编译慢\n极高，代码简洁，即写即运行\n\n\n学习难度\n陡峭，需要理解底层\n平缓，语法更接近自然语言\n\n\n核心比喻\n手动挡赛车\n自动挡智能汽车\n\n\n\n\n\n\n操作系统：Windows, macOS, Linux, Android, iOS 的核心部分都是用 C/C++ 写的。\n游戏开发：大型 3D 游戏引擎，如 Unreal Engine（虚幻引擎）、Unity（部分核心），需要榨干硬件的每一分性能来实现逼真的画面和物理效果。\n高性能计算/嵌入式系统：驱动你家智能微波炉、洗衣机的微型芯片，或者用于科学模拟和金融交易的服务器，都要求极致的效率和低延迟。\n浏览器/数据库：Google Chrome 浏览器、MySQL 数据库等，这些需要处理海量数据和高并发请求的底层软件。\n\n例子：当你玩一款次世代 3D 大作时，那流畅的画面、复杂的物理碰撞，背后就是 C++ 强大的性能在支撑。\n\n\n\n\n数据科学与人工智能（AI）：这是 Python 最闪耀的领域。无论是数据清洗、分析、可视化，还是构建复杂的机器学习、深度学习模型（例如人脸识别、推荐系统），Python 凭借 Pandas, NumPy, TensorFlow, PyTorch 等强大的库，成为了事实上的标准。\nWeb 开发：许多网站的后端服务是用 Python 搭建的，例如 Instagram, YouTube, 知乎。使用 Django 或 Flask 这样的框架，可以快速开发出功能完善的网站。\n自动化办公/网络爬虫：写个小程序自动处理 Excel 表格、批量下载文件、抓取网页上的信息，Python 是完成这些任务的绝佳工具，能把文科生从繁琐的重复劳动中解放出来。\n科学计算与教育：在科研和高校教育中，Python 因其简单易学和丰富的科学计算库而备受青睐。\n\n例子：今日头条、抖音为你推荐的短视频，背后就是基于 Python 的推荐算法在不知疲倦地学习你的偏好。你用 Python 写几十行代码，就能自动抓取所有同学的论文题目并整理成一个 Excel 表。\n\n\n\n\nPython 的强大不在于语言本身，而在于其背后无穷无尽的“功能库”。你不需要重新发明轮子，只需要学会如何使用这些强大的轮子。\n\n\n假设你有一个 Excel 文件 sales.csv，记录了不同产品的销售额。你想快速计算每种产品的平均销售额。\n\n# 导入强大的数据分析库 pandas\nimport pandas as pd\n\n# 1. 读取 Excel/CSV 文件，只需要一行代码\ndata = pd.read_csv('sales.csv')\n\n# 2. 按照 '产品名称' 分组，并计算 '销售额' 的平均值\naverage_sales = data.groupby('产品名称')['销售额'].mean()\n\n# 3. 打印结果\nprint(average_sales)\n\n解释：\n你不需要关心如何打开文件、如何一行行读取数据、如何创建字典来存储求和、如何计算平均值。pandas 这个库已经把所有复杂操作都封装好了。你只需要调用 read_csv 和 groupby().mean() 这两个简单的指令，就能完成传统方法可能需要几十上百行代码才能完成的工作。\n\n\n\n想不想体验一下 AI 的威力？比如，让 AI 判断一句话是积极的还是消极的？\n\n# 导入 Hugging Face 的 transformers 库，这是AI领域的利器\nfrom transformers import pipeline\n\n# 1. 创建一个情感分析的流水线，模型会自动下载\nsentiment_pipeline = pipeline(\"sentiment-analysis\")\n\n# 2. 分析一句话的情感\nresult = sentiment_pipeline(\"I love studying programming, it's so empowering!\")\nprint(result)\n# 输出可能类似: [{'label': 'POSITIVE', 'score': 0.999...}]\n\n解释：\n你不需要理解复杂的神经网络和 Transformer 模型。transformers 库让你只需要三行代码，就能调用一个训练好的、非常强大的 AI 模型来完成任务。这在几年前是不可想象的。对于文科同学，可以用它来做文本分析、舆情监控；对于商科同学，可以用它来分析用户评论。\n\n\n\n\n对于非计算机专业的同学来说，投入大量时间去学习 C++ 这样复杂的语言，性价比可能不高。而 Python，则是一项“低投入、高回报”的技能。\n\n易于上手：语法简单清晰，更符合人类的思维习惯，让你能快速体验到编程的乐趣和成就感。\n应用广泛，解决实际问题：你可以在你的专业领域找到它的用武之地。\n\n商科同学：可以用 Python 做量化交易、分析用户消费数据、预测销售趋势。\n文科同学：可以做社会调查数据分析、进行数字人文研究（如文本分析）、或者自动化处理文献资料。\n\n提升数据素养：在未来，无论从事什么行业，处理和分析数据的能力都将是核心竞争力。Python 是开启这扇大门的钥匙。\n思维的体操：学习编程能训练你的逻辑思维、抽象思维和解决问题的能力。这种思维方式的提升，会让你在任何领域都受益匪นาน。\n\n总结：学习 C++ 是在学习如何制造一辆高性能的汽车，而学习 Python 是在学习如何驾驶汽车去到任何你想去的地方，并利用汽车的便利性来完成你的工作。对于大多数人来说，学会“驾驶”远比学会“制造”更加实用和迫切。\n希望这份介绍能帮助大家对计算机编程有一个初步的、清晰的认识。编程不是一门高不可攀的技术，它只是一种强大的工具，等待着你去学习和使用它，来创造属于你的价值。",
    "crumbs": [
      "计算机工具简介",
      "1: 计算机科学基础与程序语言"
    ]
  },
  {
    "objectID": "Lessons/lesson1.html#计算机程序设计语言",
    "href": "Lessons/lesson1.html#计算机程序设计语言",
    "title": "1: 计算机科学基础与程序语言",
    "section": "",
    "text": "对于很多初学者而言，“编程”、“代码”这些词汇可能听起来像是另一个世界的语言，充满了神秘感和距离感。大家可能会觉得，我们又不当程序员，为什么要了解这些？\n其实，在今天这个高度数字化的时代，了解一些计算机科学的基本逻辑，能帮助我们更好地理解我们所生活的世界，提升解决问题的能力，甚至在未来的职业生涯中带来意想不到的优势。\n这篇介绍的目的，不是让大家成为专业的程序员，而是揭开编程的神秘面纱，让大家明白它到底是什么，以及它如何驱动我们每天使用的软件和应用。\n\n\n想象一下，你想让一位只会说英语的朋友帮你去图书馆借一本书。你必须用英语，按照清晰的逻辑（比如：先走到图书馆 -&gt; 然后找到特定区域 -&gt; 根据书名找到书架 -&gt; 最后办理借阅手续），一步步地告诉他该怎么做。\n程序设计语言（Programming Language），就是我们与计算机沟通的“语言”。\n计算机本质上只懂由 0 和 1 组成的“机器语言”，这对人类来说太复杂了。于是，科学家们发明了各种程序设计语言，让我们能用更接近人类自然语言的方式，给计算机下达一系列清晰、无歧义的指令，告诉它“做什么”以及“怎么做”。\n当我们写好的指令（我们称之为源代码）被计算机执行后，就能实现各种各样的功能——比如你正在使用的微信、你浏览的淘宝、你观看的视频，背后都是由千百万行代码构成的复杂程序。\n\n\n\n在众多编程语言中，C 和 C++ 是两座无法绕过的高峰。\n\n\nC 语言诞生于上世纪 70 年代，是一位真正的“元老”。它的设计哲学是简洁、高效、贴近底层硬件。你可以把它想象成手动挡的汽车，虽然操作起来比自动挡复杂，需要你精确控制离合和油门，但它能让你最大程度地掌控汽车的性能，开得飞快。\n\n特点：\n\n执行效率极高：代码被转换成机器指令后，几乎没有多余的动作，运行速度非常快。\n控制力强：可以直接操作内存（计算机存储数据的地方），像一个精密的外科医生，能精确控制计算机的每一个细节。\n过程导向：编程的思维方式是“一步一步做什么”，像一个流程图。\n\n\n\n\n\n随着软件越来越复杂，人们发现单纯用 C 语言来构建大型项目（比如一个操作系统或一个大型游戏）太困难了。于是，在 C 语言的基础上，C++ 诞生了。\nC++ 完全兼容 C 语言，并在此之上增加了一个强大的新特性——面向对象编程（Object-Oriented Programming, OOP）。\n这是什么意思呢？想象一下，你要盖一栋房子。\n\nC 语言的方式（过程导向）：你会思考步骤，“先打地基 -&gt; 再砌墙 -&gt; 然后封顶 -&gt; 最后装修……”\nC++ 的方式（面向对象）：你会先思考这栋房子由哪些“对象”组成，比如“柱子”、“墙壁”、“窗户”、“门”。你会先设计好每个“对象”应该长什么样、有什么功能（比如窗户可以打开和关闭），然后再把这些预制好的对象“组装”成一栋房子。\n\n这种“面向对象”的思想，让 C++ 更适合开发规模宏大、逻辑复杂的软件系统。\n\n特点：\n\n继承了 C 语言的高效和底层控制力。\n通过“面向对象”思想，让代码的组织、复用和维护变得更加容易。\n功能极其强大，但也因此变得非常复杂，学习曲线陡峭。\n\n\n\n\n\n我们用 C/C++ 写下的代码（例如一个 .cpp 文件），计算机是看不懂的。它需要经历一个“翻译”和“组装”的过程，才能变成一个可以执行的程序（比如 Windows 上的 .exe 文件）。这个过程主要分为两步：\n\n编译（Compilation）\n\n编译器（Compiler） 就像一个语言翻译官。它会检查你的 C++ 代码有没有语法错误（比如拼写错了、标点不对等）。\n如果没问题，编译器会把你的代码“翻译”成一种更低级的语言——汇编语言（Assembly Language），并最终生成目标文件（Object File），里面是接近机器码的指令。\n\n链接（Linking）\n\n一个大型软件可能由成百上千个代码文件组成，每个文件都会被编译成一个目标文件。同时，我们的代码可能还会用到一些系统自带的功能库（比如处理屏幕显示、文件读写的功能）。\n链接器（Linker） 的工作就像一个项目经理，它会把所有这些零散的目标文件和你用到的系统功能库“链接”在一起，组装成一个完整的、可执行的程序。\n\n\n\n\n\n编译过程的中间产物——汇编语言，是机器语言的助记符形式。它和机器指令是一一对应的，但比纯粹的 0101 串更容易让人理解。例如，一条让 CPU 做加法运算的机器码可能是 10000011 11000011，对应的汇编指令可能是 ADD AX, BX。\n最终，程序运行时，这些指令会被加载到内存中。中央处理器（CPU），作为计算机的大脑，会一条一条地读取这些指令，并在其内部的运算单元和寄存器中执行它们（比如进行加减乘除、数据移动、逻辑判断等），从而完成程序指定的功能。\n总结一下 C/C++ 的世界：\n\n你写的 C++ 代码 -&gt; [编译器] -&gt; 汇编语言/目标文件 -&gt; [链接器] -&gt; 可执行程序 -&gt; [CPU] -&gt; 完成功能\n\n\n\n\n\n讲完了复杂的 C/C++，我们再来看 Python，你会瞬间感觉轻松很多。\nPython 的设计哲学是优雅、明确、简单。它不像 C++ 那样需要你手动管理内存，也不需要复杂的编译、链接过程。它是一种解释型语言 (Interpreted Language)。\n\n解释型 vs. 编译型：如果说 C++ 的编译器是把整本书一次性翻译完再出版，那么 Python 的解释器 (Interpreter) 就是一个同声传译。你说一句（写一行代码），它就翻译一句并立刻执行一句。这使得开发和调试过程变得非常快速和直观。\n\n\n\n这是初学者最容易混淆的地方。很多人以为下载一个 PyCharm 就是装了 Python。让我们用一个清晰的类比来区分它们：\n\nPython (语言本身)\n\n是什么：它就是“英语”这门语言本身，包含所有的词汇、语法规则。它是核心，是一切的基础。\n如何体现：你从 Python 官网下载的那个安装包，就是Python 解释器，是让你的电脑能够听懂 Python 这门语言的“翻译官”。\n\nPyCharm (IDE - 集成开发环境)\n\n是什么：它是一个高级的“Word 文档处理器”，专门用来写“英语作文”（Python 代码）。它提供了语法高亮（帮你区分动词名词）、自动补全（输入 pri 就提示 print）、错误检查、一键运行等便利功能。\n类比：你完全可以在记事本（最简单的文本编辑器）里写 Python 代码，但用 PyCharm 会让你的写作体验和效率大大提升。PyCharm 是写代码的工具，而不是语言本身。\n\nPip (包管理器)\n\n是什么：它是 Python 官方自带的“应用商店”。Python 的强大之处在于有海量的第三方库 (Library/Package)，这些库封装了各种强大的功能（比如数据分析、人工智能）。\n如何工作：当你想用一个叫 pandas 的库来分析数据时，你不需要自己去网站下载，只需在命令行里输入 pip install pandas，pip 就会自动帮你找到、下载并安装好这个库。\n\nConda (环境与包管理器)\n\n是什么：Conda 是一个更强大的“项目总管家”。它不仅有 Pip 的功能（也能安装库），还有一个核心功能——环境管理。\n为什么需要它：想象一下，你的项目A需要1.0版本的 pandas，而项目B需要2.0版本的 pandas，如果都装在系统里就会冲突。Conda 可以为你创建两个完全隔离的“房间”（环境），A房间里装1.0版，B房间里装2.0版，互不干扰。这对于管理复杂项目至关重要。\n\n\n总结一下：\n\n你决定用 Python (语言) 来完成一个任务。于是你打开 PyCharm (写作工具) 开始写代码。写到一半，你发现需要一个特殊工具，就用 Pip 或 Conda (应用商店) 下载了一个叫 pandas 的库 (功能包)来帮你处理数据。\n\n\n\n\n\n\n\n\n特性比较\nC / C++\nPython\n\n\n\n\n性能\n极致，像风一样快\n足够用，但比 C++ 慢（因为是解释执行）\n\n\n开发效率\n较低，代码长，编译慢\n极高，代码简洁，即写即运行\n\n\n学习难度\n陡峭，需要理解底层\n平缓，语法更接近自然语言\n\n\n核心比喻\n手动挡赛车\n自动挡智能汽车\n\n\n\n\n\n\n操作系统：Windows, macOS, Linux, Android, iOS 的核心部分都是用 C/C++ 写的。\n游戏开发：大型 3D 游戏引擎，如 Unreal Engine（虚幻引擎）、Unity（部分核心），需要榨干硬件的每一分性能来实现逼真的画面和物理效果。\n高性能计算/嵌入式系统：驱动你家智能微波炉、洗衣机的微型芯片，或者用于科学模拟和金融交易的服务器，都要求极致的效率和低延迟。\n浏览器/数据库：Google Chrome 浏览器、MySQL 数据库等，这些需要处理海量数据和高并发请求的底层软件。\n\n例子：当你玩一款次世代 3D 大作时，那流畅的画面、复杂的物理碰撞，背后就是 C++ 强大的性能在支撑。\n\n\n\n\n数据科学与人工智能（AI）：这是 Python 最闪耀的领域。无论是数据清洗、分析、可视化，还是构建复杂的机器学习、深度学习模型（例如人脸识别、推荐系统），Python 凭借 Pandas, NumPy, TensorFlow, PyTorch 等强大的库，成为了事实上的标准。\nWeb 开发：许多网站的后端服务是用 Python 搭建的，例如 Instagram, YouTube, 知乎。使用 Django 或 Flask 这样的框架，可以快速开发出功能完善的网站。\n自动化办公/网络爬虫：写个小程序自动处理 Excel 表格、批量下载文件、抓取网页上的信息，Python 是完成这些任务的绝佳工具，能把文科生从繁琐的重复劳动中解放出来。\n科学计算与教育：在科研和高校教育中，Python 因其简单易学和丰富的科学计算库而备受青睐。\n\n例子：今日头条、抖音为你推荐的短视频，背后就是基于 Python 的推荐算法在不知疲倦地学习你的偏好。你用 Python 写几十行代码，就能自动抓取所有同学的论文题目并整理成一个 Excel 表。\n\n\n\n\nPython 的强大不在于语言本身，而在于其背后无穷无尽的“功能库”。你不需要重新发明轮子，只需要学会如何使用这些强大的轮子。\n\n\n假设你有一个 Excel 文件 sales.csv，记录了不同产品的销售额。你想快速计算每种产品的平均销售额。\n\n# 导入强大的数据分析库 pandas\nimport pandas as pd\n\n# 1. 读取 Excel/CSV 文件，只需要一行代码\ndata = pd.read_csv('sales.csv')\n\n# 2. 按照 '产品名称' 分组，并计算 '销售额' 的平均值\naverage_sales = data.groupby('产品名称')['销售额'].mean()\n\n# 3. 打印结果\nprint(average_sales)\n\n解释：\n你不需要关心如何打开文件、如何一行行读取数据、如何创建字典来存储求和、如何计算平均值。pandas 这个库已经把所有复杂操作都封装好了。你只需要调用 read_csv 和 groupby().mean() 这两个简单的指令，就能完成传统方法可能需要几十上百行代码才能完成的工作。\n\n\n\n想不想体验一下 AI 的威力？比如，让 AI 判断一句话是积极的还是消极的？\n\n# 导入 Hugging Face 的 transformers 库，这是AI领域的利器\nfrom transformers import pipeline\n\n# 1. 创建一个情感分析的流水线，模型会自动下载\nsentiment_pipeline = pipeline(\"sentiment-analysis\")\n\n# 2. 分析一句话的情感\nresult = sentiment_pipeline(\"I love studying programming, it's so empowering!\")\nprint(result)\n# 输出可能类似: [{'label': 'POSITIVE', 'score': 0.999...}]\n\n解释：\n你不需要理解复杂的神经网络和 Transformer 模型。transformers 库让你只需要三行代码，就能调用一个训练好的、非常强大的 AI 模型来完成任务。这在几年前是不可想象的。对于文科同学，可以用它来做文本分析、舆情监控；对于商科同学，可以用它来分析用户评论。\n\n\n\n\n对于非计算机专业的同学来说，投入大量时间去学习 C++ 这样复杂的语言，性价比可能不高。而 Python，则是一项“低投入、高回报”的技能。\n\n易于上手：语法简单清晰，更符合人类的思维习惯，让你能快速体验到编程的乐趣和成就感。\n应用广泛，解决实际问题：你可以在你的专业领域找到它的用武之地。\n\n商科同学：可以用 Python 做量化交易、分析用户消费数据、预测销售趋势。\n文科同学：可以做社会调查数据分析、进行数字人文研究（如文本分析）、或者自动化处理文献资料。\n\n提升数据素养：在未来，无论从事什么行业，处理和分析数据的能力都将是核心竞争力。Python 是开启这扇大门的钥匙。\n思维的体操：学习编程能训练你的逻辑思维、抽象思维和解决问题的能力。这种思维方式的提升，会让你在任何领域都受益匪นาน。\n\n总结：学习 C++ 是在学习如何制造一辆高性能的汽车，而学习 Python 是在学习如何驾驶汽车去到任何你想去的地方，并利用汽车的便利性来完成你的工作。对于大多数人来说，学会“驾驶”远比学会“制造”更加实用和迫切。\n希望这份介绍能帮助大家对计算机编程有一个初步的、清晰的认识。编程不是一门高不可攀的技术，它只是一种强大的工具，等待着你去学习和使用它，来创造属于你的价值。",
    "crumbs": [
      "计算机工具简介",
      "1: 计算机科学基础与程序语言"
    ]
  },
  {
    "objectID": "Lessons/byl.html",
    "href": "Lessons/byl.html",
    "title": "博弈论与机制设计",
    "section": "",
    "text": "博弈论与机制设计\n吕博涵整理\nlyubh.cn\n2025-07-11",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#什么是博弈",
    "href": "Lessons/byl.html#什么是博弈",
    "title": "博弈论与机制设计",
    "section": "什么是博弈？",
    "text": "什么是博弈？\n一个博弈主要由三个要素构成 ：\n\n参与人 (Players)：博弈的决策主体。\n规则 (Rules)：规定了参与人可以采取的行动、行动的顺序以及他们拥有的信息。\n收益/支付 (Payoffs)：当所有参与人做出决策后，每个参与人得到的效用或回报。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#正规形式博弈-normal-form-game",
    "href": "Lessons/byl.html#正规形式博弈-normal-form-game",
    "title": "博弈论与机制设计",
    "section": "正规形式博弈 (Normal Form Game)",
    "text": "正规形式博弈 (Normal Form Game)\n正规形式博弈，也称为策略形式博弈，通常用于描述参与人同时做出决策（或者等同于同时做出）的博弈。\n特点：非合作 (Non-cooperative)，即参与人不能进行有约束力的承诺或协议。\n\n例子 1 (囚徒困境 (Prisoner’s Dilemma)). 两名囚徒被分开审讯，他们可以选择合作（C: 告诉同伙/保持沉默）或背叛（D: 告诉警察）。效用表示为 (囚徒1的效用, 囚徒2的效用)。负数越大表示惩罚越重。\n假设效用如下 (注释中的C,D含义与笔记相反，这里采用笔记中的C:坦白, D:抵赖，但为了与经典囚徒困境含义一致，我们设C=抵赖，D=坦白)：\n笔记中的原始效用 (C:坦白, D:抵赖)：\n\\[\\begin{array}{c|cc}\n    \\text{参与人1 / 参与人2} & \\text{C (坦白)} & \\text{D (抵赖)} \\\\\n    \\hline\n    \\text{C (坦白)} & -3,-3 & -1,-4 \\\\\n    \\text{D (抵赖)} & -4,-1 & 0,0 \\\\\n\\end{array}\\]\n在这个例子中，\"坦白\" 是每个参与人的占优策略。\"均选择坦白\" (-3,-3) 是纳什均衡。\n如果我们将 C 定义为”合作/沉默”，D 定义为”背叛/坦白”，一个更经典的支付矩阵可能是：\n\\[\\begin{array}{c|cc}\n    \\text{参与人1 / 参与人2} & \\text{C (合作/沉默)} & \\text{D (背叛/坦白)} \\\\\n    \\hline\n    \\text{C (合作/沉默)} & -1,-1 & -10,0 \\\\\n    \\text{D (背叛/坦白)} & 0,-10 & -5,-5 \\\\\n\\end{array}\\]\n在这个经典版本中，(D,D) 即 (-5,-5) 是纳什均衡，尽管 (C,C) 即 (-1,-1) 对双方都更好。\n笔记中的 (-3,-3) 对应经典版 (D,D)，(0,0) 对应经典版 (C,C)。\n\n\n策略的优劣势\n\n严格占优策略 (Strictly Dominant Strategy)：一个策略 \\(\\hat{a}_i\\) 对参与人 \\(i\\) 来说是严格占优策略，如果无论其他参与人选择什么策略，选择 \\(\\hat{a}_i\\) 的收益总是严格大于选择任何其他策略 \\(a_i \\neq \\hat{a}_i\\) 的收益。\nFormal: \\(\\Pi^i(\\hat{a}_i, a_{-i}) &gt; \\Pi^i(a_i, a_{-i})\\) for all \\(a_i \\neq \\hat{a}_i\\) and for all \\(a_{-i} \\in A_{-i}\\).\n弱占优策略 (Weakly Dominant Strategy)：一个策略 \\(\\hat{a}_i\\) 对参与人 \\(i\\) 来说是弱占优策略，如果无论其他参与人选择什么策略，选择 \\(\\hat{a}_i\\) 的收益总是大于或等于选择任何其他策略 \\(a_i \\neq \\hat{a}_i\\) 的收益，并且至少在一种其他参与人的策略组合下，选择 \\(\\hat{a}_i\\) 的收益严格更高。\nFormal: \\(\\Pi^i(\\hat{a}_i, a_{-i}) \\ge \\Pi^i(a_i, a_{-i})\\) for all \\(a_i \\neq \\hat{a}_i\\) and for all \\(a_{-i} \\in A_{-i}\\), and \\(\\exists a_{-i}' \\in A_{-i}\\) such that \\(\\Pi^i(\\hat{a}_i, a_{-i}') &gt; \\Pi^i(a_i, a_{-i}')\\).\n严格劣策略 (Strictly Dominated Strategy)：一个策略 \\(a_i'\\) 是严格劣策略，如果存在另一个策略 \\(a_i\\) 使得无论其他参与人选择什么， \\(a_i\\) 的收益总是严格大于 \\(a_i'\\) 的收益。\n弱劣策略 (Weakly Dominated Strategy)：一个策略 \\(a_i'\\) 是弱劣策略，如果存在另一个策略 \\(a_i\\) 使得无论其他参与人选择什么， \\(a_i\\) 的收益总是大于或等于 \\(a_i'\\) 的收益，并且至少在一种其他参与人的策略组合下，\\(a_i\\) 的收益严格更高。\n\n重要结论：在寻找纳什均衡时，可以忽略严格劣策略。弱劣策略的剔除需要更谨慎。\n\n\n纳什均衡 (Nash Equilibrium)\n\n定义 2 (纳什均衡). 在一个 \\(n\\) 人正规形式博弈中，策略组合 \\((a_1^*, a_2^*, \\dots, a_n^*)\\) 是一个纳什均衡，如果对于每一个参与人 \\(i \\in \\{1, 2, \\dots, n\\}\\)，策略 \\(a_i^*\\) 是在给定其他参与人选择 \\(a_{-i}^* = (a_1^*, \\dots, a_{i-1}^*, a_{i+1}^*, \\dots, a_n^*)\\) 的情况下的最优反应 (best response)。也就是说，没有任何一个参与人有动机单方面改变自己的策略。\nFormal: 对于任意 \\(i \\in \\{1, 2, \\dots, n\\}\\)，以及任意 \\(a_i \\in A_i\\)，都有：\\(\\Pi^i(a_i^*, a_{-i}^*) \\ge \\Pi^i(a_i, a_{-i}^*)\\)，此时称 \\(a_i^*\\) 是对 \\(a_{-i}^*\\) 的最优反应。\n\n纳什均衡不一定是唯一的。\n\n例子 3 (协调博弈 (Coordination Game)). \\[\\begin{array}{c|cc}\n     & \\text{A} & \\text{B} \\\\\n    \\hline\n    \\text{A} & 2,2 & 0,0 \\\\\n    \\text{B} & 0,0 & 1,1 \\\\\n\\end{array}\\] 在这个博弈中，(A,A) 和 (B,B) 都是纯策略纳什均衡。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#混合策略-mixed-strategies",
    "href": "Lessons/byl.html#混合策略-mixed-strategies",
    "title": "博弈论与机制设计",
    "section": "混合策略 (Mixed Strategies)",
    "text": "混合策略 (Mixed Strategies)\n当纯策略纳什均衡不存在，或者参与人希望让对手难以预测自己的行为时，会使用混合策略。混合策略是参与人在其可用纯策略集合上选择的一个概率分布。\n\n例子 4 (剪刀石头布 (Rock-Paper-Scissors)). 效用矩阵如下 (赢+1, 输-1, 平0)： \\[\\begin{array}{c|ccc}\n    \\text{1 / 2} & \\text{石头(R)} & \\text{布(P)} & \\text{剪刀(S)} \\\\\n    \\hline\n    \\text{石头(R)} & 0,0 & -1,1 & 1,-1 \\\\\n    \\text{布(P)} & 1,-1 & 0,0 & -1,1 \\\\\n    \\text{剪刀(S)} & -1,1 & 1,-1 & 0,0 \\\\\n\\end{array}\\] 这个博弈没有纯策略纳什均衡。 唯一的混合策略纳什均衡是双方都以 \\((1/3, 1/3, 1/3)\\) 的概率随机选择石头、布、剪刀。此时，双方的期望支付都是0。\n\n混合策略的条件：当一个参与人愿意混合使用某些纯策略时，这些纯策略在给定对手策略的情况下，必须能给该参与人带来相同的期望效用。否则，他会选择期望效用最高的那个纯策略。\n\n例子 5 (混合策略求解). 考虑以下博弈，参与人1选择A或B的概率为 \\(p\\) 和 \\(1-p\\)；参与人2选择A或B的概率为 \\(q\\) 和 \\(1-q\\)。 \\[\\begin{array}{c|cc}\n    \\text{1 / 2} & \\text{A ($q$)} & \\text{B ($1-q$)} \\\\\n    \\hline\n    \\text{A ($p$)} & 1,1 & 0,0 \\\\\n    \\text{B ($1-p$)} & 0,0 & 2,2 \\\\\n\\end{array}\\] 对于参与人1： 期望效用 \\(\\Pi^1(A) = q \\cdot 1 + (1-q) \\cdot 0 = q\\) 期望效用 \\(\\Pi^1(B) = q \\cdot 0 + (1-q) \\cdot 2 = 2-2q\\) 若要混合A和B，则 \\(\\Pi^1(A) = \\Pi^1(B) \\implies q = 2-2q \\implies 3q=2 \\implies q=2/3\\)。 同理，对于参与人2可解得 \\(p=2/3\\)。 因此，一个混合策略纳什均衡是双方都以 \\(2/3\\) 的概率选择A，以 \\(1/3\\) 的概率选择B。 ((A,A), (B,B) 也是纯策略纳什均衡)。\n笔记中 的另一个例子： \\[\\begin{array}{c|ccc}\n    \\text{1 / 2} & \\text{D} & \\text{E} & \\text{F} \\\\\n    \\hline\n    \\text{A} & 1,1 & 0,0 & 0,0 \\\\\n    \\text{B} & 0,0 & 2,2 & 0,0 \\\\\n    \\text{C} & 0,0 & 0,0 & 3,3 \\\\\n\\end{array}\\] 纯策略纳什均衡有 (A,D), (B,E), (C,F)。 考虑参与人1混合A和B，参与人2混合D和E。假设参与人1选择A的概率为\\(p_A\\)，B为\\(p_B\\) (\\(p_C=0\\))；参与人2选择D的概率为\\(q_D\\)，E为\\(q_E\\) (\\(q_F=0\\))。 \\(\\Pi^1(A) = q_D \\cdot 1 + q_E \\cdot 0 = q_D\\) \\(\\Pi^1(B) = q_D \\cdot 0 + q_E \\cdot 2 = 2q_E\\) 若混合A,B，则 \\(q_D = 2q_E\\)。因为 \\(q_D+q_E=1\\)，所以 \\(q_D=2/3, q_E=1/3\\)。 同理，对参与人2： \\(\\Pi^2(D) = p_A \\cdot 1 + p_B \\cdot 0 = p_A\\) \\(\\Pi^2(E) = p_A \\cdot 0 + p_B \\cdot 2 = 2p_B\\) 若混合D,E，则 \\(p_A = 2p_B\\)。因为 \\(p_A+p_B=1\\)，所以 \\(p_A=2/3, p_B=1/3\\)。 此时，参与人1选择A的期望效用为 \\(2/3\\)，选择B的期望效用也为 \\(2/3\\)。选择C的期望效用为0。由于 \\(2/3 \\ge 0\\)，参与人1不会切换到C。 参与人2同理。 所以一个混合策略纳什均衡是 \\(a_1 = (2/3, 1/3, 0)\\)，\\(a_2 = (2/3, 1/3, 0)\\)。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#扩展形式博弈-extensive-form-game-game-tree",
    "href": "Lessons/byl.html#扩展形式博弈-extensive-form-game-game-tree",
    "title": "博弈论与机制设计",
    "section": "扩展形式博弈 (Extensive Form Game / Game Tree)",
    "text": "扩展形式博弈 (Extensive Form Game / Game Tree)\n扩展形式博弈用博弈树来表示，它明确了参与人的行动顺序、每个决策节点的信息以及最终的支付。\n\n例子 6 (抢劫者博弈). 参与人1 (受害者) 可以选择给钱 (-100) 或不给钱 (0)。 如果给钱，博弈结束，支付为 (-100, +100)。 如果不给钱，参与人2 (抢劫者) 可以选择走开 (Walk away) 或杀人 (Kill)。 若走开，支付为 (0,0)。 若杀人，支付为 \\((-\\infty, -1000)\\) (这里的-1000对抢劫者来说也是极差的结果，表示被捕等)。 博弈树表示：\n\n节点1 (参与人1决策):\n\n动作: 给$100 \\(\\rightarrow\\) 支付: \\((-100, +100)\\)\n动作: 给$0 \\(\\rightarrow\\) 进入节点2 (参与人2决策)\n\n动作: 走开 \\(\\rightarrow\\) 支付: \\((0,0)\\)\n动作: 杀人 \\(\\rightarrow\\) 支付: \\((-\\infty, -1000)\\)\n\n\n\n\n\n子博弈 (Subgame)\n\n定义 7 (子博弈). 一个扩展形式博弈的子博弈是原博弈的一部分，它满足：\n\n它从一个单独的决策节点开始。\n它包含该节点之后的所有决策节点和终端节点。\n如果一个决策节点属于子博弈，那么该节点所在信息集中的所有其他节点也必须属于该子博弈 (即不能打断信息集)。\n\n\n信息集 (Information Set)：如果一个参与人在某个决策节点做决策时，不知道自己确切处于该信息集中的哪一个具体节点，那么这些节点构成一个信息集。\n\n\n子博弈完美纳什均衡 (Subgame Perfect Nash Equilibrium - SPE)\n\n定义 8 (SPE). 一个策略组合是子博弈完美纳什均衡，如果它在整个博弈中构成纳什均衡，并且在每一个子博弈中也都构成纳什均衡。\n\nSPE通过逆向归纳法 (Backward Induction) 求解，从最后一个子博弈开始分析，逐步向前推导。SPE排除了包含”不可信威胁 (incredible threat)“的纳什均衡。\n在抢劫者博弈中 ： 子博弈：从参与人2的决策节点开始。\n\n在该子博弈中，参与人2比较”走开”(0) 和”杀人”(-1000) 的效用。理性选择是”走开”。\n\n现在回到参与人1的决策：\n\n如果给$100，效用为 -100。\n如果不给$0，预料到参与人2会”走开”，则效用为 0。\n\n参与人1比较 -100 和 0，选择不给$0。 因此，SPE是：参与人1选择”不给$0”；参与人2的策略是”如果参与人1不给钱，则选择走开”。支付为 (0,0)。 笔记中提到的一个非SPE的纳什均衡是：\\(a_1\\)=给$100, \\(a_2\\)=杀人 (如果参与人1不给钱)。这是纳什均衡，因为给定\\(a_2\\)，参与人1给钱是最佳选择；给定\\(a_1\\)，参与人2无论做什么都无所谓，因为其决策节点不会到达。但”杀人”是不可信威胁。\n\n例子 9 (蜈蚣博弈 (Centipede Game)). 两个参与人轮流选择”继续 (K)“或”停止 (S)“。每次”继续”都会使总金额增加，但将决策权交给对方；选择”停止”则拿走当前总金额的较大部分。 例如：\n\n1开始: (S) \\(\\rightarrow\\) (1,1) ; (K) \\(\\rightarrow\\) 轮到2\n2决策: (S) \\(\\rightarrow\\) (0,3) ; (K) \\(\\rightarrow\\) 轮到1\n1决策: (S) \\(\\rightarrow\\) (2,2) ; (K) \\(\\rightarrow\\) 轮到2\n2决策: (S) \\(\\rightarrow\\) (1,4) ; (K) \\(\\rightarrow\\) ...\n...\n假设最后一步是100轮后，2决策: (S) \\(\\rightarrow\\) (99,99) ; (K) \\(\\rightarrow\\) (98,101)\n101轮后，1决策: (S) \\(\\rightarrow\\) (100,100)\n\n通过逆向归纳法，SPE是参与人1在第一个决策节点就选择”停止 (S)“，获得支付 (1,1)。\n\n\n例子 10 (鲁宾斯坦交替出价谈判模型 (Rubinstein Alternating Offer Bargaining Game)). 两个参与人轮流提议如何分割一块大小为1的”馅饼”。馅饼会随时间”融化”，即存在时间折扣因子 \\(\\delta \\in [0,1]\\)。\n\nPeriod 1 (参与人1提议): 提议 \\(x_1\\) 给自己，则 \\(1-x_1\\) 给参与人2。参与人2选择接受或拒绝。\n\n接受: 支付 \\((x_1, 1-x_1)\\)\n拒绝: 进入Period 2，总馅饼大小变为 \\(\\delta\\)\n\nPeriod 2 (参与人2提议): 提议 \\(x_2\\) 给自己，则 \\(\\delta-x_2\\) 给参与人1。(注意这里 \\(x_2\\) 是从当前总额 \\(\\delta\\) 中分的) 更常见的表示是，参与人2提议自己分得 \\(y_2 \\in [0,1]\\) 的比例，则其收益为 \\(y_2 \\delta\\)，参与人1收益为 \\((1-y_2)\\delta\\)。我们采用笔记中的方式。 参与人2提议自己分得份额 \\(s_2\\)，则参与人1得到 \\(\\delta-s_2\\)。参与人1接受或拒绝。\n\n接受: 支付 \\((\\delta-s_2, s_2)\\)\n拒绝: 进入Period 3，总馅饼大小变为 \\(\\delta^2\\)\n\nPeriod 3 (参与人1提议): ...\n\n笔记中的 \\(x_i\\) 指的是当期提议者给自己留下的份额。 假设 \\(T\\)期结束，如果到 \\(T\\) 期还未达成协议，则双方支付为0。\n\n逆向归纳 (以3期为例，笔记中 \\(x_i\\) 为提议者提议给自己的份额)：\n\nPeriod 3 (参与人1提议): 参与人2会接受任何 \\(1-x_3 \\ge 0\\) (因为拒绝则得到0)。所以参与人1会提议 \\(x_3=1\\) (即自己拿走所有剩余的 \\(\\delta^2\\))。参与人2得到0。此时对参与人1的价值是 \\(\\delta^2\\)。\nPeriod 2 (参与人2提议，总额为 \\(\\delta\\)): 参与人1会接受如果自己得到的份额 \\(x_1' \\ge \\delta \\cdot (\\text{参与人1在第3期得到的份额的折现值})\\)。 笔记中符号为：参与人2提议自己拿 \\(x_2\\)，给参与人1的份额是 \\(\\delta-x_2\\) (注意这里不是比例，而是绝对值)。参与人1接受条件是 \\(\\delta-x_2 \\ge \\delta \\cdot \\delta^2 = \\delta^3\\) (这是参与人1在第三期得到的\\(\\delta^2\\)再折现到第二期)。不对，应该是参与人1在第3期提议时，他会得到整个当时的饼 \\(\\delta^2\\)。所以，参与人2在第2期提议时，要使得参与人1接受，必须给参与人1的份额至少等于参与人1在第3期能得到的份额的折现值，即 \\(\\delta \\cdot (\\text{Player 1's payoff if P3 is reached})\\). 按笔记 \\(x_3=1\\) (指P1拿走P3的全部饼 \\(\\delta^2\\))。 P2: P2提议自己拿 \\(x_2\\) (实际是比例，这里符号有点乱)。P2能给P1的最少是 \\(x_3 \\cdot \\delta\\) (这是符号错误，应为P1在P3能拿到的\\(\\delta^2\\)的价值折现到P2)。 我们按标准模型和笔记结果来： P3: P1提议，P1得 \\(\\delta^2\\), P2得 \\(0\\). P2: P2提议。P1的拒绝选项是在P3得到 \\(\\delta^2\\) (折现到P2是 \\(\\delta \\cdot \\delta^2 = \\delta^3\\) – 这种理解是错误的)。 正确理解：如果P2拒绝P1在P3的提议，P2得到0。所以P1在P3提议 \\((x_3=1, 1-x_3=0)\\)，P1得 \\(\\delta^2\\), P2得 \\(0\\)。 P2: P2提议。P1知道如果拒绝，P1在P3会得到 \\(\\delta^2\\)。所以P1在P2接受的条件是自己得到的份额 \\(\\ge \\delta \\cdot (\\text{P1在P3的份额}) = \\delta \\cdot \\delta^2 = \\delta^3\\)。 这是错误的。 P1在P3得到的是当时的全部 \\(\\delta^2\\) (未折现的，因为那是P3的支付)。P2提议时，P1比较的是P2给他的 和 他在P3能得到的(折现到P2)。所以P1要求 \\(\\text{share from P2} \\ge \\delta \\cdot \\delta^2\\)。\n\n按笔记的 \\(x_i\\) 定义 (当期提议者提议留给自己的份额)： Period 3 (P1提议, 总额 \\(\\delta^2\\)): P1提议 \\(x_3=\\delta^2\\), P2得0。P1接受。 Period 2 (P2提议, 总额 \\(\\delta\\)): P1若拒绝，则在P3得到 \\(\\delta \\cdot \\delta^2 = \\delta^3\\) (折现到P1时刻)。不对，P1在P3得到的是\\(\\delta^2\\)，折现到P2时刻是 \\(\\delta \\cdot (\\text{P1在P3得到的份额}) = \\delta \\cdot \\delta^2\\)。这还是不对。\n让我们严格按照笔记的最终公式和逻辑 ： \\(x_i\\) 是第 \\(i\\) 期提议者提议给自己的份额 (相对于当前总额)。 Period 3 (P1提议, 总价值 \\(\\delta^2\\)): P2会接受任何 \\(1-x_3 \\ge 0\\) (指分配比例)。P1提议 \\(x_3=1\\) (P1拿全部)。P1得 \\(\\delta^2 \\cdot 1 = \\delta^2\\)。P2得 \\(0\\)。 Period 2 (P2提议, 总价值 \\(\\delta\\)): P1若拒绝，P1在P3得到的份额是 \\(\\delta^2\\) (这是P3的价值)。P1在P2时，P3的价值折现为 \\(\\delta \\cdot \\delta^2\\) (P1在P3得到的份额 \\(\\times\\) P3的价值)。 P1在P2接受条件是： \\(1-x_2 \\ge \\delta x_3^*\\) (其中 \\(x_3^*\\) 是P1在P3能确保得到的份额，这里是1)。 即 \\(1-x_2 \\ge \\delta \\cdot 1 \\implies (1-x_2)\\delta \\ge \\delta^2 \\cdot 1\\) (这是P1在P2得到的实际价值)。 P2会使得P1刚好接受，即 \\((1-x_2)\\delta = \\delta^2 \\cdot 1 \\implies 1-x_2 = \\delta \\implies x_2 = 1-\\delta\\) (P2提议自己拿 \\(1-\\delta\\) 的比例)。 P2的收益是 \\((1-\\delta)\\delta = \\delta-\\delta^2\\)。P1的收益是 \\(\\delta \\cdot \\delta = \\delta^2\\)。 Period 1 (P1提议, 总价值 \\(1\\)): P2若拒绝，P2在P2能得到的份额是 \\((1-\\delta)\\delta = \\delta-\\delta^2\\)。 P1提议自己拿 \\(x_1\\)。P2接受条件是 \\(1-x_1 \\ge \\delta \\cdot (\\text{P2在P2得到的份额的比例 } x_2^*) = \\delta (1-\\delta)\\) (这是P2在P2得到的实际价值 \\(\\delta-\\delta^2\\) 折现到P1)。 即 \\(1-x_1 \\ge \\delta(1-\\delta) = \\delta-\\delta^2\\)。 P1会使得P2刚好接受，即 \\(x_1 = 1 - (\\delta-\\delta^2) = 1-\\delta+\\delta^2\\)。 P1的收益是 \\(1-\\delta+\\delta^2\\)。P2的收益是 \\(\\delta-\\delta^2\\)。\n当 \\(T \\to +\\infty\\): \\(x_1 = 1 - \\delta + \\delta^2 - \\delta^3 + \\dots = \\frac{1}{1+\\delta}\\) \\(1-x_1 = \\frac{\\delta}{1+\\delta}\\) 参与人1 (先出价者) 得到 \\(\\frac{1}{1+\\delta}\\)，参与人2得到 \\(\\frac{\\delta}{1+\\delta}\\)。存在先动优势。\n稳态均衡 (Stationary Equilibrium): 假设参与人在相似情境下做出的决策相同。即 \\(x_1 = x_3 = x_5 = \\dots = x^*\\) (P1的提议)。\\(x_2 = x_4 = \\dots = \\hat{x}\\) (P2的提议)。 P1提议 \\(x^*\\)。P2接受条件: \\(1-x^* \\ge \\delta \\hat{x}\\) (P2在下一期自己提议能得到的折现值)。P1会给P2刚好使其接受: \\(1-x^* = \\delta \\hat{x}\\) (1) P2提议 \\(\\hat{x}\\)。P1接受条件: \\(1-\\hat{x} \\ge \\delta x^*\\) (P1在下一期自己提议能得到的折现值)。P2会给P1刚好使其接受: \\(1-\\hat{x} = \\delta x^*\\) (2) 联立 (1) (2): \\(\\hat{x} = 1-\\delta x^*\\) \\(1-x^* = \\delta (1-\\delta x^*) = \\delta - \\delta^2 x^*\\) \\(1-\\delta = x^*(1-\\delta^2) = x^*(1-\\delta)(1+\\delta)\\) \\(x^* = \\frac{1}{1+\\delta}\\) \\(\\hat{x} = 1 - \\frac{\\delta}{1+\\delta} = \\frac{1}{1+\\delta}\\) 所以，P1在P1提议自己拿 \\(\\frac{1}{1+\\delta}\\)，P2接受。P2会得到 \\(1-x^* = \\frac{\\delta}{1+\\delta}\\)。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#有限重复博弈",
    "href": "Lessons/byl.html#有限重复博弈",
    "title": "博弈论与机制设计",
    "section": "有限重复博弈",
    "text": "有限重复博弈\n如果阶段博弈有唯一的纳什均衡，那么有限次重复该博弈的唯一子博弈完美纳什均衡 (SPE) 是在每个阶段都进行该纳什均衡。\n\n例子 11 (有限重复囚徒困境). 阶段博弈 (H=合作/沉默, L=背叛/坦白，这里L是支配策略): \\[\\begin{array}{c|cc}\n     & \\text{H} & \\text{L} \\\\\n    \\hline\n    \\text{H} & 3,3 & -1,4 \\\\\n    \\text{L} & 4,-1 & 0,0 \\\\ % 笔记中此处为0,0，经典为1,1或类似值\n\\end{array}\\] 阶段博弈的唯一纳什均衡是 (L,L)。 如果重复2期： Period 2: 无论Period 1发生什么，Period 2本身是一个独立的博弈，唯一纳什均衡是 (L,L)。 Period 1: 参与人预料到Period 2的结果是 (L,L)，所以在Period 1也会选择 (L,L)。 结论：对于N期重复，唯一的SPE是每期都选择 (L,L)。\n\n\n例子 12 (有限重复协调博弈). 阶段博弈: \\[\\begin{array}{c|cc}\n     & \\text{A} & \\text{B} \\\\\n    \\hline\n    \\text{A} & 1,1 & 0,0 \\\\\n    \\text{B} & 0,0 & 2,2 \\\\\n\\end{array}\\] 阶段博弈有多个纳什均衡: (A,A), (B,B) 和一个混合策略均衡。 如果重复2期 : 可以构建这样的SPE： 策略1:\n\nPeriod 1: 选择B。\nPeriod 2: 如果Period 1是(B,B)，则选择(B,B)；否则（如出现(B,A)或(A,B)或(A,A)），则选择(A,A) (或者某个惩罚性的均衡)。\n\n如果双方都遵循这个策略，那么在Period 1选择B，得到(2,2)；Period 2继续(B,B)，得到(2,2)。总效用较高。 如果一方在Period 1偏离（比如从B到A，而对方选B），则Period 1得到(0,0)，Period 2会进入(A,A)得到(1,1)。 这种依赖历史的策略可以支持非阶段博弈纳什均衡的合作结果。 笔记中提到策略 :\n\nPeriod 2: 若Period 1是(A,A)或(A,B)或(B,A)，则Period 2选(A,A)。若Period 1是(B,B)，则Period 2选(B,B)。\n此时Period 1: 若选(B,B)，则总收益是 \\(2+2=4\\)。若选(A,A)，则总收益是 \\(1+1=2\\)。 因此，(B,B)在所有时期是一个SPE。同理，(A,A)在所有时期也是一个SPE。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#无限重复博弈",
    "href": "Lessons/byl.html#无限重复博弈",
    "title": "博弈论与机制设计",
    "section": "无限重复博弈",
    "text": "无限重复博弈\n当博弈无限期重复，或者参与人不知道博弈何时结束（以一定概率持续），逆向归纳法不再适用。 引入折扣因子 (Discount Factor) \\(\\delta \\in [0,1]\\)。\\(\\delta\\) 表示未来收益相对于当前收益的价值。如果每期收益为 \\(u_t\\)，则总贴现收益为 \\(\\sum_{t=0}^{\\infty} \\delta^t u_t\\)。\n\n例子 13 (无限重复囚徒困境). 阶段博弈同上，纳什均衡 (L,L) 支付 (0,0)。合作 (H,H) 支付 (3,3)。 冷酷触发策略 (Grim Trigger Strategy):\n\n在第一期选择 H (合作)。\n在之后的每一期：如果历史上所有时期双方都选择了 H，则继续选择 H。\n否则 (即一旦有任何一方选择了 L)，则永远选择 L (背叛)。\n\n分析该策略是否构成SPE (双方都采用此策略)：\n\n一直合作 (H): 收益 \\(= 3 + 3\\delta + 3\\delta^2 + \\dots = \\frac{3}{1-\\delta}\\)。\n在第一期背叛 (L) (假设对方合作): 收益 \\(= 4 + 0\\delta + 0\\delta^2 + \\dots = 4\\) (因为对方从第二期开始会永远选L)。\n在第 \\(k\\) 期背叛 (L) (假设对方合作到 \\(k-1\\) 期): 收益 \\(= 3 + 3\\delta + \\dots + 3\\delta^{k-1} + 4\\delta^k + 0\\delta^{k+1} + \\dots\\)\n\n为了使”一直合作”成为纳什均衡，需要满足不偏离的条件，即一直合作的收益 \\(\\ge\\) 任何时候偏离的收益。 最强的偏离动机在第一期： \\(\\frac{3}{1-\\delta} \\ge 4 \\implies 3 \\ge 4(1-\\delta) \\implies 3 \\ge 4 - 4\\delta \\implies 4\\delta \\ge 1 \\implies \\delta \\ge \\frac{1}{4}\\)。 如果折扣因子足够大 (\\(\\delta \\ge 1/4\\))，那么 (H,H) 可以作为无限重复博弈的一个SPE的结果。\n\n\nFolk Theorem (无名氏定理)\n无名氏定理（有多个版本）指出，在无限重复博弈中，如果参与人有足够的耐心 (即 \\(\\delta \\to 1\\))，那么任何满足以下两个条件的平均支付都可以作为SPE的结果：\n\n可行性 (Feasible): 该支付向量必须是阶段博弈所有可能纯策略结果（包括通过协调随机化设备达成的）的凸组合 (convex hull)。即在下图中的可行支付区域内。\n个体理性 (Individually Rational): 每个参与人的平均支付必须至少等于其在阶段博弈中的最小最大支付 (minmax payoff)。 最小最大支付 \\(\\underline{u}_i = \\min_{a_{-i}} \\max_{a_i} \\Pi^i(a_i, a_{-i})\\)。这是参与人 \\(i\\) 在最坏情况下（其他参与人试图最小化 \\(i\\) 的支付）能够保证自己得到的最低支付。\n\n图示 :\n\n可行支付集 (Feasible Payoffs): 由阶段博弈结果 (0,0), (-1,4), (4,-1), (3,3) 构成的凸包。\n个体理性支付集 (Individually Rational Payoffs): \\(u_i \\ge \\underline{u}_i\\)。在本例囚徒困境中，每个参与人的最小最大支付是0（当对方选择L时，自己选择L能得到0；若对方选择H，自己选择L能得到4，所以最差是0）。所以个体理性区域是 \\(u_1 \\ge 0, u_2 \\ge 0\\)。\n\nFolk定理表明，当 \\(\\delta\\) 足够接近1时，可行且个体理性的任何支付组合（例如 (3,3)）都可以通过某种SPE来实现。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#协调博弈中的转换成本",
    "href": "Lessons/byl.html#协调博弈中的转换成本",
    "title": "博弈论与机制设计",
    "section": "协调博弈中的转换成本",
    "text": "协调博弈中的转换成本\n阶段博弈: \\[\\begin{array}{c|cc}\n     & \\text{A} & \\text{B} \\\\\n    \\hline\n    \\text{A} & 0,0 & 0,0 \\\\\n    \\text{B} & 0,0 & 2,2 \\\\\n\\end{array}\\] (笔记中的例子是 (A,A)=(1,1), (A,B)=(0,0), (B,A)=(0,0), (B,B)=(2,2)，这里用的是讲义Page1的 (A,A)=(0,0)版本) 考虑最后几个时期。如果 \\(\\epsilon\\) 足够大，例如 \\(2\\Delta &gt; \\epsilon\\) (或者笔记中 \\(\\epsilon &gt; 2\\Delta\\)？应为转换的收益 \\(2\\Delta\\) 小于转换成本 \\(\\epsilon\\) 时不转换)。 笔记的逻辑 :\n\n当 \\(t_1 \\approx \\frac{\\epsilon}{2\\Delta}\\) (表示离结束还有 \\(t_1\\) 个时期，其中 \\(2\\Delta\\) 是选择B相对于A的每期额外收益)。 当剩余时期数 \\(k\\) 使得 \\(k \\cdot (b-a) &lt; \\epsilon\\) (其中 \\(b,a\\) 为选B,A的收益)，则不会从A转到B。\n笔记中分析: 当 \\(t\\Delta &gt; \\epsilon\\) 时，若选A则会变至B。 Unique SPE outcome 是 (B,B) 在所有时期。\n\n更一般的协调博弈形式 : \\[\\begin{array}{c|cc}\n     & \\text{A} & \\text{B} \\\\\n    \\hline\n    \\text{A} & a,a & d,c \\\\\n    \\text{B} & c,d & b,b \\\\\n\\end{array}\\] 假设 \\(b&gt;a&gt;c, b&gt;d\\)。 (B,B) 成为 unique SPE outcome 的条件是 \\(b-d &gt; a-c\\) (B风险占优A，risk dominate)。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#囚徒困境中的转换成本",
    "href": "Lessons/byl.html#囚徒困境中的转换成本",
    "title": "博弈论与机制设计",
    "section": "囚徒困境中的转换成本",
    "text": "囚徒困境中的转换成本\n阶段博弈 (C=合作, D=背叛): \\[\\begin{array}{c|cc}\n     & \\text{C} & \\text{D} \\\\\n    \\hline\n    \\text{C} & 3,3 & -1,4 \\\\\n    \\text{D} & 4,-1 & 1,1 \\\\ % 笔记中为1,1\n\\end{array}\\]\n\nIncentive to cheat (从C到D，当对方C): \\(4-3=1\\)。\nIncentive to punish (从C到D，当对方从C变为D，自己也从C变为D来惩罚或止损): \\(1-(-1)=2\\) (如果对方变D，我从C变D，收益从-1变1)。\n\n笔记分析 : 如果 \\(t_2 \\approx \\frac{\\epsilon}{\\Delta}\\) (转换收益1相较于成本\\(\\epsilon\\))，\\(t_1 \\approx \\frac{\\epsilon}{2\\Delta}\\)。 SPE #1: Play D all the period. SPE #2: 考虑(C,C)能否维持。 (C,D) \\(\\rightarrow\\) (D,D) (D,C) \\(\\rightarrow\\) (D,D) (D,D) \\(\\rightarrow\\) (D,D) (C,C) \\(\\rightarrow\\) (C,C) 如果转换成本足够影响决策，(C,C)也可能成为SPE。\n另一个囚徒困境例子 : \\[\\begin{array}{c|cc}\n     & \\text{C} & \\text{D} \\\\\n    \\hline\n    \\text{C} & 3,3 & 0,5 \\\\\n    \\text{D} & 5,0 & 1,1 \\\\\n\\end{array}\\]\n\nIncentive to cheat: \\(5-3=2\\).\nIncentive to punish: \\(1-0=1\\).\n\n这里，欺骗的诱惑 (2) 大于惩罚的收益 (1)。 \\(t_1: (C,C) \\rightarrow (D,C)\\) (如果一方单方面从C转D) \\(t_2: C \\rightarrow D\\) Unique SPE 是 (D,D)...(D,D)。\n一般形式 : \\[\\begin{array}{c|cc}\n     & \\text{C} & \\text{D} \\\\\n    \\hline\n    \\text{C} & a,a & d,c \\\\\n    \\text{D} & c,d & b,b \\\\\n\\end{array}\\] 假设 \\(c&gt;a&gt;b&gt;d\\) (经典囚徒困境)。 Incentive to cheat: \\(c-a\\). Incentive to punish (如果对方从C到D，自己从C到D，收益从d到b): \\(b-d\\).\n\nIf \\(c-a &gt; b-d\\): unique SPE is (D,D),...,(D,D).\nIf \\(c-a &lt; b-d\\): (C,C),...,(C,C) can be one of the SPEs.",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#无限期转换成本",
    "href": "Lessons/byl.html#无限期转换成本",
    "title": "博弈论与机制设计",
    "section": "无限期转换成本",
    "text": "无限期转换成本\n折扣因子 \\(\\delta = e^{-r\\Delta} \\approx 1-\\Delta\\) (当 \\(r=1\\), \\(\\Delta \\to 0\\))。 参与人 \\(i\\) 的总贴现效用: \\[U_i = \\sum_{t=0}^{\\infty} \\delta^t u_i(a^t) - \\sum_{t=0}^{\\infty} \\delta^t \\epsilon \\cdot I_i(a^{t+1} \\neq a^t)\\] 其中 \\(I_i(a^{t+1} \\neq a^t)\\) 是一个指示函数，当 \\(t+1\\) 期的行动与 \\(t\\) 期不同时为1，否则为0。 个体理性支付 (Rational Payoff) \\(\\underline{V_i}\\): 参与人 \\(i\\) 的纯策略最大最小支付 (pure-strategy maxmin)。这是在没有转换成本的情况下，参与人 \\(i\\) 能确保得到的最低支付。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#基本概念",
    "href": "Lessons/byl.html#基本概念",
    "title": "博弈论与机制设计",
    "section": "基本概念",
    "text": "基本概念\n\n不对称信息 (Asymmetric Information)\n在许多现实的经济互动中，参与者拥有的信息往往是不对称的。不完全信息博弈指的是至少有一方参与者不完全了解其他参与者某些特征（例如，支付函数、类型、策略空间等）的博弈。不对称信息是其中的一种情况，即不同的参与者拥有不同的私有信息 。\n一个经典的例子是保险市场中的逆向选择（adverse selection）问题 。例如，健康保险公司可能不了解每个客户的真实健康状况，而客户对此则有更充分的信息。高风险客户更倾向于购买保险，这可能导致保险公司面临亏损。\n\n\n贝叶斯均衡 (Bayesian Equilibrium)\n在不完全信息博弈中，我们需要一种新的均衡概念来描述参与者的理性行为。贝叶斯纳什均衡（Bayesian Nash Equilibrium, BNE）是纳什均衡在不完全信息博弈中的扩展。在贝叶斯纳什均衡中，每个参与者（根据其私有信息，即”类型”）选择一个最大化其期望效用的策略，同时考虑到其他参与者类型的概率分布以及其他参与者的策略。\n一个策略组合构成贝叶斯纳什均衡，如果没有任何一个类型的参与者可以通过单方面改变其策略来提高其期望效用，给定其他参与者的策略和关于其他参与者类型的信念。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#示例分析",
    "href": "Lessons/byl.html#示例分析",
    "title": "博弈论与机制设计",
    "section": "示例分析",
    "text": "示例分析\n\n例1：不确定博弈的选择\n考虑一个博弈，其中参与者1（Player 1）不知道正在进行的是博弈1（Game 1）还是博弈2（Game 2）。他只知道博弈1发生的概率为 \\(q\\)，博弈2发生的概率为 \\(1-q\\) 。参与者2（Player 2）则完全知晓当前进行的是哪个博弈 。\n博弈的支付矩阵如下（(P1收益, P2收益)）：\n\n\n\n\n博弈1 (Game 1) - 概率 \\(q\\)\n\n\n\n\n\n\nP1 \\(\\setminus\\) P2\nC\nD\n\n\nA\n(3,1)\n(0,0)\n\n\nB\n(0,1)\n(3,0)\n\n\n\n\n\n\n博弈2 (Game 2) - 概率 \\(1-q\\)\n\n\n\n\n\n\nP1 \\(\\setminus\\) P2\nC\nD\n\n\nA\n(3,1)\n(0,2)\n\n\nB\n(0,1)\n(3,2)\n\n\n\n\n假设参与者2的策略是：在博弈1中选择C，在博弈2中选择D 。 现在我们分析参与者1的最优策略。 如果参与者1选择行动A，他的期望收益为： \\[\\Pi_1(A) = q \\cdot (\\text{A在博弈1中对C的收益}) + (1-q) \\cdot (\\text{A在博弈2中对D的收益})\\] \\[\\Pi_1(A) = q \\cdot 3 + (1-q) \\cdot 0 = 3q \\quad \\text{}\\] 如果参与者1选择行动B，他的期望收益为： \\[\\Pi_1(B) = q \\cdot (\\text{B在博弈1中对C的收益}) + (1-q) \\cdot (\\text{B在博弈2中对D的收益})\\] \\[\\Pi_1(B) = q \\cdot 0 + (1-q) \\cdot 3 = 3 - 3q \\quad \\text{}\\]\n参与者1会选择使其期望收益最大化的行动：\n\n如果 \\(\\Pi_1(A) \\ge \\Pi_1(B)\\)，即 \\(3q \\ge 3-3q \\implies 6q \\ge 3 \\implies q \\ge \\frac{1}{2}\\)，则参与者1选择A (\\(a_1=A\\)) 。\n如果 \\(\\Pi_1(A) \\le \\Pi_1(B)\\)，即 \\(3q \\le 3-3q \\implies 6q \\le 3 \\implies q \\le \\frac{1}{2}\\)，则参与者1选择B (\\(a_1=B\\)) 。\n\n当参与者1根据这个规则选择其行动，而参与者2的策略（在博弈1中选C，在博弈2中选D）是对参与者1（可能的）行动的最佳回应时（需要验证这一点），我们就可能找到了一个贝叶斯均衡 。\n参与者2的策略 \\(a_2(\\text{type})\\) 是一种依赖于其类型（即他所知道的博弈是Game 1还是Game 2）的策略，称为类型条件策略 (type contingent strategy) 。 具体来说，参与者2的类型 contingent strategy 是：\n\n如果是博弈1 (\\(t_2=1\\))，选择 \\(a_2(1)=C\\) 。\n如果是博弈2 (\\(t_2=2\\))，选择 \\(a_2(2)=D\\) 。\n\n一个贝叶斯均衡要求每个参与者的类型条件策略都是对其他参与者策略的最佳回应 。\n\n\n例2：不同博弈的纯策略均衡\n考虑另一组博弈支付矩阵 ：\n\n\n\n\n博弈1 (Game 1) - 概率 \\(q\\)\n\n\n\n\n\n\nP1 \\(\\setminus\\) P2\nC\nD\n\n\nA\n(3,1)\n(0,0)\n\n\nB\n(0,0)\n(3,1)\n\n\n\n\n\n\n博弈2 (Game 2) - 概率 \\(1-q\\)\n\n\n\n\n\n\nP1 \\(\\setminus\\) P2\nC\nD\n\n\nA\n(3,1)\n(0,2)\n\n\nB\n(0,2)\n(3,1)\n\n\n\n\n假设与前例相同，参与者1不知道是哪个博弈，参与者2知道 。\n我们来寻找纯策略贝叶斯均衡：\n\n假设参与者1选择 \\(a_1=A\\) 。 那么参与者2在博弈1中的最佳回应是选择C（收益1 vs 0），即 \\(a_2(1)=C\\) 。 参与者2在博弈2中的最佳回应是选择D（收益2 vs 1），即 \\(a_2(2)=D\\) 。 给定参与者2的策略 \\((a_2(1)=C, a_2(2)=D)\\)，参与者1选择A的前提是 \\(\\Pi_1(A) \\ge \\Pi_1(B)\\)： \\(\\Pi_1(A | (C,D)) = q \\cdot 3 + (1-q) \\cdot 0 = 3q\\) \\(\\Pi_1(B | (C,D)) = q \\cdot 0 + (1-q) \\cdot 3 = 3(1-q)\\) 所以，\\(3q \\ge 3(1-q) \\implies 3q \\ge 3-3q \\implies 6q \\ge 3 \\implies q \\ge \\frac{1}{2}\\) 。 因此，如果 \\(q \\ge \\frac{1}{2}\\)，则 \\((a_1=A; a_2(1)=C, a_2(2)=D)\\) 是一个纯策略贝叶斯均衡。\n假设参与者1选择 \\(a_1=B\\) 。 那么参与者2在博弈1中的最佳回应是选择D（收益1 vs 0），即 \\(a_2(1)=D\\) 。 参与者2在博弈2中的最佳回应是选择C（收益2 vs 1），即 \\(a_2(2)=C\\) 。 给定参与者2的策略 \\((a_2(1)=D, a_2(2)=C)\\)，参与者1选择B的前提是 \\(\\Pi_1(B) \\ge \\Pi_1(A)\\)： \\(\\Pi_1(B | (D,C)) = q \\cdot 3 + (1-q) \\cdot 0 = 3q\\) \\(\\Pi_1(A | (D,C)) = q \\cdot 0 + (1-q) \\cdot 3 = 3(1-q)\\) 所以，\\(3q \\ge 3(1-q) \\implies q \\ge \\frac{1}{2}\\) 。 因此，如果 \\(q \\ge \\frac{1}{2}\\)，则 \\((a_1=B; a_2(1)=D, a_2(2)=C)\\) 是另一个纯策略贝叶斯均衡。\n\n笔记中提到，当 \\(q &lt; \\frac{1}{2}\\) 时没有纯策略均衡 。这是因为在上述分析中，如果 \\(q &lt; \\frac{1}{2}\\)，则参与者1会偏离假设的策略。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#拍卖类型简介",
    "href": "Lessons/byl.html#拍卖类型简介",
    "title": "博弈论与机制设计",
    "section": "拍卖类型简介",
    "text": "拍卖类型简介\n有多种不同规则的拍卖形式，常见的有：\n\n英式拍卖 (English Auction): 也称为公开增价拍卖（open bid auctions）。价格从低到高逐渐上升，竞标者不断出更高的价格，直到没有人愿意出更高价格为止，最后出价最高者以其出价赢得拍卖品 。\n荷兰式拍卖 (Dutch Auction): 价格从高到低逐渐下降，第一个表示接受当前价格的竞标者赢得拍卖品并支付该价格 。\n第一价格密封投标拍卖 (First-Price Sealed-Bid Auction): 每个竞标者独立地、秘密地提交一个报价（bid），报价最高者赢得拍卖品，并支付其自己报出的价格 。\n第二价格密封投标拍卖 (Second-Price Sealed-Bid Auction): 也称为维克里拍卖（Vickrey Auction）。每个竞标者独立地、秘密地提交一个报价，报价最高者赢得拍卖品，但仅需支付所有报价中第二高的价格 。\n全支付拍卖 (All-Pay Auction): 所有竞标者都支付他们报出的价格，无论他们是否赢得拍卖品。出价最高者获得拍卖品 。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#第二价格密封投标拍卖-second-price-sealed-bid-auction",
    "href": "Lessons/byl.html#第二价格密封投标拍卖-second-price-sealed-bid-auction",
    "title": "博弈论与机制设计",
    "section": "第二价格密封投标拍卖 (Second-Price Sealed-Bid Auction)",
    "text": "第二价格密封投标拍卖 (Second-Price Sealed-Bid Auction)\n这是一种重要的拍卖形式，因为它具有一些优良的性质。\n假设有两个竞标者参与拍卖。每个竞标者 \\(i\\) 对拍卖品有一个私有价值（private value）\\(v_i\\)，即该物品对其的真实价值 。竞标者 \\(i\\) 对自己的 \\(v_i\\) 清楚，但不知道其他竞标者的私有价值。我们假设 \\(v_i\\) 是从某个概率分布中抽取的。竞标者 \\(i\\) 提交的报价为 \\(b_i\\) 。\n\n弱占优策略：\\(b_i = v_i\\)\n在第二价格密封投标拍卖中，对于每个竞标者 \\(i\\) 来说，诚实报价（即报价 \\(b_i\\) 等于其私有价值 \\(v_i\\)）是一个弱占优策略 (weakly dominant strategy) 。这意味着，无论其他竞标者如何报价，竞标者 \\(i\\) 选择 \\(b_i=v_i\\) 所带来的收益至少不比选择任何其他报价 \\(b_i \\neq v_i\\) 差，并且在某些情况下会更好。\n证明思路 (以竞标者1为例，其价值为 \\(v_1\\)，报价为 \\(b_1\\)，另一竞标者的最高报价为 \\(b_{max_2}\\)) ： 我们需要比较 \\(b_1=v_1\\) 和 \\(b_1 \\neq v_1\\) 的情况。设 \\(b_2\\) 为竞标者2的报价（如果是多个其他竞标者，则 \\(b_2\\) 代表其他竞标者中的最高报价）。竞标者1的盈余（surplus）是 \\(v_1 - \\text{支付价格}\\)（如果赢得拍卖）或0（如果未赢得）。\n\n情况1: \\(b_1 &gt; v_1\\) (过高报价)\n\n若 \\(b_2 \\ge b_1\\)：竞标者1未赢得。如果他报 \\(v_1\\) 且 \\(b_2 \\ge v_1\\)，结果相同。如果他报 \\(v_1\\) 且 \\(b_1 &gt; b_2 \\ge v_1\\)，报 \\(v_1\\) 也未赢得（或赢得并支付 \\(b_2\\)，但 \\(v_1-b_2 \\le 0\\)）。\n若 \\(v_1 &lt; b_2 &lt; b_1\\)：竞标者1赢得并支付 \\(b_2\\)。盈余为 \\(v_1 - b_2 &lt; 0\\)。如果他报 \\(v_1\\)，他将不会赢得（因为 \\(b_2 &gt; v_1\\)），盈余为0。这种情况下，报 \\(b_1 &gt; v_1\\) 更差 。\n若 \\(b_2 \\le v_1\\) (且 \\(b_2 &lt; b_1\\)): 竞标者1赢得并支付 \\(b_2\\)。盈余为 \\(v_1 - b_2 \\ge 0\\)。如果他报 \\(v_1\\)，他也会赢得并支付 \\(b_2\\)（因为 \\(v_1 \\ge b_2\\)），盈余相同。\n\n情况2: \\(b_1 &lt; v_1\\) (过低报价)\n\n若 \\(b_2 \\le b_1\\)：竞标者1赢得并支付 \\(b_2\\)。盈余为 \\(v_1 - b_2 &gt; 0\\)。如果他报 \\(v_1\\)，他也会赢得并支付 \\(b_2\\)（因为 \\(v_1 &gt; b_1 \\ge b_2\\)），盈余相同。\n若 \\(b_1 &lt; b_2 &lt; v_1\\)：竞标者1未赢得，盈余为0。如果他报 \\(v_1\\)，他将会赢得并支付 \\(b_2\\)。盈余为 \\(v_1 - b_2 &gt; 0\\)。这种情况下，报 \\(b_1 &lt; v_1\\) 更差 。\n若 \\(b_2 \\ge v_1\\) (且 \\(b_2 &gt; b_1\\)): 竞标者1未赢得。如果他报 \\(v_1\\)，他也不会赢得（因为 \\(b_2 \\ge v_1\\)），盈余相同。\n\n\n总结来说，与诚实报价 \\(b_1=v_1\\) 相比：\n\n报 \\(b_1 &gt; v_1\\)：在某些情况下（当 \\(v_1 &lt; b_2 &lt; b_1\\) 时），会导致负盈余，而诚实报价会得到0盈余。在其他情况下，结果与诚实报价相同或不劣于诚实报价。\n报 \\(b_1 &lt; v_1\\)：在某些情况下（当 \\(b_1 &lt; b_2 &lt; v_1\\) 时），会错失获得正盈余的机会，而诚实报价可以获得正盈余。在其他情况下，结果与诚实报价相同或不劣于诚实报价。\n\n因此，\\(b_i=v_i\\) 是一个弱占优策略。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#推广至n个竞标者",
    "href": "Lessons/byl.html#推广至n个竞标者",
    "title": "博弈论与机制设计",
    "section": "推广至N个竞标者",
    "text": "推广至N个竞标者\n上述结论可以推广到N个竞标者的情况。对于任何竞标者 \\(i\\)，将其余 \\(N-1\\) 个竞标者中的最高报价视为 \\(b_{max_{-i}}\\) (相当于前述证明中的 \\(b_2\\))，同样的逻辑仍然适用。因此，\\(b_i=v_i\\) 仍然是弱占优策略 。\n\n贝叶斯均衡\n在第二价格拍卖中，由于诚实报价 \\(b_i=v_i\\) 是每个参与者的弱占优策略，因此 \\((b_1=v_1, b_2=v_2, \\dots, b_N=v_N)\\) 构成一个贝叶斯纳什均衡 。这是一种类型条件策略，其中每个竞标者的报价直接反映其私有价值。\n\n\n示例\n假设有两个竞标者，其私有价值分别为 \\(v_1=10, v_2=12\\) 。 根据贝叶斯均衡策略： \\(b_1 = v_1 = 10\\) \\(b_2 = v_2 = 12\\) 竞标者2的报价最高 (\\(b_2=12\\))，因此他赢得拍卖品。他需要支付的价格是第二高的报价，即 \\(b_1=10\\)。竞标者2的盈余是 \\(v_2 - b_1 = 12 - 10 = 2\\)。竞标者1的盈余是0。 如果 \\(b_1=10, b_2 &gt; 10\\)（例如 \\(b_2=12\\)），竞标者2赢得并支付 $10 。 如果 \\(b_1&lt;10\\)（例如 \\(b_1=8\\)）且 \\(b_2 \\ge 10\\)（例如 \\(b_2=12\\)），竞标者2赢得并支付 \\(b_1=8\\) 。 (注：笔记原文中 \\(b_1&lt;1, b_2 \\ge 1\\), bidder 2 pays \\(b_1\\)。这部分应为如果 \\(b_2\\) 是最高价，他支付第二高价。如果 \\(b_1\\) 是第二高价且 \\(b_1 &lt; b_2\\)，他支付 \\(b_1\\)。) 更精确地说，如果 \\(b_i\\) 是最高出价， \\(b_j\\) 是严格次高出价，则 \\(i\\) 获胜并支付 \\(b_j\\)。如果多个出价者出相同的最高价，通常有某种打破僵局的规则。\n\n\n与英式拍卖的等价性\n对于卖方而言，英式拍卖和第二价格密封投标拍卖在一定条件下（例如，私有价值模型）通常能产生相同的期望收益 。在英式拍卖中，竞标者会持续出价直到价格略高于其第二高竞争对手愿意支付的价格（或者说，直到价格达到其自身价值，而倒数第二个退出的竞标者其价值决定了最终价格）。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#第一价格密封投标拍卖-first-price-sealed-bid-auction",
    "href": "Lessons/byl.html#第一价格密封投标拍卖-first-price-sealed-bid-auction",
    "title": "博弈论与机制设计",
    "section": "第一价格密封投标拍卖 (First-Price Sealed-Bid Auction)",
    "text": "第一价格密封投标拍卖 (First-Price Sealed-Bid Auction)\n在这种拍卖中，出价最高的竞标者赢得拍卖品，并支付其自己报出的价格。与第二价格拍卖不同，这里不存在诚实报价的占优策略。竞标者面临一个权衡：出价越高，赢得拍卖的概率越大，但一旦赢得，利润（价值 - 价格）就越小。\n\n模型设定 (双人，价值服从[0,1]均匀分布)\n假设有两个竞标者（\\(i=1,2\\)）。每个竞标者的私有价值 \\(v_i\\) 是独立同分布 (IID) 的，服从区间 \\([0,1]\\) 上的均匀分布 (\\(v_i \\sim U[0,1]\\)) 。每个竞标者只知道自己的 \\(v_i\\)。 我们寻找对称的贝叶斯纳什均衡，其中每个竞标者都使用相同的报价函数（bidding function）\\(b_i = B(v_i)\\)，该函数将其私有价值 \\(v_i\\) 映射到一个报价 \\(b_i\\) 。我们通常假设 \\(B(v)\\) 是一个严格递增函数 (\\(B'(v)&gt;0\\)) 。\n对于竞标者1，他假设竞标者2使用报价函数 \\(B(v_2)\\)。竞标者1选择其报价 \\(b_1\\) 以最大化其期望盈余 \\(\\Pi_1(b_1, v_1)\\)： \\[\\Pi_1(b_1, v_1) = P(\\text{竞标者1赢得拍卖}) \\cdot (v_1 - b_1)\\] 竞标者1赢得拍卖的条件是 \\(b_1 &gt; B(v_2)\\)。由于 \\(B(\\cdot)\\) 单调递增，这等价于 \\(B^{-1}(b_1) &gt; v_2\\) 。 因为 \\(v_2 \\sim U[0,1]\\)，\\(P(v_2 &lt; B^{-1}(b_1)) = B^{-1}(b_1)\\) （假设 \\(B^{-1}(b_1)\\) 仍在 \\([0,1]\\) 区间内）。 所以，期望盈余为： \\[\\Pi_1(b_1, v_1) = B^{-1}(b_1) \\cdot (v_1 - b_1) \\quad \\text{}\\] 竞标者1选择 \\(b_1\\) 来最大化上式。为了找到最优的 \\(b_1\\)，我们对 \\(b_1\\) 求导并令其等于0。 根据反函数求导法则，\\(\\frac{d B^{-1}(y)}{dy} = \\frac{1}{B'(B^{-1}(y))}\\) 。 \\[\\frac{\\partial \\Pi_1}{\\partial b_1} = \\frac{d B^{-1}(b_1)}{d b_1} (v_1 - b_1) + B^{-1}(b_1) (-1) = 0\\] \\[\\frac{1}{B'(B^{-1}(b_1))} (v_1 - b_1) - B^{-1}(b_1) = 0 \\quad \\text{}\\] 在对称均衡中，\\(b_1 = B(v_1)\\)，所以 \\(B^{-1}(b_1) = v_1\\)。将此代入上式： \\[\\frac{1}{B'(v_1)} (v_1 - B(v_1)) - v_1 = 0 \\quad \\text{}\\] \\[v_1 - B(v_1) - v_1 B'(v_1) = 0\\] \\[v_1 B'(v_1) + B(v_1) = v_1 \\quad \\text{}\\] 这是一个一阶线性常微分方程 (ODE)。注意到左边是 \\((v_1 B(v_1))'\\) 的展开式： \\[(v_1 B(v_1))' = v_1 \\quad \\text{}\\] 两边对 \\(v_1\\) 积分： \\[v_1 B(v_1) = \\int v_1 dv_1 = \\frac{1}{2} v_1^2 + C \\quad \\text{}\\] 其中 \\(C\\) 是积分常数。 为了确定 \\(C\\)，我们考虑边界条件。如果一个竞标者的价值为0 (\\(v_1=0\\))，他最优的出价应该是0 (\\(B(0)=0\\))。代入上式： \\(0 \\cdot B(0) = \\frac{1}{2} \\cdot 0^2 + C \\implies C = 0\\) 。 所以，均衡报价函数为： \\[B(v_1) = \\frac{1}{2} v_1 \\quad \\text{}\\] 这意味着，在有两个竞标者且其价值服从 \\([0,1]\\) 均匀分布的第一价格拍卖中，均衡策略是报出自己价值的一半。\n\n\n模型设定 (N人，一般分布)\n现在考虑有 \\(N\\) 个竞标者。每个竞标者的私有价值 \\(v_i\\) 独立同分布于区间 \\([\\underline{v}, \\overline{v}]\\)，其累积分布函数 (CDF) 为 \\(F(v_i)\\)，概率密度函数 (PDF) 为 \\(f(v_i)\\) 。 我们仍然寻找对称的贝叶斯纳什均衡报价函数 \\(b_i = B(v_i)\\)，并假设 \\(B'(v)&gt;0\\) 。\n假设竞标者1认为其他 \\(N-1\\) 个竞标者都使用报价函数 \\(B(\\cdot)\\)。竞标者1选择自己的报价 \\(b_1\\)（或者等价地，选择一个”伪装”的价值 \\(\\tilde{v}_1\\) 使得 \\(b_1 = B(\\tilde{v}_1)\\)）来最大化其期望效用。 竞标者1的期望效用 \\(\\Pi_1(b_1, v_1)\\) 或 \\(\\tilde{\\Pi}_1(\\tilde{v}_1, v_1)\\) (用 \\(\\tilde{v}_1\\) 表示其选择的报价水平对应的价值) 为： \\[\\tilde{\\Pi}_1(\\tilde{v}_1, v_1) = P(\\text{竞标者1以 } B(\\tilde{v}_1) \\text{ 获胜}) \\cdot (v_1 - B(\\tilde{v}_1)) \\quad \\text{}\\] 竞标者1获胜的条件是他的报价 \\(B(\\tilde{v}_1)\\) 高于其他所有 \\(N-1\\) 个人的报价。即 \\(B(\\tilde{v}_1) &gt; B(v_j)\\) 对所有 \\(j \\neq 1\\)。由于 \\(B(\\cdot)\\) 单调递增，这等价于 \\(\\tilde{v}_1 &gt; v_j\\) 对所有 \\(j \\neq 1\\)。 其他 \\(N-1\\) 个竞标者的价值都小于 \\(\\tilde{v}_1\\) 的概率为 \\((F(\\tilde{v}_1))^{N-1}\\)。 所以， \\[\\tilde{\\Pi}_1(\\tilde{v}_1, v_1) = (F(\\tilde{v}_1))^{N-1} (v_1 - B(\\tilde{v}_1)) \\quad \\text{}\\] 为了使 \\(\\tilde{v}_1 = v_1\\) 是最优选择（即诚实地使用自己的价值通过 \\(B(\\cdot)\\) 函数来报价），我们需要最大化 \\(\\tilde{\\Pi}_1(\\tilde{v}_1, v_1)\\) 关于 \\(\\tilde{v}_1\\)，然后代入 \\(\\tilde{v}_1=v_1\\)。 一阶条件 \\(\\frac{\\partial \\tilde{\\Pi}_1(\\tilde{v}_1, v_1)}{\\partial \\tilde{v}_1} = 0\\) 在 \\(\\tilde{v}_1 = v_1\\) 时成立 ： \\[\\frac{\\partial \\tilde{\\Pi}_1}{\\partial \\tilde{v}_1} = \\frac{d(F(\\tilde{v}_1))^{N-1}}{d\\tilde{v}_1} (v_1 - B(\\tilde{v}_1)) + (F(\\tilde{v}_1))^{N-1} (-B'(\\tilde{v}_1))\\] 在 \\(\\tilde{v}_1=v_1\\) 时： \\[((F(v_1))^{N-1})' (v_1 - B(v_1)) - (F(v_1))^{N-1} B'(v_1) = 0 \\quad \\text{}\\] 这是一个关于 \\(B(v_1)\\) 的微分方程。 \\(((F(v_1))^{N-1})' = (N-1)(F(v_1))^{N-2}f(v_1)\\)。 所以， \\((N-1)(F(v_1))^{N-2}f(v_1) (v_1 - B(v_1)) - (F(v_1))^{N-1} B'(v_1) = 0\\)。\n可以证明（通过求解这个微分方程，通常设定一个边界条件如 \\(B(\\underline{v})=\\underline{v}\\)，如果 \\(\\underline{v}\\) 是可能的最低价值且在此价值下不会有交易发生，或者更一般地，具有价值 \\(\\underline{v}\\) 的竞标者期望收益为0），均衡报价函数为： \\[B(v) = v - \\frac{\\int_{\\underline{v}}^{v} (F(t))^{N-1} dt}{(F(v))^{N-1}} \\quad \\text{}\\] 其中 \\(t\\) 是积分哑变量。 这个表达式也等于 \\(B(v) = \\mathbb{E}[Y_1 | Y_1 &lt; v]\\), 其中 \\(Y_1\\) 是其他 \\(N-1\\) 个竞标者价值中的最高值。\n我们可以验证 \\(B'(v) &gt; 0\\)。对上述 \\(B(v)\\) 求导 ： \\[(F(v))^{N-1} (v - B(v)) = \\int_{\\underline{v}}^{v} (F(t))^{N-1} dt\\] 两边对 \\(v\\) 求导： \\[\\frac{d(F(v))^{N-1}}{dv} (v - B(v)) + (F(v))^{N-1} (1 - B'(v)) = (F(v))^{N-1} \\quad \\text{}\\] \\[(N-1)(F(v))^{N-2}f(v)(v-B(v)) + (F(v))^{N-1}(1-B'(v)) = (F(v))^{N-1}\\] \\[(N-1)(F(v))^{N-2}f(v)(v-B(v)) - (F(v))^{N-1}B'(v) = 0\\] 这与我们之前设定的一阶条件一致。从 \\(B(v)\\) 的表达式可以推导出 \\(B'(v)\\) 通常为正。\n\n\n另一种推导方法 (基于包络定理)\n竞标者1的优化问题是选择 \\(\\tilde{v}_1\\) 来最大化 \\(\\tilde{\\Pi}_1(\\tilde{v}_1, v_1) = (F(\\tilde{v}_1))^{N-1} (v_1 - B(\\tilde{v}_1))\\)。 在均衡中，竞标者会选择 \\(\\tilde{v}_1 = v_1\\)。令 \\(\\Pi_1^*(v_1) = \\tilde{\\Pi}_1(v_1, v_1)\\) 为竞标者1在均衡中的最优期望效用。 根据包络定理 (Envelope Theorem)： \\[\\frac{d \\Pi_1^*(v_1)}{d v_1} = \\left. \\frac{\\partial \\tilde{\\Pi}_1(\\tilde{v}_1, v_1)}{\\partial v_1} \\right|_{\\tilde{v}_1=v_1} \\quad \\text{}\\] \\[\\frac{\\partial \\tilde{\\Pi}_1(\\tilde{v}_1, v_1)}{\\partial v_1} = (F(\\tilde{v}_1))^{N-1}\\] 所以， \\[\\frac{d \\Pi_1^*(v_1)}{d v_1} = (F(v_1))^{N-1} \\quad \\text{}\\] 两边从 \\(\\underline{v}\\) 到 \\(v\\) 积分： \\[\\Pi_1^*(v) - \\Pi_1^*(\\underline{v}) = \\int_{\\underline{v}}^{v} (F(t))^{N-1} dt \\quad \\text{}\\] 通常，拥有最低可能价值 \\(\\underline{v}\\) 的竞标者的期望效用为0，即 \\(\\Pi_1^*(\\underline{v})=0\\)（因为他们几乎不可能获胜，或者即使获胜，出价接近其价值，利润也为0）。 那么，\\(\\Pi_1^*(v) = \\int_{\\underline{v}}^{v} (F(t))^{N-1} dt\\)。 又因为 \\(\\Pi_1^*(v) = (F(v))^{N-1} (v - B(v))\\)，所以 \\[(F(v))^{N-1} (v - B(v)) = \\int_{\\underline{v}}^{v} (F(t))^{N-1} dt\\] \\[B(v) = v - \\frac{\\int_{\\underline{v}}^{v} (F(t))^{N-1} dt}{(F(v))^{N-1}}\\] 这与之前得到的结果一致。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#第一价格拍卖中的保留价格",
    "href": "Lessons/byl.html#第一价格拍卖中的保留价格",
    "title": "博弈论与机制设计",
    "section": "第一价格拍卖中的保留价格",
    "text": "第一价格拍卖中的保留价格\n在存在保留价格 \\(r\\) 的情况下，竞标者的行为会受到影响。我们假设 \\(\\underline{v} \\le r \\le \\overline{v}\\)。 如果竞标者的价值 \\(v_i &lt; r\\)，他通常不会出价高于 \\(r\\)，因为即使赢了也会亏损。一个关键的边界（或初始）条件是，对于一个价值恰好为 \\(r\\) 的竞标者，他的最优出价是 \\(r\\)，即 \\(B(r)=r\\) 。这意味着如果他的价值是 \\(r\\)，他愿意支付 \\(r\\)，并且期望利润为0。\n基于 \\(B(r)=r\\) 这个条件，我们可以修改上一节中 \\(B(v)\\) 的推导。 \\[(F(v))^{N-1} (v - B(v)) - (F(r))^{N-1} (r - B(r)) = \\int_{r}^{v} (F(t))^{N-1} dt \\quad \\text{}\\] 由于 \\(B(r)=r\\)，第二项为0。所以， \\[(F(v))^{N-1} (v - B(v)) = \\int_{r}^{v} (F(t))^{N-1} dt\\] \\[B(v) = v - \\frac{\\int_{r}^{v} (F(t))^{N-1} dt}{(F(v))^{N-1}} \\quad \\text{ for } v \\ge r \\quad \\text{}\\] 如果 \\(v &lt; r\\)，竞标者通常会出价低于 \\(r\\) (或者不出价，或者出价 \\(r\\) 但知道不会以低于 \\(r\\) 的价格成交)。 从这个公式可以看出，如果保留价格 \\(r\\) 提高，那么对于任意 \\(v &gt; r\\)，积分项 \\(\\int_{r}^{v} (F(t))^{N-1} dt\\) 会减小，从而导致 \\(B(v)\\) 增大 。即保留价格提高会使得合格的竞标者出价更高。\n\n卖方期望收益与最优保留价格\n卖方的期望收益 \\(R^1(r)\\) 是所有竞标者价值都低于 \\(r\\) 时收益为0（或为卖方自己的保留效用），以及至少有一个竞标者价值高于 \\(r\\) 时，最高价值者支付其报价 \\(B(v_{(N)})\\) 的期望值。 令 \\(v_{(N)}\\) 为 \\(N\\) 个竞标者中的最高价值。其PDF为 \\(g_{(N)}(v) = N (F(v))^{N-1} f(v)\\)。 卖方的期望收益为： \\[R^1(r) = \\int_{r}^{\\overline{v}} B(v) N (F(v))^{N-1} f(v) dv \\quad \\text{}\\] 代入 \\(B(v) = v - \\frac{\\int_{r}^{v} (F(t))^{N-1} dt}{(F(v))^{N-1}}\\)： \\[R^1(r) = \\int_{r}^{\\overline{v}} \\left( v - \\frac{\\int_{r}^{v} (F(t))^{N-1} dt}{(F(v))^{N-1}} \\right) N (F(v))^{N-1} f(v) dv\\] \\[R^1(r) = \\int_{r}^{\\overline{v}} v N (F(v))^{N-1} f(v) dv - \\int_{r}^{\\overline{v}} \\left( \\int_{r}^{v} (F(t))^{N-1} dt \\right) N f(v) dv \\quad \\text{}\\] 通过对第二项进行分部积分或改变积分次序（Fubini定理），可以得到（如思考过程所示）： \\[\\int_{r}^{\\overline{v}} \\left( \\int_{r}^{v} (F(t))^{N-1} dt \\right) N f(v) dv = \\int_{r}^{\\overline{v}} N (1-F(t)) (F(t))^{N-1} dt \\quad \\text{}\\] 所以， \\[R^1(r) = \\int_{r}^{\\overline{v}} v N (F(v))^{N-1} f(v) dv - \\int_{r}^{\\overline{v}} N (1-F(v)) (F(v))^{N-1} dv\\] 对 \\(R^1(r)\\) 关于 \\(r\\) 求导并令其等于0，可以找到最优保留价格 \\(r^*\\)。 \\[\\frac{dR^1(r)}{dr} = -r N (F(r))^{N-1} f(r) + N (1-F(r)) (F(r))^{N-1} \\quad \\text{(Leibniz rule and fundamental theorem of calculus)}\\] 令 \\(\\frac{dR^1(r)}{dr} = 0\\)： \\[-r N (F(r))^{N-1} f(r) + N (1-F(r)) (F(r))^{N-1} = 0\\] 假设 \\((F(r))^{N-1} &gt; 0\\) (即 \\(r &lt; \\overline{v}\\) and \\(F(r)&gt;0\\) for \\(N&gt;1\\)), \\[-r f(r) + (1-F(r)) = 0\\] \\[r - \\frac{1-F(r)}{f(r)} = 0 \\quad \\text{}\\] 这就是确定最优保留价格 \\(r^*\\) 的条件，通常被称为Myerson’s optimal reserve price condition（对于满足某些正则性条件的分布）。这里的 \\(J(v) = v - \\frac{1-F(v)}{f(v)}\\) 是所谓的”虚拟价值”(virtual valuation)。最优保留价格使得最低被接受的竞标者的虚拟价值为0。\n如果卖方对物品自身有一个保留效用 \\(v_0\\)（即如果物品未售出，卖方获得 \\(v_0\\) 的效用），那么最优保留价格 \\(r^*\\) 应该满足： \\[r^* - \\frac{1-F(r^*)}{f(r^*)} = v_0 \\quad \\text{}\\] 并且，实际设定的保留价格应该是 \\(\\max(r^*, v_0)\\)。\n示例：垄断者问题 当 \\(N=1\\) 时（只有一个竞标者，相当于垄断卖方直接向一个买方报价），\\(F(v)=v\\)（即 \\(v \\sim U[0,1]\\)），\\(f(v)=1\\)。 保留价格 \\(r\\) 就是卖方设定的价格。买方只有当其价值 \\(v \\ge r\\) 时才会购买。 卖方收益 \\(R(r) = P(v \\ge r) \\cdot r = (1-F(r)) \\cdot r = (1-r)r\\) 。 \\(\\frac{dR}{dr} = 1-2r = 0 \\implies r = \\frac{1}{2}\\) 。 使用公式 \\(r - \\frac{1-F(r)}{f(r)} = 0 \\implies r - \\frac{1-r}{1} = 0 \\implies r - (1-r) = 0 \\implies 2r-1=0 \\implies r=\\frac{1}{2}\\)。结果一致。 这与标准垄断定价问题中，如果需求函数为 \\(Q(p) = 1-F(p)\\)，边际成本为 \\(c\\)，则利润 \\(\\Pi = p Q(p) - c Q(p)\\)。一阶条件 \\(\\frac{d\\Pi}{dp}=0\\) 给出 \\(Q(p) + (p-c)Q'(p)=0 \\implies Q(p) + (p-c)(-f(p))=0 \\implies p-c = \\frac{Q(p)}{f(p)} = \\frac{1-F(p)}{f(p)}\\)。如果 \\(c=0\\)，则 \\(p = \\frac{1-F(p)}{f(p)}\\)，即 \\(p - \\frac{1-F(p)}{f(p)} = 0\\) 。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#第二价格拍卖中的保留价格",
    "href": "Lessons/byl.html#第二价格拍卖中的保留价格",
    "title": "博弈论与机制设计",
    "section": "第二价格拍卖中的保留价格",
    "text": "第二价格拍卖中的保留价格\n在第二价格拍卖中引入保留价格 \\(r\\)。规则是：最高出价者 \\(b_{(N)}\\) 获胜，当且仅当 \\(b_{(N)} \\ge r\\)。如果获胜，支付价格为 \\(\\max(r, b_{(N-1)})\\)，其中 \\(b_{(N-1)}\\) 是第二高出价。如果所有出价都低于 \\(r\\)，则物品不售出。由于诚实报价 \\(b_i=v_i\\) 仍然是（截断的）占优策略（即如果 \\(v_i &lt; r\\) 则不报或报一个不会赢的价格，如果 \\(v_i \\ge r\\) 则报 \\(v_i\\)），所以分析较为直接。\n卖方的期望收益 \\(R^2(r)\\) 由两部分构成：\n\n最高价值 \\(v_{(N)} \\ge r\\) 且次高价值 \\(v_{(N-1)} \\ge r\\)：卖方收到 \\(v_{(N-1)}\\)。\n最高价值 \\(v_{(N)} \\ge r\\) 且次高价值 \\(v_{(N-1)} &lt; r\\)（或者只有一个竞标者价值 \\(\\ge r\\)）：卖方收到 \\(r\\)。\n\n令 \\(f_k(v)\\) 为第 \\(k\\) 高阶统计量的概率密度函数。\\(f_2(v)\\) （笔记中用 \\(f_2(v)\\) 表示次高价值的PDF，更准确的写法是 \\(g_{(N-1)}(v)\\)）为： \\[g_{(N-1)}(v) = N(N-1) f(v) (1-F(v)) (F(v))^{N-2} \\quad \\text{}\\] (这里 \\(f_k(v)\\) 在笔记 中符号 \\(f_2(v)\\) 指的是次高阶统计量的PDF，下标2表示第二高。\\(f_3(v)\\) 同理表示第三高。) 卖方的期望收益可以写为 ： \\[R^2(r) = \\int_{r}^{\\overline{v}} v \\cdot g_{(N-1)}(v \\text{ is 2nd highest, and highest is also } \\ge v) dv + r \\cdot P(\\text{exactly one bidder has value } \\ge r)\\] 更规范的表达是： \\[R^2(r) = \\int_{r}^{\\overline{v}} v \\cdot N(N-1)f(v)(1-F(v))(F(v))^{N-2} dv + r \\cdot N (F(r))^{N-1} (1-F(r)) \\quad \\text{}\\] 这里 \\(N (F(r))^{N-1} (1-F(r))\\) 是指最高价值高于 \\(r\\)，而其余 \\(N-1\\) 个价值都低于 \\(r\\) 的概率（应为 \\(N(1-F(r))(F(r))^{N-1}\\)，即一个价值高于r，N-1个低于r的概率）。\n对 \\(R^2(r)\\) 关于 \\(r\\) 求导并令其等于0： \\[\\frac{dR^2(r)}{dr} = -r \\cdot N(N-1)f(r)(1-F(r))(F(r))^{N-2} \\quad (\\text{from first term by Leibniz})\\] \\[+ N(1-F(r))(F(r))^{N-1} \\quad (\\text{from product rule on } r \\cdot N(F(r))^{N-1}(1-F(r)))\\] \\[+ r N \\left[ -(N-1)F(r)^{N-2}f(r)(1-F(r)) - F(r)^{N-1}f(r) \\right] \\quad (\\text{this needs careful re-derivation from note})\\] 根据笔记 中给出的 \\(\\frac{dR}{dr}\\) 的各项，化简后得到： \\[\\frac{dR^2(r)}{dr} = N(1-F(r))(F(r))^{N-1} - r N f(r) (F(r))^{N-1}\\] \\((N-1)(1-F(r))F^{N-2}(r)\\) 与第一项求导的直接结果相符。中间的 \\(N(1-F(r))F^{N-1}(r)\\) 来自对第二项 \\(r P(\\text{one above r, N-1 below r})\\) 中 \\(P(\\cdot)\\)部分的求导乘以 \\(r\\) 的系数。细节推导见”思考过程”。) 令 \\(\\frac{dR^2(r)}{dr} = 0\\)，且假设 \\((F(r))^{N-1}&gt;0\\)： \\[(1-F(r)) - r f(r) = 0\\] \\[r - \\frac{1-F(r)}{f(r)} = 0 \\quad \\text{}\\] 这与第一价格拍卖得到的最优保留价格条件完全相同 。这意味着在标准模型下，无论采用第一价格还是第二价格拍卖，最优保留价格的设定是相同的。\n笔记中还给出了 \\(R^1(r) = R^2(r)\\) 的一个证明概要，即在设定了（相同的）最优保留价格 \\(r\\) 的情况下，第一价格拍卖和第二价格拍卖给卖方带来的期望收益是相同的 。这个证明通常依赖于分部积分和对期望收益表达式的巧妙变形。 例如，笔记 中 \\(R^2(r)\\) 的表达式通过分部积分： \\[\\int_{r}^{\\overline{v}} v N(N-1)(1-F(v))F^{N-2}(v)f(v)dv = \\int_{r}^{\\overline{v}} v N(1-F(v)) d(F^{N-1}(v))\\] \\[= \\left[ vN(1-F(v))F^{N-1}(v) \\right]_{r}^{\\overline{v}} - \\int_{r}^{\\overline{v}} F^{N-1}(v) d(vN(1-F(v))) dv\\] \\[= -rN(1-F(r))F^{N-1}(r) - \\int_{r}^{\\overline{v}} N F^{N-1}(v) [(1-F(v)) - vf(v)] dv\\] 将此结果代回 \\(R^2(r)\\) 的表达式，并与 \\(R^1(r)\\) 的表达式进行比较，可以证明二者相等。这实际上是收益等价定理在包含最优保留价格时的体现。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#收益等价定理-revenue-equivalence-theorem",
    "href": "Lessons/byl.html#收益等价定理-revenue-equivalence-theorem",
    "title": "博弈论与机制设计",
    "section": "收益等价定理 (Revenue Equivalence Theorem)",
    "text": "收益等价定理 (Revenue Equivalence Theorem)\n收益等价定理是拍卖理论中的一个核心结论。\n该定理指出，在一系列标准假设下，任何能产生相同结果（即总是将物品分配给具有最高价值的竞标者，并且具有最低可能价值的竞标者期望支付为零）的拍卖机制，都会给卖方带来相同的期望收益 。\n标准假设通常包括 ：\n\n有 \\(N\\) 个风险中性的竞标者。\n每个竞标者 \\(i\\) 的私有价值 \\(v_i\\) 是从同一概率分布（CDF \\(F(v)\\), PDF \\(f(v)\\)）中独立抽取的，价值区间为 \\([\\underline{v}, \\overline{v}]\\)。\n竞标者只关心自己的期望盈余（价值 - 支付）。\n拍卖机制确保物品总是分配给价值最高的竞标者（效率分配）。\n价值为 \\(\\underline{v}\\) 的竞标者的期望支付为0（或期望效用为0）。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#竞标者期望效用与期望支付",
    "href": "Lessons/byl.html#竞标者期望效用与期望支付",
    "title": "博弈论与机制设计",
    "section": "竞标者期望效用与期望支付",
    "text": "竞标者期望效用与期望支付\n考虑一个对称的、单调递增的均衡报价（或行为）策略。令 \\(\\Pi(v)\\) 为一个类型为 \\(v\\) 的竞标者的期望效用。 笔记中给出的一个设定是 ： \\(\\Pi_1(\\tilde{v}_1, v_1) = P(\\text{以类型 } \\tilde{v}_1 \\text{ 获胜}) v_1 - E[\\text{支付} | \\text{以类型 } \\tilde{v}_1 \\text{ 获胜并支付}]\\) 假设 \\(P(\\text{以类型 } \\tilde{v}_1 \\text{ 获胜}) = (F(\\tilde{v}_1))^{N-1}\\) (这是当其他 \\(N-1\\) 人价值都低于 \\(\\tilde{v}_1\\) 时发生的，例如在第一价格或第二价格拍卖中，如果其他人按其价值的某个增函数出价)。 令 \\(T(\\tilde{v}_1)\\) 是当竞标者表现得像类型 \\(\\tilde{v}_1\\) 并获胜时的期望支付。 则 \\(\\Pi_1(\\tilde{v}_1, v_1) = (F(\\tilde{v}_1))^{N-1} v_1 - T(\\tilde{v}_1)\\) (这里的 \\(T(\\tilde{v}_1)\\) 是总期望支付，而非条件期望支付)。 (注：更标准的包络定理应用是 \\(\\frac{d\\Pi(v)}{dv} = P(\\text{类型v获胜})\\)。笔记中的形式略有不同，但旨在得到支付函数。)\n根据笔记 ，通过优化 \\(\\tilde{v}_1\\) 得到一阶条件，在 \\(\\tilde{v}_1=v_1\\) 时： \\[\\frac{\\partial \\Pi_1}{\\partial \\tilde{v}_1} = \\frac{d(F(v_1))^{N-1}}{dv_1} v_1 - T'(v_1) = 0\\] (这里假设 \\(T(\\tilde{v}_1)\\) 是类型 \\(\\tilde{v}_1\\) 的总期望支付函数，而不仅仅是获胜时的支付。) 所以，期望支付函数 \\(T(v_1)\\) 的导数为： \\[T'(v_1) = v_1 \\frac{d(F(v_1))^{N-1}}{dv_1} \\quad \\text{}\\] 积分可得 \\(T(v_1)\\)： \\[T(v) = T(\\underline{v}) + \\int_{\\underline{v}}^{v} t \\frac{d(F(t))^{N-1}}{dt} dt \\quad \\text{}\\] 令 \\(H(v) = \\int_{\\underline{v}}^{v} t ( (F(t))^{N-1} )' dt\\)。则 \\(T(v) = T(\\underline{v}) + H(v)\\) 。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#卖方总期望收益",
    "href": "Lessons/byl.html#卖方总期望收益",
    "title": "博弈论与机制设计",
    "section": "卖方总期望收益",
    "text": "卖方总期望收益\n卖方的总期望收益 \\(R\\) 是所有 \\(N\\) 个竞标者的期望支付之和。由于对称性， \\[R = N \\int_{\\underline{v}}^{\\overline{v}} T(v) f(v) dv \\quad \\text{}\\] \\[R = N \\int_{\\underline{v}}^{\\overline{v}} (T(\\underline{v}) + H(v)) f(v) dv\\] \\[R = N T(\\underline{v}) \\cdot \\int_{\\underline{v}}^{\\overline{v}} f(v) dv + N \\int_{\\underline{v}}^{\\overline{v}} H(v) f(v) dv\\] \\[R = N T(\\underline{v}) + N \\int_{\\underline{v}}^{\\overline{v}} H(v) f(v) dv \\quad \\text{(因为 } \\int f(v)dv = 1 \\text{)} \\quad \\text{}\\]\n如果对于所有满足上述条件的拍卖机制，最低类型 \\(\\underline{v}\\) 的竞标者的期望支付 \\(T(\\underline{v})\\) 都相同（通常为0），那么这些拍卖机制给卖方带来的总期望收益 \\(R\\) 也将相同 。 例如，在第一价格拍卖、第二价格拍卖和全支付拍卖中（在满足效率分配和 \\(T(\\underline{v})=0\\) 条件下），卖方的期望收益是相同的 。这就是收益等价定理的核心内容。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#第一价格共同价值拍卖",
    "href": "Lessons/byl.html#第一价格共同价值拍卖",
    "title": "博弈论与机制设计",
    "section": "第一价格共同价值拍卖",
    "text": "第一价格共同价值拍卖\n在第一价格密封投标拍卖 (First-Price Sealed-Bid Auction) 中，竞拍者同时提交他们的出价，而不知道其他人的出价。出价最高的竞拍者赢得物品，并支付其自己的出价金额。\n\n情况一：两个竞拍者 (N=2)\n让我们考虑一个有两个竞拍者的简单情景。\n\n信号 (Signals)：每个竞拍者 \\(i \\in \\{1,2\\}\\) 收到一个信号 \\(s_i\\)。假设信号是独立同分布 (IID) 的，服从 \\([0,1]\\) 上的均匀分布 (Uniform Distribution)，即 \\(s_i \\sim \\text{IID U}[0,1]\\)。累积分布函数 (CDF) 为 \\(F(x)=x\\)，概率密度函数 (PDF) 为 \\(f(x)=1\\) (对于 \\(x \\in [0,1]\\))。\n共同价值 (Common Value)：物品的共同价值为 \\(V = s_1 + s_2\\)。\n竞标策略 (Bidding Strategy)：假设竞拍者采用对称且严格递增的竞标函数 \\(B(s_i)\\)，其中 \\(b_i = B(s_i)\\) 是拥有信号 \\(s_i\\) 的竞拍者 \\(i\\) 的出价。\n\n竞拍者1的期望利润： 假设竞拍者1的真实信号是 \\(s_1\\)，但他考虑如同其信号为 \\(\\tilde{s}_1\\) 那样出价，即提交出价 \\(B(\\tilde{s}_1)\\)。如果竞拍者1的出价高于竞拍者2的出价，即 \\(B(\\tilde{s}_1) &gt; B(s_2)\\)，则竞拍者1获胜。由于 \\(B(\\cdot)\\) 是递增的，这等价于 \\(\\tilde{s}_1 &gt; s_2\\)。 竞拍者1的期望利润 \\(\\pi^1\\) 为： \\[\\pi^1(\\tilde{s}_1, s_1) = P(\\text{获胜}) \\times [E(\\text{价值} | s_1, \\text{获胜}) - \\text{支付价格}]\\] \\[\\pi^1(\\tilde{s}_1, s_1) = P(s_2 &lt; \\tilde{s}_1) \\times [E(s_1+s_2 | s_1, s_2 &lt; \\tilde{s}_1) - B(\\tilde{s}_1)]\\] 鉴于 \\(s_2 \\sim U[0,1]\\):\n\n\\(P(s_2 &lt; \\tilde{s}_1) = F(\\tilde{s}_1) = \\tilde{s}_1\\) (假设 \\(\\tilde{s}_1 \\in [0,1]\\))。\n\\(E(s_2 | s_2 &lt; \\tilde{s}_1) = \\frac{\\tilde{s}_1}{2}\\) (这是 \\(U[0, \\tilde{s}_1]\\) 分布的均值)。\n\n所以，期望利润函数为： \\[\\pi^1(\\tilde{s}_1, s_1) = \\tilde{s}_1 \\left( s_1 + \\frac{\\tilde{s}_1}{2} - B(\\tilde{s}_1) \\right)\\]\n推导均衡竞标策略 \\(B(s_1)\\): 在对称贝叶斯纳什均衡中，每个竞拍者选择 \\(\\tilde{s}_1 = s_1\\) 以最大化其利润。我们可以使用包络定理 (Envelope Theorem)。对于拥有信号 \\(s_1\\) 的竞拍者1，其优化后的利润为 \\(\\pi^*(s_1) = \\pi^1(s_1, s_1)\\)。 根据包络定理： \\[\\frac{d\\pi^*(s_1)}{ds_1} = \\left. \\frac{\\partial \\pi^1(\\tilde{s}_1, s_1)}{\\partial s_1} \\right|_{\\tilde{s}_1=s_1}\\] 从 \\(\\pi^1(\\tilde{s}_1, s_1) = \\tilde{s}_1 s_1 + \\frac{\\tilde{s}_1^2}{2} - \\tilde{s}_1 B(\\tilde{s}_1)\\)，我们有 \\(\\frac{\\partial \\pi^1(\\tilde{s}_1, s_1)}{\\partial s_1} = \\tilde{s}_1\\)。 因此，当 \\(\\tilde{s}_1=s_1\\) 时： \\[\\frac{d\\pi^*(s_1)}{ds_1} = s_1\\] 对 \\(s_1\\) 积分，并假设 \\(\\pi^*(0)=0\\) (信号为0的竞拍者期望利润为零)： \\[\\pi^*(s_1) = \\int_0^{s_1} x dx = \\frac{1}{2}s_1^2\\] 我们也知道，根据定义，当 \\(\\tilde{s}_1 = s_1\\) 时： \\[\\pi^*(s_1) = s_1 \\left( s_1 + \\frac{s_1}{2} - B(s_1) \\right) = \\frac{3}{2}s_1^2 - s_1 B(s_1)\\] 令 \\(\\pi^*(s_1)\\) 的两个表达式相等： \\[\\frac{3}{2}s_1^2 - s_1 B(s_1) = \\frac{1}{2}s_1^2\\] \\[s_1^2 = s_1 B(s_1)\\] 对于 \\(s_1 &gt; 0\\)，这意味着 \\(B(s_1) = s_1\\)。 所以，对称均衡竞标策略是每个竞拍者出价等于其信号值。\n使用一阶条件 (FOC) 的替代推导： 对 \\(\\pi^1(\\tilde{s}_1, s_1)\\) 关于 \\(\\tilde{s}_1\\) 求导，并令 \\(\\tilde{s}_1=s_1\\) 且导数为0。 \\[\\frac{\\partial \\pi^1}{\\partial \\tilde{s}_1} = \\left( s_1 + \\frac{\\tilde{s}_1}{2} - B(\\tilde{s}_1) \\right) + \\tilde{s}_1 \\left( \\frac{1}{2} - B'(\\tilde{s}_1) \\right) = s_1 + \\tilde{s}_1 - B(\\tilde{s}_1) - \\tilde{s}_1 B'(\\tilde{s}_1)\\] 令 \\(\\tilde{s}_1=s_1\\) 且 \\(\\frac{\\partial \\pi^1}{\\partial \\tilde{s}_1}=0\\): \\[2s_1 - B(s_1) - s_1 B'(s_1) = 0\\] 这是一个一阶线性微分方程： \\((s_1 B(s_1))' = 2s_1\\)。 积分得到 \\(s_1 B(s_1) = \\int 2x dx = s_1^2 + C\\)。 使用边界条件 \\(B(0)=0\\) (或者当 \\(s_1 \\to 0\\) 时 \\(B(s_1)\\) 不为无穷大)，则 \\(C=0\\)。 所以，\\(s_1 B(s_1) = s_1^2\\)，这意味着对于 \\(s_1&gt;0\\)，\\(B(s_1)=s_1\\)。\n\n\n情况二：N 个竞拍者\n现在，考虑 \\(N\\) 个竞拍者。\n\n信号 (Signals)：\\(s_i \\in [\\underline{s}, \\bar{s}]\\) 是独立同分布的，其累积分布函数为 \\(F(\\cdot)\\)，概率密度函数为 \\(f(\\cdot)\\)。\n共同价值 (Common Value)：\\(V = \\sum_{i=1}^N s_i\\)。\n竞标策略 (Bidding Strategy)：对称且递增的 \\(B(s_i)\\)。\n\n竞拍者1的期望利润： 拥有信号 \\(s_1\\) 的竞拍者1考虑出价 \\(B(\\tilde{s}_1)\\)。如果 \\(B(\\tilde{s}_1)\\) 是最高出价，则竞拍者1获胜，这意味着 \\(\\tilde{s}_1\\) 大于所有其他 \\(N-1\\) 个信号 \\(s_j\\) (\\(j \\neq 1\\))。此事件的概率为 \\(P(\\max_{j \\neq 1} s_j &lt; \\tilde{s}_1) = [F(\\tilde{s}_1)]^{N-1}\\)。 期望利润为： \\[\\pi^1(\\tilde{s}_1, s_1) = [F(\\tilde{s}_1)]^{N-1} \\left( E\\left[\\sum_{k=1}^N s_k \\middle| s_1, \\max_{j \\neq 1} s_j &lt; \\tilde{s}_1 \\right] - B(\\tilde{s}_1) \\right)\\] \\[E\\left[\\sum_{k=1}^N s_k \\middle| s_1, \\max_{j \\neq 1} s_j &lt; \\tilde{s}_1 \\right] = s_1 + (N-1) E[s_j | s_j &lt; \\tilde{s}_1]\\] 其中 \\(E[s_j | s_j &lt; \\tilde{s}_1] = \\int_{\\underline{s}}^{\\tilde{s}_1} x \\frac{f(x)}{F(\\tilde{s}_1)} dx\\)。 所以， \\[\\begin{aligned}\n\\pi^1(\\tilde{s}_1, s_1) &= [F(\\tilde{s}_1)]^{N-1} \\left( s_1 + (N-1) \\frac{\\int_{\\underline{s}}^{\\tilde{s}_1} x f(x) dx}{F(\\tilde{s}_1)} - B(\\tilde{s}_1) \\right) \\\\\n&= [F(\\tilde{s}_1)]^{N-1} s_1 + (N-1)[F(\\tilde{s}_1)]^{N-2} \\int_{\\underline{s}}^{\\tilde{s}_1} x f(x) dx - [F(\\tilde{s}_1)]^{N-1} B(\\tilde{s}_1)\n\\end{aligned}\\]\n推导均衡竞标策略 \\(B(s_1)\\): 令 \\(\\pi^*(s_1) = \\pi^1(s_1, s_1)\\) 为均衡利润。根据包络定理： \\[\\frac{d\\pi^*(s_1)}{ds_1} = \\left. \\frac{\\partial \\pi^1(\\tilde{s}_1, s_1)}{\\partial s_1} \\right|_{\\tilde{s}_1=s_1}\\] 从 \\(\\pi^1(\\tilde{s}_1, s_1)\\) 的表达式可知，\\(\\frac{\\partial \\pi^1}{\\partial s_1} = [F(\\tilde{s}_1)]^{N-1}\\)。 所以，当 \\(\\tilde{s}_1=s_1\\) 时： \\[\\frac{d\\pi^*(s_1)}{ds_1} = [F(s_1)]^{N-1}\\] 从 \\(\\underline{s}\\) 积分 (假设 \\(\\pi^*(\\underline{s})=0\\)，即具有最低可能信号的竞拍者的期望利润为零)： \\[\\pi^*(s_1) = \\int_{\\underline{s}}^{s_1} [F(x)]^{N-1} dx\\] 根据定义，均衡利润也为： \\[\\pi^*(s_1) = [F(s_1)]^{N-1} s_1 + (N-1)[F(s_1)]^{N-2} \\int_{\\underline{s}}^{s_1} x f(x) dx - [F(s_1)]^{N-1} B(s_1)\\] 令 \\(\\pi^*(s_1)\\) 的两个表达式相等，并解出 \\(B(s_1)\\)： \\[[F(s_1)]^{N-1} B(s_1) = [F(s_1)]^{N-1} s_1 + (N-1)[F(s_1)]^{N-2} \\int_{\\underline{s}}^{s_1} x f(x) dx - \\int_{\\underline{s}}^{s_1} [F(x)]^{N-1} dx\\] \\[B(s_1) = s_1 + (N-1)\\frac{\\int_{\\underline{s}}^{s_1} x f(x) dx}{F(s_1)} - \\frac{\\int_{\\underline{s}}^{s_1} [F(x)]^{N-1} dx}{[F(s_1)]^{N-1}}\\] 这是第一价格共同价值拍卖中的一般对称均衡竞标策略。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#第二价格共同价值拍卖",
    "href": "Lessons/byl.html#第二价格共同价值拍卖",
    "title": "博弈论与机制设计",
    "section": "第二价格共同价值拍卖",
    "text": "第二价格共同价值拍卖\n在第二价格密封投标拍卖 (Second-Price Sealed-Bid Auction)，也称为维克里拍卖 (Vickrey Auction) 中，竞拍者提交密封出价。出价最高的竞拍者获胜，但支付第二高出价的价格。\n\n情况一：两个竞拍者 (N=2)，价值 \\(V=s_1+s_2\\)\n\n信号 (Signals)：\\(s_i \\sim \\text{IID U}[0,1]\\)。\n共同价值 (Common Value)：\\(V = s_1 + s_2\\)。\n声称的均衡策略 (Claimed Equilibrium Strategy)：\\(B(s_i) = 2s_i\\)。\n\n验证 \\(B(s_i) = 2s_i\\)： 假设竞拍者2采用策略 \\(B_2(s_2) = 2s_2\\)。拥有信号 \\(s_1\\) 的竞拍者1选择出价 \\(b_1\\) 以最大化其期望利润。 如果 \\(b_1 &gt; B_2(s_2) = 2s_2\\)，则竞拍者1获胜，这意味着 \\(s_2 &lt; b_1/2\\)。 如果竞拍者1获胜，他支付 \\(B_2(s_2) = 2s_2\\)。他的利润为 \\(V - 2s_2 = (s_1+s_2) - 2s_2 = s_1-s_2\\)。 竞拍者1出价 \\(b_1\\) 的期望利润为 (假设 \\(b_1/2 \\le 1\\)，即 \\(b_1 \\le 2\\))： \\[E[\\pi_1(b_1)] = \\int_0^{b_1/2} (s_1 - s_2) f(s_2) ds_2\\] 由于 \\(s_2 \\sim U[0,1]\\)，\\(f(s_2)=1\\)： \\[E[\\pi_1(b_1)] = \\int_0^{b_1/2} (s_1 - s_2) ds_2 = \\left[ s_1 s_2 - \\frac{s_2^2}{2} \\right]_0^{b_1/2} = s_1 \\frac{b_1}{2} - \\frac{(b_1/2)^2}{2} = \\frac{s_1 b_1}{2} - \\frac{b_1^2}{8}\\] 为了最大化关于 \\(b_1\\) 的期望利润，我们取一阶条件： \\[\\frac{\\partial E[\\pi_1(b_1)]}{\\partial b_1} = \\frac{s_1}{2} - \\frac{2b_1}{8} = \\frac{s_1}{2} - \\frac{b_1}{4}\\] 令其为零： \\[\\frac{s_1}{2} - \\frac{b_1}{4} = 0 \\implies b_1 = 2s_1\\] 因此，如果竞拍者2出价 \\(2s_2\\)，竞拍者1的最佳反应是出价 \\(2s_1\\)。这证实了 \\(B(s_i)=2s_i\\) 是一个对称贝叶斯纳什均衡策略。\n\n\n情况二：两个竞拍者 (N=2)，一般价值函数 \\(V(s_1,s_2)\\)\n假设一个一般的对称价值函数 \\(V(s_1,s_2) = V(s_2,s_1)\\)，且 \\(\\frac{\\partial V}{\\partial s_i} &gt; 0\\)。竞拍者使用对称、递增的竞标函数 \\(B(s_i)\\)。\n竞拍者1的期望利润： 拥有信号 \\(s_1\\) 的竞拍者1考虑提交对应于类型 \\(\\tilde{s}_1\\) 的出价，即 \\(B(\\tilde{s}_1)\\)。竞拍者2出价 \\(B(s_2)\\)。 如果 \\(B(\\tilde{s}_1) &gt; B(s_2)\\)，或 \\(\\tilde{s}_1 &gt; s_2\\) (因为 \\(B(\\cdot)\\) 递增)，则竞拍者1获胜。如果获胜，他支付 \\(B(s_2)\\)。 期望利润 \\(\\pi^1(\\tilde{s}_1, s_1)\\) 为： \\[\\pi^1(\\tilde{s}_1, s_1) = \\int_{\\underline{s}}^{\\tilde{s}_1} [V(s_1, s_2) - B(s_2)] f(s_2) ds_2\\] 注意：\\(s_2 \\le \\tilde{s}_1\\) 的概率为 \\(F(\\tilde{s}_1)\\)。该表达式也可以写成： \\[\\pi^1(\\tilde{s}_1, s_1) = F(\\tilde{s}_1) \\left( E[V(s_1,s_2)|s_1, s_2 \\le \\tilde{s}_1] - E[B(s_2)|s_2 \\le \\tilde{s}_1] \\right)\\] 展开后即为： \\[\\pi^1(\\tilde{s}_1, s_1) = \\int_{\\underline{s}}^{\\tilde{s}_1} V(s_1,s_2)f(s_2)ds_2 - \\int_{\\underline{s}}^{\\tilde{s}_1} B(s_2)f(s_2)ds_2\\]\n推导均衡竞标策略 \\(B(s_1)\\): 为了找到最优的 \\(\\tilde{s}_1\\)，我们对 \\(\\pi^1(\\tilde{s}_1, s_1)\\) 关于 \\(\\tilde{s}_1\\) 求导 (使用莱布尼茨积分法则)： \\[\\frac{\\partial \\pi^1(\\tilde{s}_1, s_1)}{\\partial \\tilde{s}_1} = [V(s_1, \\tilde{s}_1) - B(\\tilde{s}_1)] f(\\tilde{s}_1)\\] 在均衡中，竞拍者会选择 \\(\\tilde{s}_1=s_1\\)，并且此导数必须为零以实现利润最大化： \\[[V(s_1, s_1) - B(s_1)] f(s_1) = 0\\] 假设在相关信号范围内 \\(f(s_1) &gt; 0\\) (即信号的概率密度不为零)，则必须有： \\[B(s_1) = V(s_1, s_1)\\] 这意味着，在两人第二价格共同价值拍卖中，均衡策略是：每个竞拍者 \\(i\\) 的出价等于”假设另一个竞拍者的信号 \\(s_j\\) 与自己的信号 \\(s_i\\) 相同时，物品的价值”。\n例子：如果 \\(V(s_1,s_2) = s_1+s_2\\)。那么 \\(B(s_1) = V(s_1,s_1) = s_1+s_1 = 2s_1\\)。这与第3.1节中针对特定价值函数推导出的结果一致。\n\n\nN 个竞拍者 (\\(N \\ge 2\\)) 的讨论\n规则 \\(B(s_1) = V(s_1,s_1)\\) 特定于 \\(N=2\\) 的情况，其中 \\(V(s_1,s_1)\\) 作为具有两个相同参数的价值函数是明确定义的。对于 \\(N &gt; 2\\) 个竞拍者，这个规则如何推广？\n考虑共同价值 \\(V = \\sum_{i=1}^N s_i\\)。\n\n对于 \\(N=2\\)，\\(B(s_1) = 2s_1\\)。\n对于 \\(N&gt;2\\)，如果有人简单地将 \\(V(s_1,s_1)\\) 的想法扩展到 \\(V(s_1,s_1,\\dots,s_1)\\) (即假设所有其他 \\(N-1\\) 个人的信号都等于 \\(s_1\\))，这将意味着 \\(B(s_1) = Ns_1\\)。 然而，\\(Ns_1\\) 通常不是此模型中 \\(N&gt;2\\) 时的均衡竞标策略。原始笔记在与 \\(N=2\\) 时 \\(2s_1\\) 的结果比较时，正确地指出对于 \\(N&gt;2\\)，\\(B(s_1) \\neq Ns_1\\)。\n\n对于对称第二价格共同价值拍卖的一个更一般的结果 (Milgrom and Weber, 1982) 是，拥有信号 \\(s_i\\) 的竞拍者 \\(i\\) 出价： \\[B(s_i) = E[V | s_i, Y_1 = s_i]\\] 其中 \\(Y_1 = \\max_{j \\neq i} s_j\\) 是其他 \\(N-1\\) 个竞拍者中的最高信号。出价是物品的期望价值，条件是基于自己的信号 \\(s_i\\) 以及 \\(s_i\\) 是其竞争对手中最高信号的值 (这是其出价对获胜或决定支付价格起作用的条件)。\n让我们将此应用于 \\(V = \\sum_{k=1}^N s_k\\)： \\[B(s_i) = E\\left[s_i + \\sum_{j \\neq i} s_j \\middle| s_i, \\max_{j \\neq i} s_j = s_i \\right]\\] \\[B(s_i) = s_i + E\\left[\\max_{j \\neq i} s_j \\middle| \\max_{j \\neq i} s_j = s_i \\right] + E\\left[\\sum_{k \\neq i, k \\text{ 不是最高信号者}} s_k \\middle| \\max_{j \\neq i} s_j = s_i \\right]\\] 给定条件 \\(\\max_{j \\neq i} s_j = s_i\\)，第二项是 \\(s_i\\)。第三项是其他 \\(N-2\\) 个信号的总和，这些信号都小于 \\(s_i\\) (因为 \\(Y_1\\) 是除了 \\(s_i\\) 以外其他信号中的最大值，且 \\(Y_1 = s_i\\)) 。 \\[B(s_i) = s_i + s_i + (N-2) E[s_k | s_k &lt; s_i] = 2s_i + (N-2) E[s_k | s_k &lt; s_i]\\] 如果信号 \\(s_k \\sim \\text{IID U}[0,1]\\)，那么 \\(E[s_k | s_k &lt; s_i] = s_i/2\\)。 所以，均衡竞标策略是： \\[B(s_i) = 2s_i + (N-2)\\frac{s_i}{2} = 2s_i + \\frac{N}{2}s_i - s_i = s_i + \\frac{N}{2}s_i = \\left(1 + \\frac{N}{2}\\right)s_i\\] 对于 \\(N=2\\)，这得到 \\(B(s_i) = (1+2/2)s_i = 2s_i\\)，这是一致的。 对于 \\(N&gt;2\\)，\\((1+N/2)s_i \\neq Ns_i\\) (例如，对于 \\(N=3\\)，\\((1+3/2)s_i = 2.5s_i\\)，而 \\(Ns_i=3s_i\\))。这证实了笔记中关于简单 \\(Ns_1\\) 规则对于 \\(N&gt;2\\) 通常不正确的论断。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#机制设计基本概念",
    "href": "Lessons/byl.html#机制设计基本概念",
    "title": "博弈论与机制设计",
    "section": "机制设计基本概念",
    "text": "机制设计基本概念\n机制设计（Mechanism Design）是经济学和博弈论的一个分支，它研究如何设计交易规则或制度（即”机制”），以在参与者具有私人信息并追求自身利益最大化的情况下，达成特定的社会或经济目标（如效率、收益最大化等）。机制设计者设定博弈的规则，而参与者在这些规则下进行策略性互动。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#显示原理",
    "href": "Lessons/byl.html#显示原理",
    "title": "博弈论与机制设计",
    "section": "显示原理",
    "text": "显示原理\n显示原理（Revelation Principle）是机制设计中的一个奠基性成果。它指出，对于任何一个间接机制（参与者可能需要进行复杂的策略性思考和行动）所能达成的任何贝叶斯纳什均衡结果，总能找到一个等价的**直接机制**（Direct Mechanism）。在直接机制中，所有参与者只需向机制设计者报告他们的私人信息（例如，对物品的真实估价），并且真实地报告其私人信息对每个参与者来说都是最优策略（即构成一个贝叶斯纳什均衡）。这个直接机制能够实现与原间接机制相同的社会选择结果（例如，谁获得物品，支付多少）。\n因此，显示原理极大地简化了机制设计问题：我们无需考虑所有可能的复杂机制，只需在所有**激励相容的直接机制**（Direct Incentive Compatible, DIC Mechanisms）中寻找最优机制即可。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#环境描述",
    "href": "Lessons/byl.html#环境描述",
    "title": "博弈论与机制设计",
    "section": "环境描述",
    "text": "环境描述\n\n参与者：有两个竞标者（Bidder），编号为 \\(i=1, 2\\)。另有一个卖方（Seller）。\n物品：卖方拥有一个不可分割的物品待售。卖方对物品的估值为0。\n竞标者估价：每个竞标者 \\(i\\) 对物品有一个私人估价 \\(v_i\\)。这些估价是独立同分布的（i.i.d.）。\n估价分布：每个竞标者的估价 \\(v_i\\) 从集合 \\(\\{1, 2\\}\\) 中抽取，具体概率为：\n\n\\(P(v_i=1) = \\frac{1}{3}\\)\n\\(P(v_i=2) = \\frac{2}{3}\\)\n\n风险态度：所有竞标者和卖方都是风险中性的（risk-neutral），即他们只关心期望收益/效用。\n机制类型：我们关注直接机制，其中竞标者报告其估价（可能真实也可能虚报）。设 \\(\\tilde{v}_i\\) 为竞标者 \\(i\\) 报告的估价。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#机制变量",
    "href": "Lessons/byl.html#机制变量",
    "title": "博弈论与机制设计",
    "section": "机制变量",
    "text": "机制变量\n一个直接机制由以下两部分定义：\n\n分配规则 (Allocation Rule) \\(P_i(\\tilde{v}_1, \\tilde{v}_2)\\): 当竞标者1报告 \\(\\tilde{v}_1\\)，竞标者2报告 \\(\\tilde{v}_2\\) 时，竞标者 \\(i\\) 获得物品的概率。 由于只有一个物品，必须满足 \\(P_1(\\tilde{v}_1, \\tilde{v}_2) + P_2(\\tilde{v}_1, \\tilde{v}_2) \\le 1\\)。如果和小于1，则表示卖方保留物品。\n支付规则 (Payment Rule) \\(T_i(\\tilde{v}_1, \\tilde{v}_2)\\): 当竞标者1报告 \\(\\tilde{v}_1\\)，竞标者2报告 \\(\\tilde{v}_2\\) 时，竞标者 \\(i\\) 向卖方支付的期望金额。\n\n我们的目标是设计 \\((P_i, T_i)\\) 以最大化卖方的期望收益，同时满足激励相容和个体理性约束。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#定义与目标",
    "href": "Lessons/byl.html#定义与目标",
    "title": "博弈论与机制设计",
    "section": "定义与目标",
    "text": "定义与目标\n激励相容约束要求，在直接机制中，每个竞标者都有动机真实地报告其私人估价。换言之，假设其他竞标者都真实报告，那么某个竞标者真实报告自己类型所获得的期望效用，应不小于其谎报任何其他类型所能获得的期望效用。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#竞标者1的ic约束",
    "href": "Lessons/byl.html#竞标者1的ic约束",
    "title": "博弈论与机制设计",
    "section": "竞标者1的IC约束",
    "text": "竞标者1的IC约束\n我们以竞标者1为例。假设竞标者2真实报告其估价 \\(v_2\\)。竞标者1的期望效用是其赢得物品的概率乘以其真实估价，减去其期望支付。 令 \\(U_1(v_1, \\tilde{v}_1)\\) 表示竞标者1真实估价为 \\(v_1\\) 但报告估价为 \\(\\tilde{v}_1\\) 时的期望效用。该期望是针对竞标者2的真实估价 \\(v_2\\) 的不同可能性计算的。 \\[U_1(v_1, \\tilde{v}_1) = E_{v_2} [P_1(\\tilde{v}_1, v_2) \\cdot v_1 - T_1(\\tilde{v}_1, v_2)]\\] 激励相容要求对于所有的 \\(v_1, \\tilde{v}_1\\): \\(U_1(v_1, v_1) \\ge U_1(v_1, \\tilde{v}_1)\\)。\n具体到本例中，对竞标者1：\n\n当真实估价 \\(v_1=1\\) 时（向上约束，防止低估价者谎报为高估价者）： 报告 \\(\\tilde{v}_1=1\\) 的期望效用 \\(\\ge\\) 报告 \\(\\tilde{v}_1=2\\) 的期望效用。 $$\n\\[\\begin{aligned}\n    & E_{v_2}[P_1(1,v_2)\\cdot 1 - T_1(1,v_2)] \\ge E_{v_2}[P_1(2,v_2)\\cdot 1 - T_1(2,v_2)] \\\\\n    \\Leftrightarrow \\quad & \\frac{1}{3}[P_1(1,1)\\cdot 1 - T_1(1,1)] + \\frac{2}{3}[P_1(1,2)\\cdot 1 - T_1(1,2)] \\\\\n    & \\ge \\frac{1}{3}[P_1(2,1)\\cdot 1 - T_1(2,1)] + \\frac{2}{3}[P_1(2,2)\\cdot 1 - T_1(2,2)] \\quad \\cdots \\quad (IC_{1 \\to 2})\n\n\\end{aligned}\\]\n$$\n当真实估价 \\(v_1=2\\) 时（向下约束，防止高估价者谎报为低估价者）： 报告 \\(\\tilde{v}_1=2\\) 的期望效用 \\(\\ge\\) 报告 \\(\\tilde{v}_1=1\\) 的期望效用。 $$\n\\[\\begin{aligned}\n    & E_{v_2}[P_1(2,v_2)\\cdot 2 - T_1(2,v_2)] \\ge E_{v_2}[P_1(1,v_2)\\cdot 2 - T_1(1,v_2)] \\\\\n    \\Leftrightarrow \\quad & \\frac{1}{3}[P_1(2,1)\\cdot 2 - T_1(2,1)] + \\frac{2}{3}[P_1(2,2)\\cdot 2 - T_1(2,2)] \\\\\n    & \\ge \\frac{1}{3}[P_1(1,1)\\cdot 2 - T_1(1,1)] + \\frac{2}{3}[P_1(1,2)\\cdot 2 - T_1(1,2)] \\quad \\cdots \\quad (IC_{2 \\to 1})\n\n\\end{aligned}\\]\n$$\n\n由于对称性，对竞标者2也存在类似的IC约束。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#期中概率与期中支付",
    "href": "Lessons/byl.html#期中概率与期中支付",
    "title": "博弈论与机制设计",
    "section": "期中概率与期中支付",
    "text": "期中概率与期中支付\n为了简化IC约束的表达，我们定义”期中”（interim）概念。期中指的是在竞标者知道自己的私人估价之后，但在知道其他竞标者估价之前。 对于竞标者1，当其报告估价为 \\(\\tilde{v}_1\\) 时：\n\n期中获胜概率 \\(P_1(\\tilde{v}_1)\\): \\[P_1(\\tilde{v}_1) = E_{v_2}[P_1(\\tilde{v}_1, v_2)] = P(v_2=1)P_1(\\tilde{v}_1,1) + P(v_2=2)P_1(\\tilde{v}_1,2)\\] 具体地： $$\n\\[\\begin{aligned}\n    P_1(1) &= \\frac{1}{3}P_1(1,1) + \\frac{2}{3}P_1(1,2) \\\\\n    P_1(2) &= \\frac{1}{3}P_1(2,1) + \\frac{2}{3}P_1(2,2)\n\n\\end{aligned}\\]\n$$\n期中期望支付 \\(T_1(\\tilde{v}_1)\\): \\[T_1(\\tilde{v}_1) = E_{v_2}[T_1(\\tilde{v}_1, v_2)] = P(v_2=1)T_1(\\tilde{v}_1,1) + P(v_2=2)T_1(\\tilde{v}_1,2)\\] 具体地： $$\n\\[\\begin{aligned}\n    T_1(1) &= \\frac{1}{3}T_1(1,1) + \\frac{2}{3}T_1(1,2) \\\\\n    T_1(2) &= \\frac{1}{3}T_1(2,1) + \\frac{2}{3}T_1(2,2)\n\n\\end{aligned}\\]\n$$",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#ic约束的简化形式",
    "href": "Lessons/byl.html#ic约束的简化形式",
    "title": "博弈论与机制设计",
    "section": "IC约束的简化形式",
    "text": "IC约束的简化形式\n使用期中量，竞标者1的IC约束可以重写为： \\[\\begin{aligned}\nP_1(1) \\cdot 1 - T_1(1) &\\ge P_1(2) \\cdot 1 - T_1(2) \\quad &(IC'_{1 \\to 2}) \\label{eq:ic1_simple} \\\\\nP_1(2) \\cdot 2 - T_1(2) &\\ge P_1(1) \\cdot 2 - T_1(1) \\quad &(IC'_{2 \\to 1}) \\label{eq:ic2_simple}\n\\end{aligned}\\]",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#ic约束的推论",
    "href": "Lessons/byl.html#ic约束的推论",
    "title": "博弈论与机制设计",
    "section": "IC约束的推论",
    "text": "IC约束的推论\n\n获胜概率的单调性 (Monotonicity of Allocation Probability): 将式 [eq:ic1_simple] 和 [eq:ic2_simple] 相加，得到： \\[P_1(1) - T_1(1) + 2P_1(2) - T_1(2) \\ge P_1(2) - T_1(2) + 2P_1(1) - T_1(1)\\] \\[P_1(1) + 2P_1(2) \\ge P_1(2) + 2P_1(1)\\] \\[P_1(2) \\ge P_1(1)\\] 这意味着，真实估价越高的竞标者，其（期中）获胜概率也应该越高（或至少不低）。这是一个普遍的结论。\n支付的关系: 从 [eq:ic1_simple] 可得: \\(T_1(2) - T_1(1) \\ge P_1(2) - P_1(1)\\)。 从 [eq:ic2_simple] 可得: \\(2(P_1(2) - P_1(1)) \\ge T_1(2) - T_1(1)\\)。 所以， \\(P_1(2) - P_1(1) \\le T_1(2) - T_1(1) \\le 2(P_1(2) - P_1(1))\\)。 在机制设计中，通常假设某些IC约束是紧的（binding），即取等号。特别是高估价类型不愿谎报为低估价类型的约束 \\((IC'_{2 \\to 1})\\) 常常被假设为紧的，用以确定支付。 如果 \\((IC'_{2 \\to 1})\\) 取紧： \\[P_1(2) \\cdot 2 - T_1(2) = P_1(1) \\cdot 2 - T_1(1)\\] \\[\\Rightarrow T_1(2) - T_1(1) = 2(P_1(2) - P_1(1))\\] 这也符合笔记中紫色箭头所指的推导。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#定义与目标-1",
    "href": "Lessons/byl.html#定义与目标-1",
    "title": "博弈论与机制设计",
    "section": "定义与目标",
    "text": "定义与目标\n个体理性约束（也称参与约束）要求，每个竞标者在真实报告其类型并参与机制时，所获得的期望效用必须是非负的。否则，竞标者可以选择不参与机制，获得0效用。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#ir约束的设定",
    "href": "Lessons/byl.html#ir约束的设定",
    "title": "博弈论与机制设计",
    "section": "IR约束的设定",
    "text": "IR约束的设定\n对于竞标者1，其IR约束为（假设其真实报告类型）： \\[\\begin{aligned}\nP_1(1) \\cdot 1 - T_1(1) &\\ge 0 \\quad &(IR_1) \\label{eq:ir1} \\\\\nP_1(2) \\cdot 2 - T_1(2) &\\ge 0 \\quad &(IR_2) \\label{eq:ir2}\n\\end{aligned}\\] 通常，为了最大化卖方收益，**最低估价类型的IR约束会取紧**，即刚好等于0。这是因为卖方希望在不违反参与约束的前提下，尽可能多地向竞标者收取费用。如果最低估价类型的IR满足，且IC满足，则更高估价类型的IR通常也会满足。 因此，我们假设 \\((IR_1)\\) 取紧： \\[P_1(1) \\cdot 1 - T_1(1) = 0 \\implies T_1(1) = P_1(1)\\]",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#支付规则的确定-结合ic和ir",
    "href": "Lessons/byl.html#支付规则的确定-结合ic和ir",
    "title": "博弈论与机制设计",
    "section": "支付规则的确定 (结合IC和IR)",
    "text": "支付规则的确定 (结合IC和IR)\n我们已经有：\n\n\\(T_1(1) = P_1(1)\\) (来自紧的 \\(IR_1\\))\n\\(T_1(2) - T_1(1) = 2(P_1(2) - P_1(1))\\) (来自紧的 \\(IC'_{2 \\to 1}\\))\n\n将 (1) 代入 (2)，得到竞标者1报告类型2时的期中支付： \\[T_1(2) = T_1(1) + 2(P_1(2) - P_1(1)) = P_1(1) + 2P_1(2) - 2P_1(1)\\] \\[T_1(2) = 2P_1(2) - P_1(1)\\] 这与笔记中对 \\(T_1(2)\\) 的推导 \\((P_1(2)-P_1(1))\\cdot 2 + P_1(1)\\) 结果一致。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#卖方期望收益函数",
    "href": "Lessons/byl.html#卖方期望收益函数",
    "title": "博弈论与机制设计",
    "section": "卖方期望收益函数",
    "text": "卖方期望收益函数\n卖方的总期望收益 \\(R\\) 是从所有竞标者处获得的期望支付之和。由于对称性，对竞标者2也存在类似的支付规则: \\(T_2(1) = P_2(1)\\) 和 \\(T_2(2) = 2P_2(2) - P_2(1)\\)。 竞标者1对卖方收益的期望贡献为 \\(E[T_1]\\) (期望是对 \\(v_1\\) 的类型取的)： \\[\\begin{aligned}\nE[T_1] &= P(v_1=1)T_1(1) + P(v_1=2)T_1(2) \\\\\n&= \\frac{1}{3} T_1(1) + \\frac{2}{3} T_1(2) \\\\\n&= \\frac{1}{3} P_1(1) + \\frac{2}{3} (2P_1(2) - P_1(1)) \\\\\n&= \\frac{1}{3} P_1(1) + \\frac{4}{3} P_1(2) - \\frac{2}{3} P_1(1) \\\\\n&= \\frac{4}{3} P_1(2) - \\frac{1}{3} P_1(1)\n\\end{aligned}\\] 卖方的总期望收益为 \\(R = E[T_1] + E[T_2]\\)： \\[R = \\left(\\frac{4}{3} P_1(2) - \\frac{1}{3} P_1(1)\\right) + \\left(\\frac{4}{3} P_2(2) - \\frac{1}{3} P_2(1)\\right)\\]",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#收益函数的展开与重组",
    "href": "Lessons/byl.html#收益函数的展开与重组",
    "title": "博弈论与机制设计",
    "section": "收益函数的展开与重组",
    "text": "收益函数的展开与重组\n现在，我们将期中获胜概率 \\(P_i(\\cdot)\\) 用基于报告类型组合 \\((\\tilde{v}_1, \\tilde{v}_2)\\) 的分配规则 \\(P_i(\\tilde{v}_1, \\tilde{v}_2)\\) 展开。 回忆： \\(P_1(1) = \\frac{1}{3}P_1(1,1) + \\frac{2}{3}P_1(1,2)\\) \\(P_1(2) = \\frac{1}{3}P_1(2,1) + \\frac{2}{3}P_1(2,2)\\) \\(P_2(1) = \\frac{1}{3}P_2(1,1) + \\frac{2}{3}P_2(2,1)\\) (竞标者2报告1，对竞标者1的类型取期望) \\(P_2(2) = \\frac{1}{3}P_2(1,2) + \\frac{2}{3}P_2(2,2)\\) (竞标者2报告2，对竞标者1的类型取期望)\n代入 \\(R\\) 的表达式： \\[\\begin{aligned}\nR = & \\frac{4}{3} \\left(\\frac{1}{3}P_1(2,1) + \\frac{2}{3}P_1(2,2)\\right) - \\frac{1}{3} \\left(\\frac{1}{3}P_1(1,1) + \\frac{2}{3}P_1(1,2)\\right) \\\\\n& + \\frac{4}{3} \\left(\\frac{1}{3}P_2(1,2) + \\frac{2}{3}P_2(2,2)\\right) - \\frac{1}{3} \\left(\\frac{1}{3}P_2(1,1) + \\frac{2}{3}P_2(2,1)\\right)\n\\end{aligned}\\] 整理各项： \\[\\begin{aligned}\nR = & \\frac{4}{9}P_1(2,1) + \\frac{8}{9}P_1(2,2) - \\frac{1}{9}P_1(1,1) - \\frac{2}{9}P_1(1,2) \\\\\n& + \\frac{4}{9}P_2(1,2) + \\frac{8}{9}P_2(2,2) - \\frac{1}{9}P_2(1,1) - \\frac{2}{9}P_2(2,1)\n\\end{aligned}\\] 按照报告的类型组合 \\((\\tilde{v}_1, \\tilde{v}_2)\\) 对各项进行重新组合，这与笔记中的方式一致：\n\n类型组合 \\((\\tilde{v}_1, \\tilde{v}_2) = (2,2)\\): 来自 \\(P_1(2,2)\\) 和 \\(P_2(2,2)\\) 的贡献是 \\(\\frac{8}{9}P_1(2,2) + \\frac{8}{9}P_2(2,2) = \\frac{8}{9}(P_1(2,2)+P_2(2,2))\\)\n类型组合 \\((\\tilde{v}_1, \\tilde{v}_2) = (2,1)\\): 来自 \\(P_1(2,1)\\) 和 \\(P_2(2,1)\\) 的贡献是 \\(\\frac{4}{9}P_1(2,1) - \\frac{2}{9}P_2(2,1)\\)\n类型组合 \\((\\tilde{v}_1, \\tilde{v}_2) = (1,2)\\): 来自 \\(P_1(1,2)\\) 和 \\(P_2(1,2)\\) 的贡献是 \\(-\\frac{2}{9}P_1(1,2) + \\frac{4}{9}P_2(1,2)\\)\n类型组合 \\((\\tilde{v}_1, \\tilde{v}_2) = (1,1)\\): 来自 \\(P_1(1,1)\\) 和 \\(P_2(1,1)\\) 的贡献是 \\(-\\frac{1}{9}P_1(1,1) - \\frac{1}{9}P_2(1,1) = -\\frac{1}{9}(P_1(1,1)+P_2(1,1))\\)\n\n所以，总期望收益可以写为： \\[\\begin{aligned}\nR = & \\frac{8}{9}(P_1(2,2)+P_2(2,2)) \\\\\n& + \\left(\\frac{4}{9}P_1(2,1) - \\frac{2}{9}P_2(2,1)\\right) \\\\\n& + \\left(-\\frac{2}{9}P_1(1,2) + \\frac{4}{9}P_2(1,2)\\right) \\\\\n& - \\frac{1}{9}(P_1(1,1)+P_2(1,1))\n\\end{aligned}\\] 这个表达式中的系数（如 \\(8/9, 4/9, -2/9, -1/9\\)）可以看作是与每种类型组合下分配物品的”虚拟估价”或”影子价格”相关的权重。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#最优分配规则的确定",
    "href": "Lessons/byl.html#最优分配规则的确定",
    "title": "博弈论与机制设计",
    "section": "最优分配规则的确定",
    "text": "最优分配规则的确定\n为了最大化期望收益 \\(R\\)，我们需要选择分配概率 \\(P_i(\\tilde{v}_1, \\tilde{v}_2)\\)。这些概率必须满足 \\(0 \\le P_i(\\tilde{v}_1, \\tilde{v}_2) \\le 1\\) 以及 \\(P_1(\\tilde{v}_1, \\tilde{v}_2) + P_2(\\tilde{v}_1, \\tilde{v}_2) \\le 1\\)。 观察 \\(R\\) 的表达式中各项的系数：\n\n当报告为 \\((\\tilde{v}_1, \\tilde{v}_2) = (2,2)\\) 时: 项为 \\(\\frac{8}{9}(P_1(2,2)+P_2(2,2))\\)。由于系数 \\(\\frac{8}{9} &gt; 0\\)，为最大化此项，应使 \\(P_1(2,2)+P_2(2,2)\\) 最大，即 \\(P_1(2,2)+P_2(2,2)=1\\)。这意味着当两个竞标者都报告高估价时，物品应该被分配出去。\n当报告为 \\((\\tilde{v}_1, \\tilde{v}_2) = (2,1)\\) 时: 项为 \\(\\frac{4}{9}P_1(2,1) - \\frac{2}{9}P_2(2,1)\\)。为最大化此项，应使 \\(P_1(2,1)=1\\) 且 \\(P_2(2,1)=0\\)。这意味着当竞标者1报告高估价、竞标者2报告低估价时，物品应该分配给竞标者1。\n当报告为 \\((\\tilde{v}_1, \\tilde{v}_2) = (1,2)\\) 时: 项为 \\(-\\frac{2}{9}P_1(1,2) + \\frac{4}{9}P_2(1,2)\\)。为最大化此项，应使 \\(P_1(1,2)=0\\) 且 \\(P_2(1,2)=1\\)。这意味着当竞标者1报告低估价、竞标者2报告高估价时，物品应该分配给竞标者2。\n当报告为 \\((\\tilde{v}_1, \\tilde{v}_2) = (1,1)\\) 时: 项为 \\(-\\frac{1}{9}(P_1(1,1)+P_2(1,1))\\)。由于系数 \\(-\\frac{1}{9} &lt; 0\\)，为最大化此项（即最小化损失），应使 \\(P_1(1,1)+P_2(1,1)\\) 最小，即 \\(P_1(1,1)+P_2(1,1)=0\\)。这意味着当两个竞标者都报告低估价时，物品不应被分配出去（卖方保留）。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#最优机制下的结果",
    "href": "Lessons/byl.html#最优机制下的结果",
    "title": "博弈论与机制设计",
    "section": "最优机制下的结果",
    "text": "最优机制下的结果\n根据上述最优分配规则：\n\n\\(P_1(1,1)=0, P_2(1,1)=0\\)\n\\(P_1(1,2)=0, P_2(1,2)=1\\)\n\\(P_1(2,1)=1, P_2(2,1)=0\\)\n\\(P_1(2,2)+P_2(2,2)=1\\)。为确定起见，可以设定多种分配方式，例如将物品确定地分配给竞标者1（\\(P_1(2,2)=1, P_2(2,2)=0\\)），或分配给竞标者2，或以某种概率分配。总收益中只关心其和。\n\n现在计算在此最优分配规则下，竞标者1的期中获胜概率和期中支付：\n\n\\(P_1(1) = \\frac{1}{3}P_1(1,1) + \\frac{2}{3}P_1(1,2) = \\frac{1}{3}(0) + \\frac{2}{3}(0) = 0\\)。\n根据 \\(T_1(1) = P_1(1)\\), 可得 \\(T_1(1) = 0\\)。\n\\(P_1(2) = \\frac{1}{3}P_1(2,1) + \\frac{2}{3}P_1(2,2)\\)。 如果采用 \\(P_1(2,2)=1, P_2(2,2)=0\\) 的分配方式（当两人都报高价时，竞标者1获得物品），则： \\(P_1(2) = \\frac{1}{3}(1) + \\frac{2}{3}(1) = 1\\)。\n根据 \\(T_1(2) = 2P_1(2) - P_1(1)\\), 可得 \\(T_1(2) = 2(1) - 0 = 2\\)。\n\n笔记中最后的 \"\\(T_1(2) = 2(\\frac{1}{3}P_1(2,1) + \\frac{2}{3}P_1(2,2))\\)\" 实际上就是将 \\(P_1(2)\\) 的定义代入 \\(T_1(2)=2P_1(2)\\) (因为 \\(P_1(1)=0\\))。\n如果当 \\((\\tilde{v}_1, \\tilde{v}_2) = (2,2)\\) 时，物品以各 \\(1/2\\) 的概率分配给竞标者1和2，即 \\(P_1(2,2)=1/2, P_2(2,2)=1/2\\)，那么： \\(P_1(2) = \\frac{1}{3}P_1(2,1) + \\frac{2}{3}P_1(2,2) = \\frac{1}{3}(1) + \\frac{2}{3}(\\frac{1}{2}) = \\frac{1}{3} + \\frac{1}{3} = \\frac{2}{3}\\)。 \\(T_1(2) = 2P_1(2) - P_1(1) = 2(\\frac{2}{3}) - 0 = \\frac{4}{3}\\)。 对称地，\\(P_2(2) = \\frac{2}{3}\\)，\\(T_2(2) = \\frac{4}{3}\\)。 这种情况下，卖方在 \\((\\tilde{v}_1, \\tilde{v}_2) = (2,2)\\) 时收到的总支付为 \\(T_1(2,2)+T_2(2,2)\\)。而期中支付 \\(T_1(2)\\) 是针对所有 \\(v_2\\) 的平均。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#拍卖设定-auction-design-by-myerson",
    "href": "Lessons/byl.html#拍卖设定-auction-design-by-myerson",
    "title": "博弈论与机制设计",
    "section": "拍卖设定 (Auction design by Myerson)",
    "text": "拍卖设定 (Auction design by Myerson)\n\n竞标者集合 (Set of bidders): \\(N = \\{1, 2, \\dots, n\\}\\)，代表有 \\(n\\) 个竞标者。\n估值/类型 (Types): 每个竞标者 \\(i\\) 对拍卖品有一个私人估值 \\(t_i\\) (也称作其类型)。该估值从区间 \\([a_i, b_i]\\) 中独立抽取，其概率密度函数 (PDF) 为 \\(f_i: [a_i, b_i] \\to \\mathbb{R}^+\\)。我们用 \\(F_i(t_i)\\) 表示其累积分布函数 (CDF)。\n\\(t = (t_1, \\dots, t_n)\\) 是所有竞标者类型组成的向量。\n\\(t_{-i} = (t_1, \\dots, t_{i-1}, t_{i+1}, \\dots, t_n)\\) 表示除竞标者 \\(i\\) 以外其他所有竞标者的类型向量。\n所有可能的类型组合的空间为 \\(T = \\underset{i=1}{\\overset{n}{\\times}} [a_i, b_i]\\)。\n由于独立性，类型向量 \\(t\\) 的联合概率密度函数为 \\(f(t) = \\prod_{j=1}^n f_j(t_j)\\)。\n除 \\(i\\) 以外其他人类型向量的联合概率密度函数为 \\(f_{-i}(t_{-i}) = \\prod_{j \\neq i} f_j(t_j)\\)。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#拍卖机制-auction-mechanism",
    "href": "Lessons/byl.html#拍卖机制-auction-mechanism",
    "title": "博弈论与机制设计",
    "section": "拍卖机制 (Auction Mechanism)",
    "text": "拍卖机制 (Auction Mechanism)\n一个拍卖机制由一对函数 \\((p, x)\\) 定义：\n\n\\(p = (p_1(t), \\dots, p_n(t))\\)：其中 \\(p_i(t)\\) 表示当所有竞标者的类型组合为 \\(t\\) 时，竞标者 \\(i\\) 赢得拍卖品的概率。必须满足 \\(\\sum_{i=1}^n p_i(t) \\le 1\\)（物品最多被一个竞标者赢得，或者不被任何人赢得）。\n\\(x = (x_1(t), \\dots, x_n(t))\\)：其中 \\(x_i(t)\\) 表示当所有竞标者的类型组合为 \\(t\\) 时，竞标者 \\(i\\) 需要支付的金额。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#显示原理-revelation-principle",
    "href": "Lessons/byl.html#显示原理-revelation-principle",
    "title": "博弈论与机制设计",
    "section": "显示原理 (Revelation Principle)",
    "text": "显示原理 (Revelation Principle)\n显示原理是拍卖理论中的一个基石。它指出：对于任何（可能是间接的、复杂的）可行拍卖机制，都存在一个等价的、可行的直接机制 (direct mechanism)，在该直接机制中：\n\n竞标者被要求直接向拍卖方汇报他们的真实类型。\n如实汇报其真实类型是每个竞标者的最优策略（即该机制是激励相容的，Incentive Compatible）。\n这个直接机制能给卖方和所有竞标者带来与原机制相同的期望效用。\n\n因此，在设计最优拍卖时，我们无需考虑所有复杂的间接机制，只需在所有激励相容的直接机制中寻找最优者。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#竞标者-i-的效用-utility-for-bidder-i",
    "href": "Lessons/byl.html#竞标者-i-的效用-utility-for-bidder-i",
    "title": "博弈论与机制设计",
    "section": "竞标者 \\(i\\) 的效用 (Utility for bidder \\(i\\))",
    "text": "竞标者 \\(i\\) 的效用 (Utility for bidder \\(i\\))\n如果竞标者 \\(i\\) 的真实类型是 \\(t_i\\)，在直接机制中，他汇报类型（我们关注他如实汇报的情况），那么他的期望效用 \\(U_i(p, x, t_i)\\) 是： \\[U_i(p, x, t_i) = \\int_{T_{-i}} (V_i(t) p_i(t) - x_i(t)) f_{-i}(t_{-i}) dt_{-i}\\] 其中 \\(V_i(t)\\) 是竞标者 \\(i\\) 在类型向量为 \\(t\\) 时对物品的估值。\n\n笔记中首先提到了一种可能带有外部性的估值形式：\\(V_i(t) = t_i + \\sum_{j \\neq i} e_j(t_j)\\)，这意味着 \\(i\\) 的估值不仅取决于自己的类型 \\(t_i\\)，还受到其他人类型 \\(t_j\\) 的影响（\\(e_j(t_j)\\) 是外部性项）。\n然而，一个重要的修正或常见假设是私人估值 (private value)模型：\\(V_i(t) = t_i\\)。这意味着物品对竞标者 \\(i\\) 的价值仅由其自身类型 \\(t_i\\) 决定。在后续推导中，我们主要采用此设定。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#卖方效用-utility-for-seller",
    "href": "Lessons/byl.html#卖方效用-utility-for-seller",
    "title": "博弈论与机制设计",
    "section": "卖方效用 (Utility for seller)",
    "text": "卖方效用 (Utility for seller)\n卖方的期望效用 \\(U_0(p, x)\\)（通常是期望收益）是： \\[U_0(p, x) = \\int_T \\left( V_0(t)\\left(1 - \\sum_{k=1}^n p_k(t)\\right) + \\sum_{k=1}^n x_k(t) \\right) f(t) dt\\] 这里：\n\n\\(V_0(t)\\) 是物品在未被卖出时，卖方对物品的估值（保留估值）。笔记中提及 \\(V_0(t) = s_0 + \\sum_{j=1}^n e_j(t_j)\\)，其中 \\(s_0\\) 是卖方的基础保留估值。\n第一项 \\(V_0(t) (1 - \\sum_{k=1}^n p_k(t))\\) 表示物品未卖出时（其概率为 \\(1 - \\sum_{k=1}^n p_k(t)\\)），卖方保留物品获得的期望估值。\n第二项 \\(\\sum_{k=1}^n x_k(t)\\) 是卖方从所有竞标者那里收到的期望总支付。\n\n为了最大化卖方收益，通常假设卖方试图最大化 \\(U_0(p, x)\\)。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#激励相容约束-ic---incentive-compatibility",
    "href": "Lessons/byl.html#激励相容约束-ic---incentive-compatibility",
    "title": "博弈论与机制设计",
    "section": "激励相容约束 (IC - Incentive Compatibility)",
    "text": "激励相容约束 (IC - Incentive Compatibility)\n在直接机制中，激励相容意味着每个竞标者如实汇报其类型 \\(t_i\\) 是其最优策略。也就是说，汇报 \\(t_i\\) 所得的期望效用，必须大于或等于谎报为任何其他类型 \\(s_i\\) 所得到的期望效用。 对于私人估值 \\(V_i(t)=t_i\\)，当真实类型为 \\(t_i\\) 时，若谎报为 \\(s_i\\)，其期望效用为 \\(\\int_{T_{-i}} (t_i p_i(s_i, t_{-i}) - x_i(s_i, t_{-i})) f_{-i}(t_{-i}) dt_{-i}\\)。 则IC约束为： \\[U_i(p, x, t_i) \\ge \\int_{T_{-i}} (t_i p_i(s_i, t_{-i}) - x_i(s_i, t_{-i})) f_{-i}(t_{-i}) dt_{-i} \\quad \\forall s_i \\in [a_i, b_i]\\] 定义竞标者 \\(i\\) 汇报类型 \\(s_i\\) 时的期望获胜概率 (interim expected probability of winning) 为： \\[Q_i(p, s_i) = \\int_{T_{-i}} p_i(s_i, t_{-i}) f_{-i}(t_{-i}) dt_{-i}\\] 通过一系列推导（基于效用函数的包络定理），可以从IC约束得到： \\[\\label{eq:envelope}\n\\frac{dU_i(p, x, t_i)}{dt_i} = Q_i(p, t_i)\\] 这个公式表明：竞标者期望效用对其类型的边际变化率，等于其在该类型下的期望获胜概率。 对 [eq:envelope] 式从类型的下限 \\(a_i\\) 积分到 \\(t_i\\)： \\[U_i(p, x, t_i) - U_i(p, x, a_i) = \\int_{a_i}^{t_i} Q_i(p, s_i) ds_i\\] 因此，竞标者的期望效用可以表示为： \\[U_i(p, x, t_i) = U_i(p, x, a_i) + \\int_{a_i}^{t_i} Q_i(p, s_i) ds_i\\] \\(U_i(p, x, a_i)\\) 是类型为最低可能值 \\(a_i\\) 的竞标者的期望效用。个体理性 (Individual Rationality, IR) 约束要求 \\(U_i(p, x, t_i) \\ge 0\\) 对所有 \\(t_i\\) 成立。由于 \\(Q_i(p, s_i) \\ge 0\\)（获胜概率非负），\\(U_i(p, x, t_i)\\) 是关于 \\(t_i\\) 非减的。因此，要满足所有类型的IR约束，只需满足最低类型 \\(a_i\\) 的IR约束，即 \\(U_i(p, x, a_i) \\ge 0\\)。为了最大化卖方收益，通常将 \\(U_i(p, x, a_i)\\) 设定为0。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#卖方期望收益-r-的改写",
    "href": "Lessons/byl.html#卖方期望收益-r-的改写",
    "title": "博弈论与机制设计",
    "section": "卖方期望收益 \\(R\\) 的改写",
    "text": "卖方期望收益 \\(R\\) 的改写\n卖方的期望收益 \\(R = U_0(p, x)\\)。为简化讨论，我们先假设卖方对物品的保留估值 \\(V_0(t) = 0\\) (即不保留物品则价值为0)，此时卖方收益完全来自竞标者的支付： \\[R = \\sum_{i=1}^n \\int_T x_i(t) f(t) dt = \\sum_{i=1}^n \\int_{a_i}^{b_i} \\left( \\int_{T_{-i}} x_i(t_i, t_{-i}) f_{-i}(t_{-i}) dt_{-i} \\right) f_i(t_i) dt_i\\] 从竞标者效用定义 \\(U_i(p, x, t_i) = \\int_{T_{-i}} (t_i p_i(t) - x_i(t)) f_{-i}(t_{-i}) dt_{-i}\\)，我们可以得到竞标者 \\(i\\) 的期望支付： \\[\\int_{T_{-i}} x_i(t) f_{-i}(t_{-i}) dt_{-i} = t_i Q_i(p, t_i) - U_i(p, x, t_i)\\] 令 \\(A_i\\) 代表竞标者 \\(i\\) 的总期望支付对卖方收益的贡献： \\[\\begin{aligned}\nA_i &= \\int_{a_i}^{b_i} \\left( t_i Q_i(p, t_i) - U_i(p, x, t_i) \\right) f_i(t_i) dt_i \\\\\n&= \\int_{a_i}^{b_i} \\left( t_i Q_i(p, t_i) - \\left( U_i(p, x, a_i) + \\int_{a_i}^{t_i} Q_i(p, s_i) ds_i \\right) \\right) f_i(t_i) dt_i \\\\\n&= \\int_{a_i}^{b_i} t_i Q_i(p, t_i) f_i(t_i) dt_i - U_i(p, x, a_i)\\int_{a_i}^{b_i}f_i(t_i)dt_i - \\int_{a_i}^{b_i} \\left( \\int_{a_i}^{t_i} Q_i(p, s_i) ds_i \\right) f_i(t_i) dt_i\n\\end{aligned}\\] 注意到 \\(\\int_{a_i}^{b_i}f_i(t_i)dt_i = 1\\)。对于最后一项，可以使用分部积分法或以下常用的积分恒等式（通过改变积分次序得到）： \\[\\int_{a_i}^{b_i} \\left( \\int_{a_i}^{t_i} Q_i(p, s_i) ds_i \\right) f_i(t_i) dt_i = \\int_{a_i}^{b_i} Q_i(p, s_i) (1 - F_i(s_i)) ds_i\\] 将此代回 \\(A_i\\) 的表达式： \\[\\begin{aligned}\nA_i &= \\int_{a_i}^{b_i} t_i Q_i(p, t_i) f_i(t_i) dt_i - \\int_{a_i}^{b_i} Q_i(p, t_i) (1 - F_i(t_i)) dt_i - U_i(p, x, a_i) \\\\\n&= \\int_{a_i}^{b_i} Q_i(p, t_i) \\left( t_i f_i(t_i) - (1 - F_i(t_i)) \\right) dt_i - U_i(p, x, a_i) \\\\\n&= \\int_{a_i}^{b_i} Q_i(p, t_i) \\left( t_i - \\frac{1 - F_i(t_i)}{f_i(t_i)} \\right) f_i(t_i) dt_i - U_i(p, x, a_i)\n\\end{aligned}\\] 将 \\(Q_i(p, t_i) = \\int_{T_{-i}} p_i(t_i, t_{-i}) f_{-i}(t_{-i}) dt_{-i}\\) 代回，并将 \\(f_i(t_i)f_{-i}(t_{-i})=f(t)\\) 合并： \\[A_i = \\int_{T} p_i(t) \\left( t_i - \\frac{1 - F_i(t_i)}{f_i(t_i)} \\right) f(t) dt - U_i(p, x, a_i)\\]",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#虚拟估值-virtual-valuation",
    "href": "Lessons/byl.html#虚拟估值-virtual-valuation",
    "title": "博弈论与机制设计",
    "section": "虚拟估值 (Virtual Valuation)",
    "text": "虚拟估值 (Virtual Valuation)\n我们定义竞标者 \\(i\\) 的虚拟估值函数 (或者称为虚拟类型) \\(\\phi_i(t_i)\\) 为： \\[\\phi_i(t_i) = t_i - \\frac{1 - F_i(t_i)}{f_i(t_i)}\\] 这个函数是迈尔森理论的核心。\\(\\frac{1 - F_i(t_i)}{f_i(t_i)}\\) 是逆风险率 (inverse hazard rate)。 那么 \\(A_i\\) 可以写成： \\[A_i = \\int_{T} p_i(t) \\phi_i(t_i) f(t) dt - U_i(p, x, a_i)\\] 卖方的总期望收益（假设 \\(U_i(p, x, a_i) = 0\\) 对所有 \\(i\\) 成立，并且考虑卖方保留物品的估值 \\(V_0(t)\\)）为： \\[\\begin{aligned}\nR &= \\sum_{i=1}^n A_i + \\int_T V_0(t)\\left(1-\\sum_{k=1}^n p_k(t)\\right)f(t)dt \\\\\n&= \\sum_{i=1}^n \\int_{T} p_i(t) \\phi_i(t_i) f(t) dt + \\int_T V_0(t)f(t)dt - \\int_T V_0(t)\\sum_{k=1}^n p_k(t)f(t)dt \\\\\n&= \\int_T \\left( \\sum_{k=1}^n p_k(t) (\\phi_k(t_k) - V_0(t)) + V_0(t) \\right) f(t) dt\n\\end{aligned}\\]",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#最优拍卖规则-optimal-auction",
    "href": "Lessons/byl.html#最优拍卖规则-optimal-auction",
    "title": "博弈论与机制设计",
    "section": "最优拍卖规则 (Optimal Auction)",
    "text": "最优拍卖规则 (Optimal Auction)\n为了最大化卖方期望收益 \\(R\\)，我们需要逐点（即对于每一个可能的类型组合 \\(t\\)）选择分配概率 \\(p_k(t)\\) 来最大化被积函数 \\(\\sum_{k=1}^n p_k(t) (\\phi_k(t_k) - V_0(t))\\)。 最优的分配规则如下：\n\n对每个竞标者 \\(k\\)，计算其有效虚拟估值 \\(\\phi_k(t_k) - V_0(t)\\)。\n将物品分配给使得这个有效虚拟估值最大的竞标者 \\(i^*\\) (即 \\(p_{i^*}^*(t)=1\\))，前提条件是这个最大值必须为非负，即 \\(\\phi_{i^*} (t_{i^*}) - V_0(t) \\ge 0\\)。\n如果所有竞标者的 \\(\\phi_k(t_k) - V_0(t)\\) 都小于0，则物品不卖出 (即 \\(p_k^*(t)=0\\) 对所有 \\(k\\))，卖方保留物品。\n\n简单来说，若定义卖方的虚拟估值为 \\(\\phi_0(t) = V_0(t)\\)（在笔记中，这可能对应 \\(e_i(t_i)\\) 或一个保留价 \\(r_0\\)），则最优规则是： 找出 \\(i^* = \\text{argmax}_{i \\in N \\cup \\{0\\}} \\{ \\phi_i(t_i) \\}\\) (这里 \\(\\phi_0(t_0)\\) 代表卖方的虚拟估值，例如一个固定的 \\(r_0\\) 或者更复杂的 \\(V_0(t)\\))。如果 \\(i^* \\in N\\) (即某个竞标者的虚拟估值最高且不低于卖方的)，则物品分配给 \\(i^*\\)。如果 \\(i^*=0\\) (卖方自己的虚拟估值最高)，则物品不卖出。 笔记中的分配规则 \\(i^* = \\text{argmax}_i \\{ t_i - e_i(t_i) - \\frac{1 - F_i(t_i)}{f_i(t_i)} \\}\\)，然后要求这个最大值非负。这等价于将 \\(e_i(t_i)\\) 视为与卖方保留估值相关的一个项。\n通常要求虚拟估值函数 \\(\\phi_i(t_i)\\) 是关于 \\(t_i\\) 严格递增的，即 \\(\\phi_i'(t_i) &gt; 0\\)。这个条件被称为正则性条件 (regularity condition)。如果分布不是正则的（例如，\\(\\phi_i(t_i)\\) 可能有下降的部分），则需要进行所谓的”熨平 (ironing)“处理，这使得分析更为复杂。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#例子和收益等价定理",
    "href": "Lessons/byl.html#例子和收益等价定理",
    "title": "博弈论与机制设计",
    "section": "例子和收益等价定理",
    "text": "例子和收益等价定理\n\n例子：均匀分布 (Uniform Distribution)\n假设竞标者 \\(i\\) 的类型 \\(t_i\\) 服从 \\([0,1]\\) 上的均匀分布 (\\(t_i \\sim U[0,1]\\))。 则：\n\n\\(F_i(t_i) = t_i\\) (CDF)\n\\(f_i(t_i) = 1\\) (PDF)\n\n其虚拟估值为： \\[\\phi_i(t_i) = t_i - \\frac{1 - t_i}{1} = t_i - 1 + t_i = 2t_i - 1\\]\n\n\n例子：独立同分布私人估值 (i.i.d. Private Values)\n如果所有竞标者的估值都是从同一个分布 \\(F(\\cdot)\\) (密度为 \\(f(\\cdot)\\)) 中独立抽取的，并且满足正则性条件 (\\(\\phi'(t) &gt; 0\\))。 此时，最优拍卖将物品分配给虚拟估值 \\(\\phi(t_i)\\) 最高的竞标者，前提是其虚拟估值不低于卖方的虚拟保留估值 (例如0，或 \\(r_0\\) 使得 \\(\\phi(r_0)=0\\))。 在这种对称i.i.d.正则环境下，常见的具体最优拍卖形式包括：\n\n带有保留价 \\(r^*\\) 的第一价格密封拍卖 (First-price sealed-bid auction with reserve price \\(r^*\\))。\n带有保留价 \\(r^*\\) 的第二价格密封拍卖 (Second-price sealed-bid auction with reserve price \\(r^*\\))。\n\n这里的保留价 \\(r^*\\) 通常设定为使得 \\(\\phi(r^*) = \\phi_0\\) (卖方的虚拟估值，若卖方保留物品价值为0，则 \\(\\phi(r^*)=0\\))。\n\n\n收益等价定理 (Revenue Equivalence Theorem)\n该定理指出：在某些条件下，不同的拍卖机制可以产生相同的卖方期望收益。标准条件如下： 假设竞标者是风险中性的，他们的私人估值是独立抽取的（可以来自不同的分布）。那么任何满足以下条件的拍卖机制，其卖方期望收益都相同：\n\n相同的分配结果： 对于任何类型组合，具有合格最高估值的竞标者赢得物品（即，物品总是分配给某个特定规则选出的赢家，例如，在对称情况下，估值最高者赢得，只要其估值超过某个保留价）。\n最低类型的期望效用相同： 所有竞标者中，类型为最低可能值 (\\(a_i\\)) 的个体，其期望效用为零 (或者某个相同的常数)。\n\n笔记中的表述为：如果所有竞标者的 \\(U_i(p,x,a_i)\\) 相同，并且对于所有类型组合 \\(t\\)，分配概率 \\(P_i(t)\\) 都相同，那么这些机制会产生相同的期望收益 \\(R\\)。\n\n\n例子：非对称竞标者 (Asymmetric Bidders)\n考虑两个竞标者 (\\(n=2\\))，具有私人估值：\n\n竞标者1: \\(t_1 \\sim U[0,1] \\implies F_1(t_1) = t_1, f_1(t_1) = 1 \\implies \\phi_1(t_1) = 2t_1 - 1\\).\n竞标者2: \\(t_2 \\sim U[0,2] \\implies F_2(t_2) = t_2/2, f_2(t_2) = 1/2 \\implies \\phi_2(t_2) = t_2 - \\frac{1 - t_2/2}{1/2} = t_2 - (2 - t_2) = 2t_2 - 2\\).\n\n假设一个具体的类型实现：\\(t_1 = 1, t_2 = 1.1\\)。 计算他们的虚拟估值：\n\n\\(\\phi_1(1) = 2(1) - 1 = 1\\).\n\\(\\phi_2(1.1) = 2(1.1) - 2 = 2.2 - 2 = 0.2\\).\n\n根据最优拍卖规则（分配给虚拟估值最高者，假设卖方保留估值为0，且两个虚拟估值都非负），由于 \\(\\phi_1(1) = 1 &gt; \\phi_2(1.1) = 0.2\\)，竞标者1赢得物品。 然而，我们注意到竞标者2的实际估值 \\(t_2 = 1.1\\) 高于竞标者1的实际估值 \\(t_1 = 1\\)。这意味着，在这个非对称竞标者的例子中，最优拍卖（旨在最大化卖方收益的拍卖）并不一定是有效率的 (allocatively efficient)。效率通常指将物品分配给对其估值最高的竞标者。 这也说明，标准的第二价格拍卖（总是将物品给予估值最高者）在这种非对称情况下，不是最优的 (not optimal for revenue maximization)，因为它不一定能最大化卖方收益。为了达到收益最大化，需要根据虚拟估值来设计分配规则和支付规则。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#图示博弈示例简化的求婚博弈",
    "href": "Lessons/byl.html#图示博弈示例简化的求婚博弈",
    "title": "博弈论与机制设计",
    "section": "图示博弈示例：简化的求婚博弈",
    "text": "图示博弈示例：简化的求婚博弈\n笔记中的图示为一个典型的动态非完全信息博弈，可以理解为一个简化的求婚博弈场景：\n\n自然 (N, Nature): 首先决定参与人1（求婚者）的类型。\n\n以概率 \\(p\\) 成为 R 型 (Rich, 富有)。\n以概率 \\(1-p\\) 成为 P 型 (Poor, 贫穷)。\n\n参与人1 (求婚者，信号发送方):\n\n知道自己的真实类型（R 或 P），此为私人信息。\n根据自己的类型选择一个行动：送 E (Expensive gift, 贵重礼物) 或 C (Cheap gift, 便宜礼物)。\n\n参与人2 (被求婚者，信号接收方):\n\n观察到参与人1选择的礼物 (E 或 C)，但不能直接观察到参与人1的真实类型 (R 或 P)。\n在观察到礼物后，参与人2会对其类型形成一个信念 (Belief)。例如，观察到贵重礼物 E，可能会使得参与人2认为求婚者是 R 型的概率增加。\n根据观察到的礼物和形成的信念，选择一个行动：M (Marry, 结婚) 或 N (Not Marry, 不结婚)。\n\n\n在这个博弈中，核心的信息不对称在于：参与人1知道自己的类型，而参与人2不知道，只能通过参与人1的行动（送礼）来推断其类型。参与人2的决策节点（例如，观察到E后决定是否结婚）构成一个信息集 (Information Set)，因为她不确定这个E是由R型还是P型发出的（除非某种类型从不选择E）。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#精炼贝叶斯均衡-perfect-bayesian-equilibrium---pbe",
    "href": "Lessons/byl.html#精炼贝叶斯均衡-perfect-bayesian-equilibrium---pbe",
    "title": "博弈论与机制设计",
    "section": "精炼贝叶斯均衡 (Perfect Bayesian Equilibrium - PBE)",
    "text": "精炼贝叶斯均衡 (Perfect Bayesian Equilibrium - PBE)\n精炼贝叶斯均衡是分析动态非完全信息博弈的主要解概念。它由参与者的策略组合和信念系统构成，并且这些策略和信念需要满足一定的理性要求。\nPBE 要求满足以下两个核心条件：\n\n信念一致性 (Belief Consistency): 在均衡路径上，当一个参与者处于某个信息集时，他对该信息集内不同节点的信念（即到达各个节点的概率）必须通过贝叶斯法则，并结合其他参与者的均衡策略以及类型的先验概率分布来计算得出。对于非均衡路径 (Out-of-Equilibrium Path)上的信息集（即在均衡中不会被到达的信息集），贝叶斯法则可能无法直接应用，PBE对此处的信念约束较弱，但通常要求信念是”合理的”。\n序贯理性 (Sequential Rationality): 在给定信念和其他参与者策略的情况下，每一位参与者在博弈的每一个可能的信息集上，其选择的行动都必须是最大化其自身期望效用的最优选择（从该信息集开始直至博弈结束）。\n\n发送方理性: 给定接收方的预期反应策略，发送方的每个类型都选择能最大化自身期望效用的行动。\n接收方理性: 给定观察到的行动以及据此形成的信念，接收方选择能最大化自身期望效用的行动。\n\n\n根据发送方在均衡中行为模式的不同，PBE可以分为：\n\n分离均衡 (Separating Equilibrium): 不同类型的发送方选择不同的行动，使得接收方可以通过观察行动完美地推断出发送方的类型。\n混同均衡 (Pooling Equilibrium): 所有类型的发送方都选择相同的行动，因此接收方在观察到该行动后无法通过行动本身更新关于发送方类型的先验信念。\n半分离/部分混同均衡 (Semi-Separating/Semi-Pooling Equilibrium): 某些类型的发送方选择相同的行动，而另一些类型选择不同的行动；或者某一类型的发送方以一定的概率混合其行动选择。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#模型设定",
    "href": "Lessons/byl.html#模型设定",
    "title": "博弈论与机制设计",
    "section": "模型设定",
    "text": "模型设定\n\n参与者:\n\n工人 (Workers, 信号发送方): 拥有关于自身生产力的私人信息。\n企业 (Firms, 信号接收方): 无法直接观察到工人的生产力。\n\n工人的生产力类型 (\\(\\theta\\)):\n\n高生产力 (\\(\\theta_H\\)): 出现概率为 \\(\\lambda\\)。\n低生产力 (\\(\\theta_L\\)): 出现概率为 \\(1-\\lambda\\)。\n假设 \\(\\theta_H &gt; \\theta_L\\)。\n\n工人的行动: 选择教育水平 \\(e \\ge 0\\)。\n企业的行动: 观察到工人的教育水平 \\(e\\) 后，形成对工人类型的信念，并提供工资 \\(w(e)\\)。在完全竞争的市场中，企业会支付等于工人预期生产力的工资。\n教育成本 (\\(C(e, \\theta)\\)): 工人获得教育水平 \\(e\\) 所需的成本，该成本也取决于工人的类型 \\(\\theta\\)。 关键的成本函数假设：\n\n\\(C(0, \\theta) = 0\\): 不受教育则成本为零。\n\\(C_e(e, \\theta) = \\frac{\\partial C(e, \\theta)}{\\partial e} &gt; 0\\): 教育的边际成本为正，即获得更高教育水平需要付出更多成本。\n\\(C_{ee}(e, \\theta) = \\frac{\\partial^2 C(e, \\theta)}{\\partial e^2} &gt; 0\\): 教育的边际成本递增（可选假设，但图中曲线常如此表示）。\n\\(C_\\theta(e, \\theta) = \\frac{\\partial C(e, \\theta)}{\\partial \\theta} &lt; 0\\): 对于相同的教育水平 \\(e\\)，高生产力工人 (\\(\\theta_H\\)) 付出的总成本更低（或至少不更高）。\n\\(C_{e\\theta}(e, \\theta) = \\frac{\\partial^2 C(e, \\theta)}{\\partial e \\partial \\theta} &lt; 0\\): 这是关键的单调信号条件 (Spence-Mirrlees Condition 或 Single-Crossing Property)。它意味着高生产力工人获得教育的边际成本更低。也就是说，\\(\\theta_H\\) 类型的人增加一个单位教育水平所付出的额外成本，要比 \\(\\theta_L\\) 类型的人少。这个性质是分离均衡能够存在的数学基础，因为它使得高生产力者通过选择较高的教育水平来”廉价地”将自己与低生产力者区分开来成为可能。\n\n工人的净效用: 工资减去教育成本，即 \\(U(w, e, \\theta) = w - C(e, \\theta)\\)。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#博弈顺序-timing",
    "href": "Lessons/byl.html#博弈顺序-timing",
    "title": "博弈论与机制设计",
    "section": "博弈顺序 (Timing)",
    "text": "博弈顺序 (Timing)\n\n自然选择工人的类型 \\(\\theta \\in \\{\\theta_L, \\theta_H\\}\\)。工人知道自己的类型，企业不知道。\n工人选择教育水平 \\(e \\ge 0\\)。\n企业观察到工人选择的教育水平 \\(e\\)，但不能直接观察到其类型 \\(\\theta\\)。企业根据 \\(e\\) 更新对工人类型的信念 \\(\\mu(\\theta|e)\\)。\n企业向工人提供工资 \\(w(e)\\)。在竞争性市场中，企业会支付等于工人预期生产力的工资：\\(w(e) = \\mu(\\theta_H|e)\\theta_H + \\mu(\\theta_L|e)\\theta_L\\)。\n工人获得净效用 \\(w(e) - C(e, \\theta)\\)。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#分离均衡-separating-equilibrium",
    "href": "Lessons/byl.html#分离均衡-separating-equilibrium",
    "title": "博弈论与机制设计",
    "section": "分离均衡 (Separating Equilibrium)",
    "text": "分离均衡 (Separating Equilibrium)\n在分离均衡中，不同类型的工人选择不同的教育水平，从而使得企业能够通过观察到的教育水平完美地识别出工人的真实生产力类型。\n\n定义与信念\n假设存在一个分离均衡，其中：\n\n高生产力工人选择教育水平 \\(e_H\\): \\(e(\\theta_H) = e_H\\)。\n低生产力工人选择教育水平 \\(e_L\\): \\(e(\\theta_L) = e_L\\)。\n且 \\(e_H \\neq e_L\\)。通常为了简化分析，假设低生产力工人选择最低的教育水平，即 \\(e_L = 0\\)。\n\n在这种情况下，企业的信念是：\n\n如果观察到教育水平 \\(e_H\\)，企业相信该工人是高生产力类型 (\\(\\theta_H\\))，因此支付工资 \\(w(e_H) = \\theta_H\\)。\n如果观察到教育水平 \\(e_L\\)，企业相信该工人是低生产力类型 (\\(\\theta_L\\))，因此支付工资 \\(w(e_L) = \\theta_L\\)。\n非均衡路径信念 (Out-of-Equilibrium Beliefs): 如果企业观察到一个既不是 \\(e_H\\) 也不是 \\(e_L\\) 的教育水平 \\(e'\\) (即 \\(e' \\notin \\{e_H, e_L\\}\\))，企业会如何判断？一个常见的支持分离均衡的信念是”悲观信念”：企业认为任何偏离均衡路径选择 \\(e'\\) 的工人都是低生产力类型 \\(\\theta_L\\)，因此支付工资 \\(w(e') = \\theta_L\\)。\n\n\n\n激励相容约束 (Incentive Compatibility Constraints - IC)\n为了使上述策略和信念构成一个PBE，每种类型的工人选择其均衡教育水平所获得的净效用，必须不低于其选择其他任何教育水平（包括模仿另一种类型）所能获得的净效用。 假设 \\(e_L = 0\\) 且 \\(C(0, \\theta)=0\\)。\n\n高生产力工人 \\((\\theta_H)\\) 的激励相容约束 (IC-H): \\(\\theta_H\\) 型工人选择 \\(e_H\\) 的净效用，不应低于他选择 \\(e_L=0\\) (从而被误认为 \\(\\theta_L\\) 类型并获得工资 \\(\\theta_L\\)) 的净效用。 \\[\\theta_H - C(e_H, \\theta_H) \\ge \\theta_L - C(0, \\theta_H)\\] 由于 \\(C(0, \\theta_H)=0\\)，上式简化为： \\[\\theta_H - C(e_H, \\theta_H) \\ge \\theta_L \\implies C(e_H, \\theta_H) \\le \\theta_H - \\theta_L\\] 这意味着高生产力工人愿意为获得工资差额 \\((\\theta_H - \\theta_L)\\) 而支付的教育成本 \\(C(e_H, \\theta_H)\\) 不能超过这个差额。这条约束定义了 \\(e_H\\) 的一个上限（对应笔记图中分离均衡部分的 \\(e_2\\)）。\n低生产力工人 \\((\\theta_L)\\) 的激励相容约束 (IC-L): \\(\\theta_L\\) 型工人选择 \\(e_L=0\\) 的净效用，不应低于他模仿 \\(\\theta_H\\) 型工人选择 \\(e_H\\) (从而被误认为是 \\(\\theta_H\\) 类型并获得工资 \\(\\theta_H\\)) 的净效用。 \\[\\theta_L - C(0, \\theta_L) \\ge \\theta_H - C(e_H, \\theta_L)\\] 由于 \\(C(0, \\theta_L)=0\\)，上式简化为： \\[\\theta_L \\ge \\theta_H - C(e_H, \\theta_L) \\implies C(e_H, \\theta_L) \\ge \\theta_H - \\theta_L\\] 这意味着低生产力工人模仿高生产力工人选择 \\(e_H\\) 所需的成本 \\(C(e_H, \\theta_L)\\) 必须足够高，使得他不值得去模仿以获取工资差额 \\((\\theta_H - \\theta_L)\\)。这条约束定义了 \\(e_H\\) 的一个下限（对应笔记图中分离均衡部分的 \\(e^*\\)，有时也记为 \\(e_1\\)）。\n\n因此，任何满足 \\(C(e_H, \\theta_L) \\ge \\theta_H - \\theta_L\\) 且 \\(C(e_H, \\theta_H) \\le \\theta_H - \\theta_L\\) 的教育水平 \\(e_H\\)（以及 \\(e_L=0\\)）都可以构成一个分离均衡。 由于 \\(C_{e\\theta} &lt; 0\\)（即 \\(C(e, \\theta_L)\\) 曲线比 \\(C(e, \\theta_H)\\) 曲线更陡峭），总能找到满足这两个条件的 \\(e_H\\) 区间。\n\n\n成本最低的分离均衡 (Least-Cost Separating Equilibrium)\n在所有可能的分离均衡中，对社会福利（或至少对高能力工人）而言最优的是成本最低的分离均衡。这发生在 \\(e_H\\) 取其可能的最小值时，即刚好满足低能力者不愿模仿的条件： \\[e_H^* \\text{ 使得 } C(e_H^*, \\theta_L) = \\theta_H - \\theta_L\\] 同时，这个 \\(e_H^*\\) 也必须满足高能力者的IC约束：\\(C(e_H^*, \\theta_H) \\le \\theta_H - \\theta_L\\)。由于 \\(C(e_H^*, \\theta_H) &lt; C(e_H^*, \\theta_L)\\) （因为 \\(\\theta_H &gt; \\theta_L\\) 且 \\(C_\\theta &lt; 0\\) 或者更直观地从 \\(C_{e\\theta}&lt;0\\) 导致两条成本曲线分离），这个条件通常是满足的。 笔记图中的 \\(e^*\\) (对应分离均衡图中的 \\(e^*\\)) 就是这样一个点。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#混同均衡-pooling-equilibrium",
    "href": "Lessons/byl.html#混同均衡-pooling-equilibrium",
    "title": "博弈论与机制设计",
    "section": "混同均衡 (Pooling Equilibrium)",
    "text": "混同均衡 (Pooling Equilibrium)\n在混同均衡中，所有类型的工人都选择相同的教育水平 \\(e^*\\)。因此，企业在观察到 \\(e^*\\) 后，无法区分工人的真实类型。\n\n定义与信念\n假设存在一个混同均衡，其中：\n\n所有类型的工人（\\(\\theta_H\\) 和 \\(\\theta_L\\)）都选择相同的教育水平 \\(e^*\\): \\(e(\\theta_H) = e(\\theta_L) = e^*\\)。\n\n在这种情况下，企业的信念是：\n\n如果观察到教育水平 \\(e^*\\)：企业知道工人是 \\(\\theta_H\\) 类型的先验概率为 \\(\\lambda\\)，是 \\(\\theta_L\\) 类型的先验概率为 \\(1-\\lambda\\)。由于无法区分，企业支付的工资是工人的期望生产力： \\[w(e^*) = \\lambda\\theta_H + (1-\\lambda)\\theta_L\\]\n非均衡路径信念: 如果企业观察到任何不同于 \\(e^*\\) 的教育水平 \\(e' \\neq e^*\\)，一个常见的支持混同均衡的信念（同样是”悲观信念”）是：企业认为选择 \\(e'\\) 的工人是低生产力类型 \\(\\theta_L\\)，因此支付工资 \\(w(e') = \\theta_L\\)。\n\n\n\n激励相容约束 (IC)\n为了使这种策略和信念构成PBE，每种类型的工人都必须觉得选择 \\(e^*\\) 并获得平均工资 \\(w(e^*)\\)，比偏离到其他教育水平（例如选择 \\(e=0\\) 并被认为是 \\(\\theta_L\\) 类型）要好。我们考虑偏离到 \\(e=0\\) 的情况，此时 \\(C(0,\\theta)=0\\) 且获得的工资为 \\(\\theta_L\\)（根据非均衡路径信念）。\n\n高生产力工人 \\((\\theta_H)\\) 的激励相容约束 (IC-H): \\(\\theta_H\\) 型工人在混同均衡中选择 \\(e^*\\) 的净效用，不应低于他偏离选择 \\(e=0\\) 的净效用。 \\[\\lambda\\theta_H + (1-\\lambda)\\theta_L - C(e^*, \\theta_H) \\ge \\theta_L - C(0, \\theta_H)\\] 由于 \\(C(0, \\theta_H)=0\\)，上式简化为： \\[\\lambda\\theta_H + (1-\\lambda)\\theta_L - C(e^*, \\theta_H) \\ge \\theta_L\\] \\[\\implies \\lambda(\\theta_H - \\theta_L) \\ge C(e^*, \\theta_H)\\] 这意味着高生产力工人在混同均衡中获得的相对于被单独识别为低生产力者的工资溢价 \\(\\lambda(\\theta_H - \\theta_L)\\)，必须足以补偿其为达到混同教育水平 \\(e^*\\) 所付出的成本 \\(C(e^*, \\theta_H)\\)。这定义了 \\(e^*\\) 的一个上限（对应笔记图中混同均衡部分的 \\(e_4\\)）。\n低生产力工人 \\((\\theta_L)\\) 的激励相容约束 (IC-L): \\(\\theta_L\\) 型工人在混同均衡中选择 \\(e^*\\) 的净效用，不应低于他偏离选择 \\(e=0\\) 的净效用。 \\[\\lambda\\theta_H + (1-\\lambda)\\theta_L - C(e^*, \\theta_L) \\ge \\theta_L - C(0, \\theta_L)\\] 由于 \\(C(0, \\theta_L)=0\\)，上式简化为： \\[\\lambda\\theta_H + (1-\\lambda)\\theta_L - C(e^*, \\theta_L) \\ge \\theta_L\\] \\[\\implies \\lambda(\\theta_H - \\theta_L) \\ge C(e^*, \\theta_L)\\] 这意味着低生产力工人在混同均衡中获得的相对于其基础工资 \\(\\theta_L\\) 的工资溢价 \\(\\lambda(\\theta_H - \\theta_L)\\)，也必须足以补偿其为达到混同教育水平 \\(e^*\\) 所付出的成本 \\(C(e^*, \\theta_L)\\)。这定义了 \\(e^*\\) 的一个上限（对应笔记图中混同均衡部分的 \\(e_3\\)）。\n\n由于 \\(C(e^*, \\theta_L) &gt; C(e^*, \\theta_H)\\) (对于 \\(e^*&gt;0\\))，所以低生产力工人的IC约束通常更为严格 (即 \\(e_3 &lt; e_4\\) 如果两者都为正)。因此，混同均衡能够存在的条件主要是由低生产力工人的IC约束决定的：\\(e^*\\) 必须满足 \\(\\lambda(\\theta_H - \\theta_L) \\ge C(e^*, \\theta_L)\\)。如果混同的教育成本 \\(e^*\\) 对于低生产力者来说太高，他宁愿选择 \\(e=0\\) 并接受 \\(\\theta_L\\) 的工资。\n一个常见的混同均衡是 \\(e^*=0\\)。此时，所有工人都不接受教育，企业支付平均工资 \\(\\lambda\\theta_H + (1-\\lambda)\\theta_L\\)。这个均衡总是存在的，只要非均衡路径信念设定为：任何 \\(e&gt;0\\) 的教育水平都被认为是 \\(\\theta_L\\) 类型发出的（这是一种极度悲观但允许的信念，足以阻止任何人偏离 \\(e^*=0\\)）。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#基本设定",
    "href": "Lessons/byl.html#基本设定",
    "title": "博弈论与机制设计",
    "section": "基本设定",
    "text": "基本设定\n\n生产力 (productivity) \\(\\theta\\): 代表工人的生产能力，分布在区间 \\([\\underline{\\theta}, \\bar{\\theta}]\\)，其分布函数为 \\(F(\\theta)\\)，密度函数为 \\(f(\\theta)\\)。\n保留工资 (reservation wage) \\(r(\\theta)\\): \\(\\theta\\)类型的工人愿意接受的最低工资。通常假设 \\(r'(\\theta) &gt; 0\\)，即生产力越高的工人，其保留工资也越高。\n企业提供的工资 \\(W\\): 企业提供一个统一的工资 \\(W\\)，所有满足 \\(r(\\theta) \\le W\\) 的工人都会被吸引并前来应聘。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#图示解释-根据图片描述",
    "href": "Lessons/byl.html#图示解释-根据图片描述",
    "title": "博弈论与机制设计",
    "section": "图示解释 (根据图片描述)",
    "text": "图示解释 (根据图片描述)\n图片的左上角图示了生产力 \\(\\theta\\) (横轴)与工资 \\(W\\) (纵轴)之间的关系。\\(r(\\theta)\\) 是一条向上倾斜的曲线/直线。当企业提供工资 \\(W\\) 时，所有保留工资低于或等于 \\(W\\) 的工人（即图中 \\(r(\\theta)\\) 曲线上 \\(W\\) 水平线以下的对应 \\(\\theta\\) 区间，记为 \\(\\{\\theta | r(\\theta) \\le W\\}\\)）会接受这份工作。企业无法直接观察到每个应聘者的真实生产力 \\(\\theta\\)。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#竞争性均衡-competitive-equilibrium",
    "href": "Lessons/byl.html#竞争性均衡-competitive-equilibrium",
    "title": "博弈论与机制设计",
    "section": "竞争性均衡 (Competitive Equilibrium)",
    "text": "竞争性均衡 (Competitive Equilibrium)\n在竞争性市场中，企业的期望利润为零。这意味着企业支付的工资 \\(W\\) 应该等于它雇佣到的工人的平均生产力。均衡条件为： \\[W = E[\\theta | r(\\theta) \\le W]\\] 即企业支付的工资，等于所有接受该工资的工人的期望生产力。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#例子1-市场失灵---market-breakdown",
    "href": "Lessons/byl.html#例子1-市场失灵---market-breakdown",
    "title": "博弈论与机制设计",
    "section": "例子1 (市场失灵 - Market Breakdown)",
    "text": "例子1 (市场失灵 - Market Breakdown)\n假设 \\(r(\\theta) = \\frac{2}{3}\\theta\\)，且 \\(\\theta \\sim U(0,1)\\) (在0到1之间均匀分布)。 那么，工人接受工资 \\(W\\) 的条件是 \\(\\frac{2}{3}\\theta \\le W \\Rightarrow \\theta \\le \\frac{3}{2}W\\)。 因此，企业雇佣的工人的期望生产力为： \\[E[\\theta | r(\\theta) \\le W] = E\\left[\\theta \\middle| \\theta \\le \\frac{3}{2}W\\right]\\] 假设 \\(\\frac{3}{2}W \\le 1\\) (即 \\(W \\le \\frac{2}{3}\\)，这样工人的生产力上限仍在1以内)。由于 \\(\\theta \\sim U(0,1)\\)，那么： \\[E\\left[\\theta \\middle| \\theta \\le \\frac{3}{2}W\\right] = \\frac{0 + \\frac{3}{2}W}{2} = \\frac{3}{4}W\\] 在均衡时，\\(W = E[\\theta | r(\\theta) \\le W]\\)，所以： \\[W = \\frac{3}{4}W\\] 这只有在 \\(W=0\\) 时成立。这意味着市场上唯一可能的均衡工资是0，此时没有工人愿意工作，市场崩溃。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#例子2-多重均衡",
    "href": "Lessons/byl.html#例子2-多重均衡",
    "title": "博弈论与机制设计",
    "section": "例子2 (多重均衡)",
    "text": "例子2 (多重均衡)\n假设 \\(r(\\theta) = \\frac{1}{3}\\theta\\)，且 \\(\\theta \\sim U(0,1)\\)。 工人接受工资 \\(W\\) 的条件是 \\(\\frac{1}{3}\\theta \\le W \\Rightarrow \\theta \\le 3W\\)。\n\n情况一：若 \\(3W \\le 1\\) (即 \\(W \\le \\frac{1}{3}\\)) \\[E[\\theta | \\theta \\le 3W] = \\frac{3W}{2}\\] 均衡时 \\(W = \\frac{3W}{2} \\Rightarrow W=0\\)。\n情况二：若 \\(3W &gt; 1\\) (即 \\(W &gt; \\frac{1}{3}\\)) 这意味着所有类型的工人 (\\(\\theta \\in [0,1]\\)) 都会被吸引。此时： \\[E[\\theta | \\theta \\in [0,1]] = \\frac{0+1}{2} = \\frac{1}{2}\\] 均衡时 \\(W = \\frac{1}{2}\\)。这个均衡是成立的，因为 \\(W=\\frac{1}{2}\\) 满足 \\(W &gt; \\frac{1}{3}\\) 的条件。\n\n因此，这个例子中存在两个均衡：\\(W=0\\) 和 \\(W=\\frac{1}{2}\\)。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#图示解释-根据图片左下角描述---多重均衡",
    "href": "Lessons/byl.html#图示解释-根据图片左下角描述---多重均衡",
    "title": "博弈论与机制设计",
    "section": "图示解释 (根据图片左下角描述 - 多重均衡)",
    "text": "图示解释 (根据图片左下角描述 - 多重均衡)\n该图的横轴是 \\(\\theta\\) (或代表平均生产力的某种指标)，纵轴是 \\(W\\)。曲线 \\(E[\\theta | r(\\theta) \\le W]\\) 表示给定工资 \\(W\\) 时，企业能吸引到的工人的平均生产力。\\(45^\\circ\\) 线表示 \\(W = E[\\theta | r(\\theta) \\le W]\\)，即均衡点。图中可能标出多个交点 \\(E_1, E_2, E_3, E_4\\)，这些都是潜在的均衡。\n\n稳定性 (Stability)\n\n如果 \\(E[\\theta | \\dots]\\) 曲线从上方穿过 \\(45^\\circ\\) 线（如 \\(E_2, E_4\\)），则该均衡是局部稳定的。\n如果 \\(E[\\theta | \\dots]\\) 曲线从下方穿过 \\(45^\\circ\\) 线（如 \\(E_3\\)），则该均衡是不稳定的。\n\n图片注释提到 \"\\(E_4\\) is the only equ for dynamic game where firms first make wage offers then workers choose the best offer\"，指出在特定动态博弈中 \\(E_4\\) 可能是最终结果。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#逆向选择-rtheta-0",
    "href": "Lessons/byl.html#逆向选择-rtheta-0",
    "title": "博弈论与机制设计",
    "section": "逆向选择 (\\(r'(\\theta) < 0\\))",
    "text": "逆向选择 (\\(r'(\\theta) &lt; 0\\))\n这是一个特殊情况，即生产力越高的工人，其保留工资反而越低。图中 \\(r(\\theta)\\) 曲线向下倾斜。企业提供工资 \\(W\\) 时，会吸引 \\(r(\\theta) \\le W\\) 的工人，这意味着会吸引生产力 \\(\\theta\\) 高于某个阈值的工人。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#寡头垄断-oligopoly",
    "href": "Lessons/byl.html#寡头垄断-oligopoly",
    "title": "博弈论与机制设计",
    "section": "寡头垄断 (Oligopoly)",
    "text": "寡头垄断 (Oligopoly)\n指市场上只有少数几家公司（寡头）进行竞争。这些公司的决策会相互影响。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#价格竞争-bertrand-competition---伯特兰竞争",
    "href": "Lessons/byl.html#价格竞争-bertrand-competition---伯特兰竞争",
    "title": "博弈论与机制设计",
    "section": "价格竞争 (Bertrand Competition - 伯特兰竞争)",
    "text": "价格竞争 (Bertrand Competition - 伯特兰竞争)\n\n核心思想\n企业通过制定价格来进行竞争。\n\n\n基本假设\n\n至少有两家企业。\n产品同质 (homogeneous product)。\n企业同时选择价格 \\(p_1, p_2\\)。\n消费者从价格较低的企业购买。若价格相同，则市场需求平均分配。\n边际生产成本 (marginal cost) 为常数 \\(c\\)。即 \\(MC = c\\)。\n\n\n\n逻辑\n如果一家企业的价格 \\(p_i &gt; c\\)，竞争对手可以通过定一个略低于 \\(p_i\\) 但仍高于 \\(c\\) 的价格来抢占所有市场份额并获得正利润。这种削价竞争会一直持续下去，直到价格被压低到边际成本的水平。\n\n\n均衡结果\n\\[p_1 = p_2 = \\dots = p_N = MC = c\\] 在伯特兰均衡中，所有企业都将价格定在边际成本水平，经济利润为零。这个结果与完全竞争市场相同。 图片中图示了水平的边际成本线 \\(c\\)，伯特兰均衡价格 \\(P=c\\)，而垄断价格 \\(P^m\\) 通常高于 \\(c\\)。\n\n\n例子与注释\n图片中提到两家企业 \\(mc_1=3, mc_2=3\\)，则均衡价格 \\(p_1=p_2=3\\)。 关于 \"\\(p1=5, p2=5-\\epsilon\\) 加价获利 (若 price 连续) No Nash equ. unless \\(P_1^m &lt; 5 \\Rightarrow P_2 = P_1^m, P_1=5\\)\" 的注释，是在特定条件下对标准伯特兰模型的讨论或扩展，可能涉及非对称成本或垄断势力。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#数量竞争-cournot-competition---古诺竞争",
    "href": "Lessons/byl.html#数量竞争-cournot-competition---古诺竞争",
    "title": "博弈论与机制设计",
    "section": "数量竞争 (Cournot Competition - 古诺竞争)",
    "text": "数量竞争 (Cournot Competition - 古诺竞争)\n\n核心思想\n企业通过选择产量来进行竞争。\n\n\n基本假设\n\n至少有两家企业 (设为企业1和企业2)。\n企业同时决定各自的产量 \\(q_1, q_2\\)。\n市场价格 \\(P\\) 由市场总产量 \\(Q = q_1 + q_2\\) 决定。线性需求函数为：\\(P(Q) = a - bQ = a - b(q_1+q_2)\\)。\n边际成本相同且为常数，\\(mc_1 = mc_2 = c\\)。\n\n\n\n企业1的利润最大化问题\n企业1的利润函数为： \\[\\pi_1(q_1, q_2) = P(q_1+q_2) \\cdot q_1 - c q_1 = [a - b(q_1+q_2)]q_1 - c q_1\\]\n\n\n一阶条件 (FOC)\n企业1选择 \\(q_1\\) 使其利润最大化，对 \\(q_1\\) 求导并令其为0: \\[\\frac{\\partial \\pi_1}{\\partial q_1} = a - 2bq_1 - bq_2 - c = 0\\]\n\n\n反应函数 (Reaction Function) \\(R_1(q_2)\\)\n从一阶条件中解出 \\(q_1\\): \\[q_1 = R_1(q_2) = \\frac{a-c-bq_2}{2b}\\] 这是企业1在给定 \\(q_2\\) 时的最优产量。\n\n\n对称性与古诺均衡\n由于企业对称，企业2的反应函数为 \\(q_2 = R_2(q_1) = \\frac{a-c-bq_1}{2b}\\)。 古诺均衡是 \\((q_1^*, q_2^*)\\) 满足 \\(q_1^* = R_1(q_2^*)\\) 和 \\(q_2^* = R_2(q_1^*)\\)。 在对称情况下，\\(q_1^* = q_2^* = q^*\\)，解得： \\[q^* = \\frac{a-c}{3b}\\] 总产量 \\(Q^* = 2q^* = \\frac{2(a-c)}{3b}\\)。 均衡价格 \\(P^* = a - bQ^* = \\frac{a+2c}{3}\\)。\n\n\n图示\n图片显示两条向下倾斜的反应函数，其交点即为古诺-纳什均衡 \\((q_1^*, q_2^*)\\)。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#斯塔克尔伯格模型-stackelberg-model",
    "href": "Lessons/byl.html#斯塔克尔伯格模型-stackelberg-model",
    "title": "博弈论与机制设计",
    "section": "斯塔克尔伯格模型 (Stackelberg Model)",
    "text": "斯塔克尔伯格模型 (Stackelberg Model)\n\n核心思想\n数量竞争，但企业决策有先后顺序：领导者 (leader) 和 跟随者 (follower)。\n\n\n基本假设\n\n两家企业，边际成本 \\(mc_1=mc_2=c\\)。需求函数 \\(P = a-bQ\\)。\n企业1 (领导者) 首先选择其产量 \\(q_1\\)。\n企业2 (跟随者) 观察到 \\(q_1\\) 后，再选择其产量 \\(q_2\\)。\n\n\n\n求解方法：逆向归纳法 (Backward Induction)\n\n第二阶段 (Stage 2 - 跟随者的决策): 企业2在观察到 \\(q_1\\) 后，选择 \\(q_2\\) 最大化其利润。其反应函数与古诺模型中相同： \\[q_2(q_1) = R_2(q_1) = \\frac{a-c-bq_1}{2b}\\] (图片中显示 \\(q_2 = \\frac{a-bq_1-C}{2b}\\)，若 \\(C\\) 代表边际成本，则一致)。\n第一阶段 (Stage 1 - 领导者的决策): 企业1预期到企业2的反应，选择 \\(q_1\\) 以最大化其利润，将 \\(R_2(q_1)\\) 代入 \\(\\pi_1\\): \\[\\pi_1(q_1) = \\left[a-b\\left(q_1 + \\frac{a-c-bq_1}{2b}\\right)\\right]q_1 - c q_1\\] 根据图片中的简化形式（扣除成本后的利润表达式）： \\(\\pi_1(q_1) = \\left(\\frac{a-c}{2} - \\frac{b}{2}q_1\\right)q_1 = \\frac{1}{2}(a-c)q_1 - \\frac{b}{2}q_1^2\\) (更完整的推导是 \\(\\pi_1 = (P(q_1+R_2(q_1)) - c)q_1 = (\\frac{a-c-bq_1}{2})q_1\\))\n对 \\(\\pi_1\\) 关于 \\(q_1\\) 求一阶条件并令其为0: \\[\\frac{d\\pi_1}{dq_1} = \\frac{1}{2}(a-c) - bq_1 = 0\\] 解得领导者产量： \\[q_1^S = \\frac{a-c}{2b}\\] 将 \\(q_1^S\\) 代入企业2的反应函数，得到跟随者的产量： \\[q_2^S = \\frac{a-c-b\\left(\\frac{a-c}{2b}\\right)}{2b} = \\frac{a-c-\\frac{a-c}{2}}{2b} = \\frac{a-c}{4b}\\]\n\n\n\n结果比较\n\n领导者产量 \\(q_1^S = \\frac{a-c}{2b}\\) (高于古诺产量)。\n跟随者产量 \\(q_2^S = \\frac{a-c}{4b}\\) (低于古诺产量)。\n总产量 \\(Q^S = q_1^S + q_2^S = \\frac{3(a-c)}{4b}\\) (高于古诺总产量)。\n领导者有先发优势，利润更高。\n\n图片中注释古诺均衡产量 \\(q_1^* = q_2^* = \\frac{a-c}{3b}\\)。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#线性城市模型-linear-city-model---hotelling-model",
    "href": "Lessons/byl.html#线性城市模型-linear-city-model---hotelling-model",
    "title": "博弈论与机制设计",
    "section": "线性城市模型 (Linear City Model - Hotelling Model)",
    "text": "线性城市模型 (Linear City Model - Hotelling Model)\n\n核心思想\n考虑空间差异和运输成本的企业竞争模型。\n\n\n基本设定\n\n消费者均匀分布在一条长度为1的线段上 (例如从0到1)。\n两家企业，企业1位于0点 (Firm 1)，企业2位于1点 (Firm 2)。\n企业边际成本 \\(mc_1=mc_2=c\\)。\n消费者购买产品需要支付运输成本，每单位距离的运输成本为 \\(t\\)。位于 \\(x\\) 处的消费者到企业1的运输成本为 \\(tx\\)，到企业2的运输成本为 \\(t(1-x)\\)。\n每个消费者购买一单位产品。\\(V\\) 是产品的价值。\n\n\n\n消费者的决策\n位于 \\(\\hat{x}\\) 的消费者在企业1和企业2之间无差异 (indifferent)，如果他从两家企业购买的总成本（价格+运输成本）相同： \\[P_1 + t\\hat{x} = P_2 + t(1-\\hat{x})\\] 解出市场分界点 \\(\\hat{x}\\) (即企业1的需求，假设总消费者数量为1)： \\[P_1 + t\\hat{x} = P_2 + t - t\\hat{x}\\] \\[2t\\hat{x} = P_2 - P_1 + t\\] \\[\\hat{x} = \\frac{P_2 - P_1 + t}{2t} = \\frac{P_2 - P_1}{2t} + \\frac{1}{2}\\] 企业1的需求 \\(D_1 = \\hat{x}\\)。企业2的需求 \\(D_2 = 1-\\hat{x}\\)。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#假设",
    "href": "Lessons/byl.html#假设",
    "title": "博弈论与机制设计",
    "section": "假设",
    "text": "假设\n\\(V\\) 足够高，以至于所有消费者都会购买产品 (\\(U(x) &gt; 0\\) for all \\(x \\in [0,1]\\))。企业同时定价 (simultaneous price setting)，且 \\(mc_1=mc_2=c\\)。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#企业1的利润最大化",
    "href": "Lessons/byl.html#企业1的利润最大化",
    "title": "博弈论与机制设计",
    "section": "企业1的利润最大化",
    "text": "企业1的利润最大化\n\\[\\pi_1(P_1, P_2) = \\hat{x}(P_1 - c) = \\left(\\frac{P_2 - P_1}{2t} + \\frac{1}{2}\\right)(P_1 - c)\\] 对 \\(P_1\\) 求一阶导数并令其为0 (FOC): \\[\\frac{\\partial \\pi_1}{\\partial P_1} = -\\frac{1}{2t}(P_1-c) + \\left(\\frac{P_2 - P_1}{2t} + \\frac{1}{2}\\right) = 0\\] 图片中整理后得到 (将 \\(\\frac{1}{2}\\) 写作 \\(\\frac{t}{2t}\\) 并合并同类项)： \\[\\frac{-P_1+c}{2t} + \\frac{P_2-P_1+t}{2t} = 0 \\quad (\\text{图片中为 } -\\frac{1}{2t}(P_1-c) + \\frac{P_2-P_1}{2t} + \\frac{1}{2}=0)\\] \\[-P_1+c + P_2-P_1+t = 0\\] \\[2P_1 = P_2 + c + t\\] 这是企业1对企业2价格的反应函数 \\(P_1(P_2)\\)。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#企业2的利润最大化",
    "href": "Lessons/byl.html#企业2的利润最大化",
    "title": "博弈论与机制设计",
    "section": "企业2的利润最大化",
    "text": "企业2的利润最大化\n企业2的需求是 \\(D_2 = 1-\\hat{x} = 1 - \\left(\\frac{P_2 - P_1}{2t} + \\frac{1}{2}\\right) = \\frac{P_1 - P_2 + t}{2t}\\)。 \\[\\pi_2(P_1, P_2) = (1-\\hat{x})(P_2 - c) = \\left(\\frac{P_1 - P_2 + t}{2t}\\right)(P_2 - c)\\] 对 \\(P_2\\) 求一阶导数并令其为0 (FOC): \\[\\frac{\\partial \\pi_2}{\\partial P_2} = -\\frac{1}{2t}(P_2-c) + \\frac{P_1 - P_2 + t}{2t} = 0\\] \\[-P_2+c + P_1-P_2+t = 0\\] \\[2P_2 = P_1 + c + t\\] 这是企业2对企业1价格的反应函数 \\(P_2(P_1)\\)。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  },
  {
    "objectID": "Lessons/byl.html#对称均衡-symmetric-equilibrium",
    "href": "Lessons/byl.html#对称均衡-symmetric-equilibrium",
    "title": "博弈论与机制设计",
    "section": "对称均衡 (Symmetric Equilibrium)",
    "text": "对称均衡 (Symmetric Equilibrium)\n由于两家企业是对称的，在一个纳什均衡中它们会定相同的价格，即 \\(P_1^* = P_2^* = P^*\\)。 将 \\(P_1 = P_2 = P\\) 代入任何一个反应函数，例如企业1的反应函数 \\(2P_1 = P_2 + c + t\\): \\[2P^* = P^* + c + t\\] \\[P^* = c + t\\] 所以，均衡时两家企业的价格都是 \\(P_1^* = P_2^* = c+t\\)。\n在这个模型中，企业会收取高于边际成本的价格。价格加成 (markup) 等于运输成本参数 \\(t\\)。运输成本 \\(t\\) 越大，产品因地理位置带来的差异化程度越高，企业就拥有更大的定价权。如果 \\(t \\to 0\\)，则 \\(P^* \\to c\\)，结果趋向于伯特兰竞争的结果。",
    "crumbs": [
      "数字化课程资源",
      "博弈论与机制设计"
    ]
  }
]